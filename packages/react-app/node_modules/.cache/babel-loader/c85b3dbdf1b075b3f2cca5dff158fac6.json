{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar events_1 = require(\"events\");\n\nfunction safeApply(handler, context, args) {\n  try {\n    Reflect.apply(handler, context, args);\n  } catch (err) {\n    // Throw error after timeout so as not to interrupt the stack\n    setTimeout(function () {\n      throw err;\n    });\n  }\n}\n\nfunction arrayClone(arr) {\n  var n = arr.length;\n  var copy = new Array(n);\n\n  for (var i = 0; i < n; i += 1) {\n    copy[i] = arr[i];\n  }\n\n  return copy;\n}\n\nvar SafeEventEmitter = /*#__PURE__*/function (_events_1$EventEmitte) {\n  _inherits(SafeEventEmitter, _events_1$EventEmitte);\n\n  var _super = _createSuper(SafeEventEmitter);\n\n  function SafeEventEmitter() {\n    _classCallCheck(this, SafeEventEmitter);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(SafeEventEmitter, [{\n    key: \"emit\",\n    value: function emit(type) {\n      var doError = type === 'error';\n      var events = this._events;\n\n      if (events !== undefined) {\n        doError = doError && events.error === undefined;\n      } else if (!doError) {\n        return false;\n      } // If there is no 'error' event listener then throw.\n\n\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      if (doError) {\n        var er;\n\n        if (args.length > 0) {\n          er = args[0];\n        }\n\n        if (er instanceof Error) {\n          // Note: The comments on the `throw` lines are intentional, they show\n          // up in Node's output if this results in an unhandled exception.\n          throw er; // Unhandled 'error' event\n        } // At least give some kind of context to the user\n\n\n        var err = new Error(\"Unhandled error.\".concat(er ? \" (\".concat(er.message, \")\") : ''));\n        err.context = er;\n        throw err; // Unhandled 'error' event\n      }\n\n      var handler = events[type];\n\n      if (handler === undefined) {\n        return false;\n      }\n\n      if (typeof handler === 'function') {\n        safeApply(handler, this, args);\n      } else {\n        var len = handler.length;\n        var listeners = arrayClone(handler);\n\n        for (var i = 0; i < len; i += 1) {\n          safeApply(listeners[i], this, args);\n        }\n      }\n\n      return true;\n    }\n  }]);\n\n  return SafeEventEmitter;\n}(events_1.EventEmitter);\n\nexports.default = SafeEventEmitter;","map":{"version":3,"sources":["index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA,IAAA,QAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AAOA,SAAS,SAAT,CAAwC,OAAxC,EAAgF,OAAhF,EAA4F,IAA5F,EAAmG;AACjG,MAAI;AACF,IAAA,OAAO,CAAC,KAAR,CAAc,OAAd,EAAuB,OAAvB,EAAgC,IAAhC;AACD,GAFD,CAEE,OAAO,GAAP,EAAY;AACZ;AACA,IAAA,UAAU,CAAC,YAAK;AACd,YAAM,GAAN;AACD,KAFS,CAAV;AAGD;AACF;;AAED,SAAS,UAAT,CAAwB,GAAxB,EAAgC;AAC9B,MAAM,CAAC,GAAG,GAAG,CAAC,MAAd;AACA,MAAM,IAAI,GAAG,IAAI,KAAJ,CAAU,CAAV,CAAb;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,CAApB,EAAuB,CAAC,IAAI,CAA5B,EAA+B;AAC7B,IAAA,IAAI,CAAC,CAAD,CAAJ,GAAU,GAAG,CAAC,CAAD,CAAb;AACD;;AACD,SAAO,IAAP;AACD;;IAEoB,gB;;;;;;;;;;;;;WACnB,cAAM,IAAN,EAAkC;AAChC,UAAI,OAAO,GAAG,IAAI,KAAK,OAAvB;AAEA,UAAM,MAAM,GAAc,KAAa,OAAvC;;AACA,UAAI,MAAM,KAAK,SAAf,EAA0B;AACxB,QAAA,OAAO,GAAG,OAAO,IAAI,MAAM,CAAC,KAAP,KAAiB,SAAtC;AACD,OAFD,MAEO,IAAI,CAAC,OAAL,EAAc;AACnB,eAAO,KAAP;AACD,OAR+B,CAUhC;;;AAVgC,wCAAX,IAAW;AAAX,QAAA,IAAW;AAAA;;AAWhC,UAAI,OAAJ,EAAa;AACX,YAAI,EAAJ;;AACA,YAAI,IAAI,CAAC,MAAL,GAAc,CAAlB,EAAqB;AAClB,UAAA,EADkB,GACZ,IADY;AAEpB;;AACD,YAAI,EAAE,YAAY,KAAlB,EAAyB;AACvB;AACA;AACA,gBAAM,EAAN,CAHuB,CAGb;AACX,SATU,CAUX;;;AACA,YAAM,GAAG,GAAG,IAAI,KAAJ,2BAA6B,EAAE,eAAQ,EAAE,CAAC,OAAX,SAAwB,EAAvD,EAAZ;AACC,QAAA,GAAW,CAAC,OAAZ,GAAsB,EAAtB;AACD,cAAM,GAAN,CAbW,CAaA;AACZ;;AAED,UAAM,OAAO,GAAG,MAAM,CAAC,IAAD,CAAtB;;AAEA,UAAI,OAAO,KAAK,SAAhB,EAA2B;AACzB,eAAO,KAAP;AACD;;AAED,UAAI,OAAO,OAAP,KAAmB,UAAvB,EAAmC;AACjC,QAAA,SAAS,CAAC,OAAD,EAAU,IAAV,EAAgB,IAAhB,CAAT;AACD,OAFD,MAEO;AACL,YAAM,GAAG,GAAG,OAAO,CAAC,MAApB;AACA,YAAM,SAAS,GAAG,UAAU,CAAC,OAAD,CAA5B;;AACA,aAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,GAApB,EAAyB,CAAC,IAAI,CAA9B,EAAiC;AAC/B,UAAA,SAAS,CAAC,SAAS,CAAC,CAAD,CAAV,EAAe,IAAf,EAAqB,IAArB,CAAT;AACD;AACF;;AAED,aAAO,IAAP;AACD;;;;EA7C2C,QAAA,CAAA,Y;;AAA9C,OAAA,CAAA,OAAA,GAAA,gBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events_1 = require(\"events\");\nfunction safeApply(handler, context, args) {\n    try {\n        Reflect.apply(handler, context, args);\n    }\n    catch (err) {\n        // Throw error after timeout so as not to interrupt the stack\n        setTimeout(() => {\n            throw err;\n        });\n    }\n}\nfunction arrayClone(arr) {\n    const n = arr.length;\n    const copy = new Array(n);\n    for (let i = 0; i < n; i += 1) {\n        copy[i] = arr[i];\n    }\n    return copy;\n}\nclass SafeEventEmitter extends events_1.EventEmitter {\n    emit(type, ...args) {\n        let doError = type === 'error';\n        const events = this._events;\n        if (events !== undefined) {\n            doError = doError && events.error === undefined;\n        }\n        else if (!doError) {\n            return false;\n        }\n        // If there is no 'error' event listener then throw.\n        if (doError) {\n            let er;\n            if (args.length > 0) {\n                [er] = args;\n            }\n            if (er instanceof Error) {\n                // Note: The comments on the `throw` lines are intentional, they show\n                // up in Node's output if this results in an unhandled exception.\n                throw er; // Unhandled 'error' event\n            }\n            // At least give some kind of context to the user\n            const err = new Error(`Unhandled error.${er ? ` (${er.message})` : ''}`);\n            err.context = er;\n            throw err; // Unhandled 'error' event\n        }\n        const handler = events[type];\n        if (handler === undefined) {\n            return false;\n        }\n        if (typeof handler === 'function') {\n            safeApply(handler, this, args);\n        }\n        else {\n            const len = handler.length;\n            const listeners = arrayClone(handler);\n            for (let i = 0; i < len; i += 1) {\n                safeApply(listeners[i], this, args);\n            }\n        }\n        return true;\n    }\n}\nexports.default = SafeEventEmitter;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}