{"ast":null,"code":"// Process *this* and _that_\n//\n'use strict'; // Insert each marker as a separate text token, and add it to delimiter list\n//\n\nmodule.exports.tokenize = function emphasis(state, silent) {\n  var i,\n      scanned,\n      token,\n      start = state.pos,\n      marker = state.src.charCodeAt(start);\n\n  if (silent) {\n    return false;\n  }\n\n  if (marker !== 0x5F\n  /* _ */\n  && marker !== 0x2A\n  /* * */\n  ) {\n    return false;\n  }\n\n  scanned = state.scanDelims(state.pos, marker === 0x2A);\n\n  for (i = 0; i < scanned.length; i++) {\n    token = state.push('text', '', 0);\n    token.content = String.fromCharCode(marker);\n    state.delimiters.push({\n      // Char code of the starting marker (number).\n      //\n      marker: marker,\n      // Total length of these series of delimiters.\n      //\n      length: scanned.length,\n      // An amount of characters before this one that's equivalent to\n      // current one. In plain English: if this delimiter does not open\n      // an emphasis, neither do previous `jump` characters.\n      //\n      // Used to skip sequences like \"*****\" in one step, for 1st asterisk\n      // value will be 0, for 2nd it's 1 and so on.\n      //\n      jump: i,\n      // A position of the token this delimiter corresponds to.\n      //\n      token: state.tokens.length - 1,\n      // If this delimiter is matched as a valid opener, `end` will be\n      // equal to its position, otherwise it's `-1`.\n      //\n      end: -1,\n      // Boolean flags that determine if this delimiter could open or close\n      // an emphasis.\n      //\n      open: scanned.can_open,\n      close: scanned.can_close\n    });\n  }\n\n  state.pos += scanned.length;\n  return true;\n};\n\nfunction postProcess(state, delimiters) {\n  var i,\n      startDelim,\n      endDelim,\n      token,\n      ch,\n      isStrong,\n      max = delimiters.length;\n\n  for (i = max - 1; i >= 0; i--) {\n    startDelim = delimiters[i];\n\n    if (startDelim.marker !== 0x5F\n    /* _ */\n    && startDelim.marker !== 0x2A\n    /* * */\n    ) {\n      continue;\n    } // Process only opening markers\n\n\n    if (startDelim.end === -1) {\n      continue;\n    }\n\n    endDelim = delimiters[startDelim.end]; // If the previous delimiter has the same marker and is adjacent to this one,\n    // merge those into one strong delimiter.\n    //\n    // `<em><em>whatever</em></em>` -> `<strong>whatever</strong>`\n    //\n\n    isStrong = i > 0 && delimiters[i - 1].end === startDelim.end + 1 && delimiters[i - 1].token === startDelim.token - 1 && delimiters[startDelim.end + 1].token === endDelim.token + 1 && delimiters[i - 1].marker === startDelim.marker;\n    ch = String.fromCharCode(startDelim.marker);\n    token = state.tokens[startDelim.token];\n    token.type = isStrong ? 'strong_open' : 'em_open';\n    token.tag = isStrong ? 'strong' : 'em';\n    token.nesting = 1;\n    token.markup = isStrong ? ch + ch : ch;\n    token.content = '';\n    token = state.tokens[endDelim.token];\n    token.type = isStrong ? 'strong_close' : 'em_close';\n    token.tag = isStrong ? 'strong' : 'em';\n    token.nesting = -1;\n    token.markup = isStrong ? ch + ch : ch;\n    token.content = '';\n\n    if (isStrong) {\n      state.tokens[delimiters[i - 1].token].content = '';\n      state.tokens[delimiters[startDelim.end + 1].token].content = '';\n      i--;\n    }\n  }\n} // Walk through delimiter list and replace text tokens with tags\n//\n\n\nmodule.exports.postProcess = function emphasis(state) {\n  var curr,\n      tokens_meta = state.tokens_meta,\n      max = state.tokens_meta.length;\n  postProcess(state, state.delimiters);\n\n  for (curr = 0; curr < max; curr++) {\n    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\n      postProcess(state, tokens_meta[curr].delimiters);\n    }\n  }\n};","map":{"version":3,"sources":["/Users/sam/Desktop/kiwik/node_modules/markdown-it/lib/rules_inline/emphasis.js"],"names":["module","exports","tokenize","emphasis","state","silent","i","scanned","token","start","pos","marker","src","charCodeAt","scanDelims","length","push","content","String","fromCharCode","delimiters","jump","tokens","end","open","can_open","close","can_close","postProcess","startDelim","endDelim","ch","isStrong","max","type","tag","nesting","markup","curr","tokens_meta"],"mappings":"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","sourcesContent":["// Process *this* and _that_\n//\n'use strict';\n\n\n// Insert each marker as a separate text token, and add it to delimiter list\n//\nmodule.exports.tokenize = function emphasis(state, silent) {\n  var i, scanned, token,\n      start = state.pos,\n      marker = state.src.charCodeAt(start);\n\n  if (silent) { return false; }\n\n  if (marker !== 0x5F /* _ */ && marker !== 0x2A /* * */) { return false; }\n\n  scanned = state.scanDelims(state.pos, marker === 0x2A);\n\n  for (i = 0; i < scanned.length; i++) {\n    token         = state.push('text', '', 0);\n    token.content = String.fromCharCode(marker);\n\n    state.delimiters.push({\n      // Char code of the starting marker (number).\n      //\n      marker: marker,\n\n      // Total length of these series of delimiters.\n      //\n      length: scanned.length,\n\n      // An amount of characters before this one that's equivalent to\n      // current one. In plain English: if this delimiter does not open\n      // an emphasis, neither do previous `jump` characters.\n      //\n      // Used to skip sequences like \"*****\" in one step, for 1st asterisk\n      // value will be 0, for 2nd it's 1 and so on.\n      //\n      jump:   i,\n\n      // A position of the token this delimiter corresponds to.\n      //\n      token:  state.tokens.length - 1,\n\n      // If this delimiter is matched as a valid opener, `end` will be\n      // equal to its position, otherwise it's `-1`.\n      //\n      end:    -1,\n\n      // Boolean flags that determine if this delimiter could open or close\n      // an emphasis.\n      //\n      open:   scanned.can_open,\n      close:  scanned.can_close\n    });\n  }\n\n  state.pos += scanned.length;\n\n  return true;\n};\n\n\nfunction postProcess(state, delimiters) {\n  var i,\n      startDelim,\n      endDelim,\n      token,\n      ch,\n      isStrong,\n      max = delimiters.length;\n\n  for (i = max - 1; i >= 0; i--) {\n    startDelim = delimiters[i];\n\n    if (startDelim.marker !== 0x5F/* _ */ && startDelim.marker !== 0x2A/* * */) {\n      continue;\n    }\n\n    // Process only opening markers\n    if (startDelim.end === -1) {\n      continue;\n    }\n\n    endDelim = delimiters[startDelim.end];\n\n    // If the previous delimiter has the same marker and is adjacent to this one,\n    // merge those into one strong delimiter.\n    //\n    // `<em><em>whatever</em></em>` -> `<strong>whatever</strong>`\n    //\n    isStrong = i > 0 &&\n               delimiters[i - 1].end === startDelim.end + 1 &&\n               delimiters[i - 1].token === startDelim.token - 1 &&\n               delimiters[startDelim.end + 1].token === endDelim.token + 1 &&\n               delimiters[i - 1].marker === startDelim.marker;\n\n    ch = String.fromCharCode(startDelim.marker);\n\n    token         = state.tokens[startDelim.token];\n    token.type    = isStrong ? 'strong_open' : 'em_open';\n    token.tag     = isStrong ? 'strong' : 'em';\n    token.nesting = 1;\n    token.markup  = isStrong ? ch + ch : ch;\n    token.content = '';\n\n    token         = state.tokens[endDelim.token];\n    token.type    = isStrong ? 'strong_close' : 'em_close';\n    token.tag     = isStrong ? 'strong' : 'em';\n    token.nesting = -1;\n    token.markup  = isStrong ? ch + ch : ch;\n    token.content = '';\n\n    if (isStrong) {\n      state.tokens[delimiters[i - 1].token].content = '';\n      state.tokens[delimiters[startDelim.end + 1].token].content = '';\n      i--;\n    }\n  }\n}\n\n\n// Walk through delimiter list and replace text tokens with tags\n//\nmodule.exports.postProcess = function emphasis(state) {\n  var curr,\n      tokens_meta = state.tokens_meta,\n      max = state.tokens_meta.length;\n\n  postProcess(state, state.delimiters);\n\n  for (curr = 0; curr < max; curr++) {\n    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\n      postProcess(state, tokens_meta[curr].delimiters);\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"script"}