{"ast":null,"code":"import _regeneratorRuntime from \"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { locToRange, offsetToPosition } from 'graphql-language-service-utils';\nexport var LANGUAGE = 'GraphQL';\n\nfunction assert(value, message) {\n  if (!value) {\n    throw new Error(message);\n  }\n}\n\nfunction getRange(text, node) {\n  var location = node.loc;\n  assert(location, 'Expected ASTNode to have a location.');\n  return locToRange(text, location);\n}\n\nfunction getPosition(text, node) {\n  var location = node.loc;\n  assert(location, 'Expected ASTNode to have a location.');\n  return offsetToPosition(text, location.start);\n}\n\nexport function getDefinitionQueryResultForNamedType(text, node, dependencies) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var name, defNodes, definitions;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            name = node.name.value;\n            defNodes = dependencies.filter(function (_ref) {\n              var definition = _ref.definition;\n              return definition.name && definition.name.value === name;\n            });\n\n            if (!(defNodes.length === 0)) {\n              _context.next = 4;\n              break;\n            }\n\n            throw Error(\"Definition not found for GraphQL type \".concat(name));\n\n          case 4:\n            definitions = defNodes.map(function (_ref2) {\n              var filePath = _ref2.filePath,\n                  content = _ref2.content,\n                  definition = _ref2.definition;\n              return getDefinitionForNodeDefinition(filePath || '', content, definition);\n            });\n            return _context.abrupt(\"return\", {\n              definitions: definitions,\n              queryRange: definitions.map(function (_) {\n                return getRange(text, node);\n              })\n            });\n\n          case 6:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n}\nexport function getDefinitionQueryResultForFragmentSpread(text, fragment, dependencies) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n    var name, defNodes, definitions;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            name = fragment.name.value;\n            defNodes = dependencies.filter(function (_ref3) {\n              var definition = _ref3.definition;\n              return definition.name.value === name;\n            });\n\n            if (!(defNodes.length === 0)) {\n              _context2.next = 4;\n              break;\n            }\n\n            throw Error(\"Definition not found for GraphQL fragment \".concat(name));\n\n          case 4:\n            definitions = defNodes.map(function (_ref4) {\n              var filePath = _ref4.filePath,\n                  content = _ref4.content,\n                  definition = _ref4.definition;\n              return getDefinitionForFragmentDefinition(filePath || '', content, definition);\n            });\n            return _context2.abrupt(\"return\", {\n              definitions: definitions,\n              queryRange: definitions.map(function (_) {\n                return getRange(text, fragment);\n              })\n            });\n\n          case 6:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n}\nexport function getDefinitionQueryResultForDefinitionNode(path, text, definition) {\n  return {\n    definitions: [getDefinitionForFragmentDefinition(path, text, definition)],\n    queryRange: definition.name ? [getRange(text, definition.name)] : []\n  };\n}\n\nfunction getDefinitionForFragmentDefinition(path, text, definition) {\n  var name = definition.name;\n\n  if (!name) {\n    throw Error('Expected ASTNode to have a Name.');\n  }\n\n  return {\n    path: path,\n    position: getPosition(text, definition),\n    range: getRange(text, definition),\n    name: name.value || '',\n    language: LANGUAGE,\n    projectRoot: path\n  };\n}\n\nfunction getDefinitionForNodeDefinition(path, text, definition) {\n  var name = definition.name;\n  assert(name, 'Expected ASTNode to have a Name.');\n  return {\n    path: path,\n    position: getPosition(text, definition),\n    range: getRange(text, definition),\n    name: name.value || '',\n    language: LANGUAGE,\n    projectRoot: path\n  };\n}","map":{"version":3,"sources":["../src/getDefinition.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { locToRange, offsetToPosition, } from 'graphql-language-service-utils';\nexport const LANGUAGE = 'GraphQL';\nfunction assert(value, message) {\n    if (!value) {\n        throw new Error(message);\n    }\n}\nfunction getRange(text, node) {\n    const location = node.loc;\n    assert(location, 'Expected ASTNode to have a location.');\n    return locToRange(text, location);\n}\nfunction getPosition(text, node) {\n    const location = node.loc;\n    assert(location, 'Expected ASTNode to have a location.');\n    return offsetToPosition(text, location.start);\n}\nexport function getDefinitionQueryResultForNamedType(text, node, dependencies) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const name = node.name.value;\n        const defNodes = dependencies.filter(({ definition }) => definition.name && definition.name.value === name);\n        if (defNodes.length === 0) {\n            throw Error(`Definition not found for GraphQL type ${name}`);\n        }\n        const definitions = defNodes.map(({ filePath, content, definition }) => getDefinitionForNodeDefinition(filePath || '', content, definition));\n        return {\n            definitions,\n            queryRange: definitions.map(_ => getRange(text, node)),\n        };\n    });\n}\nexport function getDefinitionQueryResultForFragmentSpread(text, fragment, dependencies) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const name = fragment.name.value;\n        const defNodes = dependencies.filter(({ definition }) => definition.name.value === name);\n        if (defNodes.length === 0) {\n            throw Error(`Definition not found for GraphQL fragment ${name}`);\n        }\n        const definitions = defNodes.map(({ filePath, content, definition }) => getDefinitionForFragmentDefinition(filePath || '', content, definition));\n        return {\n            definitions,\n            queryRange: definitions.map(_ => getRange(text, fragment)),\n        };\n    });\n}\nexport function getDefinitionQueryResultForDefinitionNode(path, text, definition) {\n    return {\n        definitions: [getDefinitionForFragmentDefinition(path, text, definition)],\n        queryRange: definition.name ? [getRange(text, definition.name)] : [],\n    };\n}\nfunction getDefinitionForFragmentDefinition(path, text, definition) {\n    const name = definition.name;\n    if (!name) {\n        throw Error('Expected ASTNode to have a Name.');\n    }\n    return {\n        path,\n        position: getPosition(text, definition),\n        range: getRange(text, definition),\n        name: name.value || '',\n        language: LANGUAGE,\n        projectRoot: path,\n    };\n}\nfunction getDefinitionForNodeDefinition(path, text, definition) {\n    const name = definition.name;\n    assert(name, 'Expected ASTNode to have a Name.');\n    return {\n        path,\n        position: getPosition(text, definition),\n        range: getRange(text, definition),\n        name: name.value || '',\n        language: LANGUAGE,\n        projectRoot: path,\n    };\n}\n//# sourceMappingURL=getDefinition.js.map"]},"metadata":{},"sourceType":"module"}