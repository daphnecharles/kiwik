{"ast":null,"code":"import _regeneratorRuntime from \"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _slicedToArray from \"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { ethers } from 'ethers';\nimport { useEffect, useMemo, useState } from 'react';\nimport { parseProviderOrSigner } from \"./functions/providerOrSigner\";\n/**\n * Loads your local contracts and gives options to read values from contracts\n  or write transactions into them\n\n   ~ Features ~\n  - localProvider enables reading values from contracts\n  - userProvider enables writing transactions into contracts\n  - Example of keeping track of \"purpose\" variable by loading contracts into readContracts\n    and using ContractReader.js hook:\n    const purpose = useContractReader(readContracts,\"YourContract\", \"purpose\")\n  - Example of using setPurpose function from our contract and writing transactions by Transactor.js helper:\n    tx( writeContracts.YourContract.setPurpose(newPurpose) )\n\n  config can include:\n  - chainId - to hardcode the chainId, irrespective of the providerOrSigner chainId\n  - hardhatNetworkName - to hardcode the hardhat network of interest\n  - customAddresses: { contractName: 0xCustomAddress } to hardcode the address for a given named contract\n  - hardhatContracts: object following the hardhat deploy export format (Json with chainIds as keys, which have hardhat network names as keys, which contain arrays of contracts for each)\n  - externalContracts: object with chainIds as keys, with an array of contracts for each\n * @param providerOrSigner (TEthersProviderOrSigner)\n * @param config (TContractConfig) :: configuration for loader\n * @returns (Record<string, Contract>) :: a record of contractName:contract\n */\n\nexport var useContractLoader = function useContractLoader(providerOrSigner) {\n  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var chainId = arguments.length > 2 ? arguments[2] : undefined;\n\n  var _useState = useState({}),\n      _useState2 = _slicedToArray(_useState, 2),\n      contracts = _useState2[0],\n      setContracts = _useState2[1];\n\n  var configDep = useMemo(function () {\n    return JSON.stringify(config !== null && config !== void 0 ? config : {});\n  }, [config]);\n  useEffect(function () {\n    var active = true;\n\n    var loadContracts = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _a, _b, _c, _d, _e, _yield$parseProviderO, providerNetwork, currentChainId, contractList, externalContractList, combinedContracts, hardhatNetwork, newContracts;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(providerOrSigner && typeof providerOrSigner !== 'undefined')) {\n                  _context.next = 22;\n                  break;\n                }\n\n                console.log(\"loading contracts\");\n                console.log(providerOrSigner, config);\n                _context.prev = 3;\n\n                if (!(typeof providerOrSigner !== 'undefined')) {\n                  _context.next = 17;\n                  break;\n                }\n\n                _context.next = 7;\n                return parseProviderOrSigner(providerOrSigner);\n\n              case 7:\n                _yield$parseProviderO = _context.sent;\n                providerNetwork = _yield$parseProviderO.providerNetwork;\n                // find the current chainId based on this order:\n                //  - chainId passed in or a fallback of provider chainId\n                currentChainId = (_a = chainId !== null && chainId !== void 0 ? chainId : providerNetwork === null || providerNetwork === void 0 ? void 0 : providerNetwork.chainId) !== null && _a !== void 0 ? _a : 0; // Type definition\n                //  Record<string, Record<string, Contract>>\n                //  { chainId: { contractName: Contract } }\n\n                contractList = Object.assign({}, (_b = config.deployedContracts) !== null && _b !== void 0 ? _b : {});\n                externalContractList = Object.assign({}, (_c = config.externalContracts) !== null && _c !== void 0 ? _c : {});\n                combinedContracts = {}; // combine partitioned contracts based on all the available and chain id.\n\n                if ((contractList === null || contractList === void 0 ? void 0 : contractList[currentChainId]) != null) {\n                  for (hardhatNetwork in contractList[currentChainId]) {\n                    if (Object.prototype.hasOwnProperty.call(contractList[currentChainId], hardhatNetwork)) {\n                      if (!config.hardhatNetworkName || hardhatNetwork === config.hardhatNetworkName) {\n                        combinedContracts = Object.assign(Object.assign({}, combinedContracts), (_e = (_d = contractList === null || contractList === void 0 ? void 0 : contractList[currentChainId]) === null || _d === void 0 ? void 0 : _d[hardhatNetwork]) === null || _e === void 0 ? void 0 : _e.contracts);\n                      }\n                    }\n                  }\n                }\n\n                if ((externalContractList === null || externalContractList === void 0 ? void 0 : externalContractList[currentChainId]) != null) {\n                  combinedContracts = Object.assign(Object.assign({}, combinedContracts), externalContractList[currentChainId].contracts);\n                }\n\n                newContracts = Object.keys(combinedContracts).reduce(function (accumulator, contractName) {\n                  var address = config.customAddresses && Object.keys(config.customAddresses).includes(contractName) ? config.customAddresses[contractName] : combinedContracts[contractName].address;\n                  accumulator[contractName] = new ethers.Contract(address, combinedContracts[contractName].abi, providerOrSigner);\n                  return accumulator;\n                }, {});\n                if (active) setContracts(newContracts);\n\n              case 17:\n                _context.next = 22;\n                break;\n\n              case 19:\n                _context.prev = 19;\n                _context.t0 = _context[\"catch\"](3);\n                console.log('ERROR LOADING CONTRACTS!!', _context.t0);\n\n              case 22:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[3, 19]]);\n      }));\n\n      return function loadContracts() {\n        return _ref.apply(this, arguments);\n      };\n    }();\n\n    void loadContracts();\n    return function () {\n      active = false;\n    }; // disable as configDep is used for dep instead of config\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [providerOrSigner, configDep]);\n  return contracts;\n};","map":{"version":3,"sources":["/Users/sam/Desktop/kiwik/node_modules/eth-hooks/useContractLoader.js"],"names":["ethers","useEffect","useMemo","useState","parseProviderOrSigner","useContractLoader","providerOrSigner","config","chainId","contracts","setContracts","configDep","JSON","stringify","active","loadContracts","console","log","providerNetwork","currentChainId","_a","contractList","Object","assign","_b","deployedContracts","externalContractList","_c","externalContracts","combinedContracts","hardhatNetwork","prototype","hasOwnProperty","call","hardhatNetworkName","_e","_d","newContracts","keys","reduce","accumulator","contractName","address","customAddresses","includes","Contract","abi"],"mappings":"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","sourcesContent":["import { ethers } from 'ethers';\nimport { useEffect, useMemo, useState } from 'react';\nimport { parseProviderOrSigner } from \"./functions/providerOrSigner\";\n/**\n * Loads your local contracts and gives options to read values from contracts\n  or write transactions into them\n\n   ~ Features ~\n  - localProvider enables reading values from contracts\n  - userProvider enables writing transactions into contracts\n  - Example of keeping track of \"purpose\" variable by loading contracts into readContracts\n    and using ContractReader.js hook:\n    const purpose = useContractReader(readContracts,\"YourContract\", \"purpose\")\n  - Example of using setPurpose function from our contract and writing transactions by Transactor.js helper:\n    tx( writeContracts.YourContract.setPurpose(newPurpose) )\n\n  config can include:\n  - chainId - to hardcode the chainId, irrespective of the providerOrSigner chainId\n  - hardhatNetworkName - to hardcode the hardhat network of interest\n  - customAddresses: { contractName: 0xCustomAddress } to hardcode the address for a given named contract\n  - hardhatContracts: object following the hardhat deploy export format (Json with chainIds as keys, which have hardhat network names as keys, which contain arrays of contracts for each)\n  - externalContracts: object with chainIds as keys, with an array of contracts for each\n * @param providerOrSigner (TEthersProviderOrSigner)\n * @param config (TContractConfig) :: configuration for loader\n * @returns (Record<string, Contract>) :: a record of contractName:contract\n */\nexport const useContractLoader = (providerOrSigner, config = {}, chainId) => {\n    const [contracts, setContracts] = useState({});\n    const configDep = useMemo(() => JSON.stringify(config !== null && config !== void 0 ? config : {}), [config]);\n    useEffect(() => {\n        let active = true;\n        const loadContracts = async () => {\n            var _a, _b, _c, _d, _e;\n            if (providerOrSigner && typeof providerOrSigner !== 'undefined') {\n                console.log(`loading contracts`);\n                console.log(providerOrSigner, config);\n                try {\n                    // we need to check to see if this providerOrSigner has a signer or not\n                    if (typeof providerOrSigner !== 'undefined') {\n                        // we need to check to see if this providerOrSigner has a signer or not\n                        const { providerNetwork } = await parseProviderOrSigner(providerOrSigner);\n                        // find the current chainId based on this order:\n                        //  - chainId passed in or a fallback of provider chainId\n                        const currentChainId = (_a = chainId !== null && chainId !== void 0 ? chainId : providerNetwork === null || providerNetwork === void 0 ? void 0 : providerNetwork.chainId) !== null && _a !== void 0 ? _a : 0;\n                        // Type definition\n                        //  Record<string, Record<string, Contract>>\n                        //  { chainId: { contractName: Contract } }\n                        const contractList = Object.assign({}, ((_b = config.deployedContracts) !== null && _b !== void 0 ? _b : {}));\n                        const externalContractList = Object.assign({}, ((_c = config.externalContracts) !== null && _c !== void 0 ? _c : {}));\n                        let combinedContracts = {};\n                        // combine partitioned contracts based on all the available and chain id.\n                        if ((contractList === null || contractList === void 0 ? void 0 : contractList[currentChainId]) != null) {\n                            for (const hardhatNetwork in contractList[currentChainId]) {\n                                if (Object.prototype.hasOwnProperty.call(contractList[currentChainId], hardhatNetwork)) {\n                                    if (!config.hardhatNetworkName || hardhatNetwork === config.hardhatNetworkName) {\n                                        combinedContracts = Object.assign(Object.assign({}, combinedContracts), (_e = (_d = contractList === null || contractList === void 0 ? void 0 : contractList[currentChainId]) === null || _d === void 0 ? void 0 : _d[hardhatNetwork]) === null || _e === void 0 ? void 0 : _e.contracts);\n                                    }\n                                }\n                            }\n                        }\n                        if ((externalContractList === null || externalContractList === void 0 ? void 0 : externalContractList[currentChainId]) != null) {\n                            combinedContracts = Object.assign(Object.assign({}, combinedContracts), externalContractList[currentChainId].contracts);\n                        }\n                        const newContracts = Object.keys(combinedContracts).reduce((accumulator, contractName) => {\n                            const address = config.customAddresses && Object.keys(config.customAddresses).includes(contractName)\n                                ? config.customAddresses[contractName]\n                                : combinedContracts[contractName].address;\n                            accumulator[contractName] = new ethers.Contract(address, combinedContracts[contractName].abi, providerOrSigner);\n                            return accumulator;\n                        }, {});\n                        if (active)\n                            setContracts(newContracts);\n                    }\n                }\n                catch (e) {\n                    console.log('ERROR LOADING CONTRACTS!!', e);\n                }\n            }\n        };\n        void loadContracts();\n        return () => {\n            active = false;\n        };\n        // disable as configDep is used for dep instead of config\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [providerOrSigner, configDep]);\n    return contracts;\n};\n"]},"metadata":{},"sourceType":"module"}