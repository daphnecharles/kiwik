{"ast":null,"code":"import _classCallCheck from \"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nvar CharacterStream = /*#__PURE__*/function () {\n  function CharacterStream(sourceText) {\n    var _this = this;\n\n    _classCallCheck(this, CharacterStream);\n\n    this.getStartOfToken = function () {\n      return _this._start;\n    };\n\n    this.getCurrentPosition = function () {\n      return _this._pos;\n    };\n\n    this.eol = function () {\n      return _this._sourceText.length === _this._pos;\n    };\n\n    this.sol = function () {\n      return _this._pos === 0;\n    };\n\n    this.peek = function () {\n      return _this._sourceText.charAt(_this._pos) ? _this._sourceText.charAt(_this._pos) : null;\n    };\n\n    this.next = function () {\n      var char = _this._sourceText.charAt(_this._pos);\n\n      _this._pos++;\n      return char;\n    };\n\n    this.eat = function (pattern) {\n      var isMatched = _this._testNextCharacter(pattern);\n\n      if (isMatched) {\n        _this._start = _this._pos;\n        _this._pos++;\n        return _this._sourceText.charAt(_this._pos - 1);\n      }\n\n      return undefined;\n    };\n\n    this.eatWhile = function (match) {\n      var isMatched = _this._testNextCharacter(match);\n\n      var didEat = false;\n\n      if (isMatched) {\n        didEat = isMatched;\n        _this._start = _this._pos;\n      }\n\n      while (isMatched) {\n        _this._pos++;\n        isMatched = _this._testNextCharacter(match);\n        didEat = true;\n      }\n\n      return didEat;\n    };\n\n    this.eatSpace = function () {\n      return _this.eatWhile(/[\\s\\u00a0]/);\n    };\n\n    this.skipToEnd = function () {\n      _this._pos = _this._sourceText.length;\n    };\n\n    this.skipTo = function (position) {\n      _this._pos = position;\n    };\n\n    this.match = function (pattern) {\n      var consume = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var caseFold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var token = null;\n      var match = null;\n\n      if (typeof pattern === 'string') {\n        var regex = new RegExp(pattern, caseFold ? 'i' : 'g');\n        match = regex.test(_this._sourceText.substr(_this._pos, pattern.length));\n        token = pattern;\n      } else if (pattern instanceof RegExp) {\n        match = _this._sourceText.slice(_this._pos).match(pattern);\n        token = match && match[0];\n      }\n\n      if (match != null) {\n        if (typeof pattern === 'string' || match instanceof Array && _this._sourceText.startsWith(match[0], _this._pos)) {\n          if (consume) {\n            _this._start = _this._pos;\n\n            if (token && token.length) {\n              _this._pos += token.length;\n            }\n          }\n\n          return match;\n        }\n      }\n\n      return false;\n    };\n\n    this.backUp = function (num) {\n      _this._pos -= num;\n    };\n\n    this.column = function () {\n      return _this._pos;\n    };\n\n    this.indentation = function () {\n      var match = _this._sourceText.match(/\\s*/);\n\n      var indent = 0;\n\n      if (match && match.length !== 0) {\n        var whitespaces = match[0];\n        var pos = 0;\n\n        while (whitespaces.length > pos) {\n          if (whitespaces.charCodeAt(pos) === 9) {\n            indent += 2;\n          } else {\n            indent++;\n          }\n\n          pos++;\n        }\n      }\n\n      return indent;\n    };\n\n    this.current = function () {\n      return _this._sourceText.slice(_this._start, _this._pos);\n    };\n\n    this._start = 0;\n    this._pos = 0;\n    this._sourceText = sourceText;\n  }\n\n  _createClass(CharacterStream, [{\n    key: \"_testNextCharacter\",\n    value: function _testNextCharacter(pattern) {\n      var character = this._sourceText.charAt(this._pos);\n\n      var isMatched = false;\n\n      if (typeof pattern === 'string') {\n        isMatched = character === pattern;\n      } else {\n        isMatched = pattern instanceof RegExp ? pattern.test(character) : pattern(character);\n      }\n\n      return isMatched;\n    }\n  }]);\n\n  return CharacterStream;\n}();\n\nexport { CharacterStream as default };","map":{"version":3,"sources":["../src/CharacterStream.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["export default class CharacterStream {\n    constructor(sourceText) {\n        this.getStartOfToken = () => this._start;\n        this.getCurrentPosition = () => this._pos;\n        this.eol = () => this._sourceText.length === this._pos;\n        this.sol = () => this._pos === 0;\n        this.peek = () => {\n            return this._sourceText.charAt(this._pos)\n                ? this._sourceText.charAt(this._pos)\n                : null;\n        };\n        this.next = () => {\n            const char = this._sourceText.charAt(this._pos);\n            this._pos++;\n            return char;\n        };\n        this.eat = (pattern) => {\n            const isMatched = this._testNextCharacter(pattern);\n            if (isMatched) {\n                this._start = this._pos;\n                this._pos++;\n                return this._sourceText.charAt(this._pos - 1);\n            }\n            return undefined;\n        };\n        this.eatWhile = (match) => {\n            let isMatched = this._testNextCharacter(match);\n            let didEat = false;\n            if (isMatched) {\n                didEat = isMatched;\n                this._start = this._pos;\n            }\n            while (isMatched) {\n                this._pos++;\n                isMatched = this._testNextCharacter(match);\n                didEat = true;\n            }\n            return didEat;\n        };\n        this.eatSpace = () => this.eatWhile(/[\\s\\u00a0]/);\n        this.skipToEnd = () => {\n            this._pos = this._sourceText.length;\n        };\n        this.skipTo = (position) => {\n            this._pos = position;\n        };\n        this.match = (pattern, consume = true, caseFold = false) => {\n            let token = null;\n            let match = null;\n            if (typeof pattern === 'string') {\n                const regex = new RegExp(pattern, caseFold ? 'i' : 'g');\n                match = regex.test(this._sourceText.substr(this._pos, pattern.length));\n                token = pattern;\n            }\n            else if (pattern instanceof RegExp) {\n                match = this._sourceText.slice(this._pos).match(pattern);\n                token = match && match[0];\n            }\n            if (match != null) {\n                if (typeof pattern === 'string' ||\n                    (match instanceof Array &&\n                        this._sourceText.startsWith(match[0], this._pos))) {\n                    if (consume) {\n                        this._start = this._pos;\n                        if (token && token.length) {\n                            this._pos += token.length;\n                        }\n                    }\n                    return match;\n                }\n            }\n            return false;\n        };\n        this.backUp = (num) => {\n            this._pos -= num;\n        };\n        this.column = () => this._pos;\n        this.indentation = () => {\n            const match = this._sourceText.match(/\\s*/);\n            let indent = 0;\n            if (match && match.length !== 0) {\n                const whitespaces = match[0];\n                let pos = 0;\n                while (whitespaces.length > pos) {\n                    if (whitespaces.charCodeAt(pos) === 9) {\n                        indent += 2;\n                    }\n                    else {\n                        indent++;\n                    }\n                    pos++;\n                }\n            }\n            return indent;\n        };\n        this.current = () => this._sourceText.slice(this._start, this._pos);\n        this._start = 0;\n        this._pos = 0;\n        this._sourceText = sourceText;\n    }\n    _testNextCharacter(pattern) {\n        const character = this._sourceText.charAt(this._pos);\n        let isMatched = false;\n        if (typeof pattern === 'string') {\n            isMatched = character === pattern;\n        }\n        else {\n            isMatched =\n                pattern instanceof RegExp\n                    ? pattern.test(character)\n                    : pattern(character);\n        }\n        return isMatched;\n    }\n}\n//# sourceMappingURL=CharacterStream.js.map"]},"metadata":{},"sourceType":"module"}