{"ast":null,"code":"import _classCallCheck from \"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { BlockCipher } from './cipher-core.js'; // Lookup tables\n\nvar _SBOX = [];\nvar INV_SBOX = [];\nvar _SUB_MIX_0 = [];\nvar _SUB_MIX_1 = [];\nvar _SUB_MIX_2 = [];\nvar _SUB_MIX_3 = [];\nvar INV_SUB_MIX_0 = [];\nvar INV_SUB_MIX_1 = [];\nvar INV_SUB_MIX_2 = [];\nvar INV_SUB_MIX_3 = []; // Compute lookup tables\n// Compute double table\n\nvar d = [];\n\nfor (var i = 0; i < 256; i += 1) {\n  if (i < 128) {\n    d[i] = i << 1;\n  } else {\n    d[i] = i << 1 ^ 0x11b;\n  }\n} // Walk GF(2^8)\n\n\nvar x = 0;\nvar xi = 0;\n\nfor (var _i = 0; _i < 256; _i += 1) {\n  // Compute sbox\n  var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;\n  sx = sx >>> 8 ^ sx & 0xff ^ 0x63;\n  _SBOX[x] = sx;\n  INV_SBOX[sx] = x; // Compute multiplication\n\n  var x2 = d[x];\n  var x4 = d[x2];\n  var x8 = d[x4]; // Compute sub bytes, mix columns tables\n\n  var t = d[sx] * 0x101 ^ sx * 0x1010100;\n  _SUB_MIX_0[x] = t << 24 | t >>> 8;\n  _SUB_MIX_1[x] = t << 16 | t >>> 16;\n  _SUB_MIX_2[x] = t << 8 | t >>> 24;\n  _SUB_MIX_3[x] = t; // Compute inv sub bytes, inv mix columns tables\n\n  t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;\n  INV_SUB_MIX_0[sx] = t << 24 | t >>> 8;\n  INV_SUB_MIX_1[sx] = t << 16 | t >>> 16;\n  INV_SUB_MIX_2[sx] = t << 8 | t >>> 24;\n  INV_SUB_MIX_3[sx] = t; // Compute next counter\n\n  if (!x) {\n    xi = 1;\n    x = xi;\n  } else {\n    x = x2 ^ d[d[d[x8 ^ x2]]];\n    xi ^= d[d[xi]];\n  }\n} // Precomputed Rcon lookup\n\n\nvar RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];\n/**\n * AES block cipher algorithm.\n */\n\nexport var AESAlgo = /*#__PURE__*/function (_BlockCipher) {\n  _inherits(AESAlgo, _BlockCipher);\n\n  var _super = _createSuper(AESAlgo);\n\n  function AESAlgo() {\n    _classCallCheck(this, AESAlgo);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(AESAlgo, [{\n    key: \"_doReset\",\n    value: function _doReset() {\n      var t; // Skip reset of nRounds has been set before and key did not change\n\n      if (this._nRounds && this._keyPriorReset === this._key) {\n        return;\n      } // Shortcuts\n\n\n      this._keyPriorReset = this._key;\n      var key = this._keyPriorReset;\n      var keyWords = key.words;\n      var keySize = key.sigBytes / 4; // Compute number of rounds\n\n      this._nRounds = keySize + 6;\n      var nRounds = this._nRounds; // Compute number of key schedule rows\n\n      var ksRows = (nRounds + 1) * 4; // Compute key schedule\n\n      this._keySchedule = [];\n      var keySchedule = this._keySchedule;\n\n      for (var ksRow = 0; ksRow < ksRows; ksRow += 1) {\n        if (ksRow < keySize) {\n          keySchedule[ksRow] = keyWords[ksRow];\n        } else {\n          t = keySchedule[ksRow - 1];\n\n          if (!(ksRow % keySize)) {\n            // Rot word\n            t = t << 8 | t >>> 24; // Sub word\n\n            t = _SBOX[t >>> 24] << 24 | _SBOX[t >>> 16 & 0xff] << 16 | _SBOX[t >>> 8 & 0xff] << 8 | _SBOX[t & 0xff]; // Mix Rcon\n\n            t ^= RCON[ksRow / keySize | 0] << 24;\n          } else if (keySize > 6 && ksRow % keySize === 4) {\n            // Sub word\n            t = _SBOX[t >>> 24] << 24 | _SBOX[t >>> 16 & 0xff] << 16 | _SBOX[t >>> 8 & 0xff] << 8 | _SBOX[t & 0xff];\n          }\n\n          keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;\n        }\n      } // Compute inv key schedule\n\n\n      this._invKeySchedule = [];\n      var invKeySchedule = this._invKeySchedule;\n\n      for (var invKsRow = 0; invKsRow < ksRows; invKsRow += 1) {\n        var _ksRow = ksRows - invKsRow;\n\n        if (invKsRow % 4) {\n          t = keySchedule[_ksRow];\n        } else {\n          t = keySchedule[_ksRow - 4];\n        }\n\n        if (invKsRow < 4 || _ksRow <= 4) {\n          invKeySchedule[invKsRow] = t;\n        } else {\n          invKeySchedule[invKsRow] = INV_SUB_MIX_0[_SBOX[t >>> 24]] ^ INV_SUB_MIX_1[_SBOX[t >>> 16 & 0xff]] ^ INV_SUB_MIX_2[_SBOX[t >>> 8 & 0xff]] ^ INV_SUB_MIX_3[_SBOX[t & 0xff]];\n        }\n      }\n    }\n  }, {\n    key: \"encryptBlock\",\n    value: function encryptBlock(M, offset) {\n      this._doCryptBlock(M, offset, this._keySchedule, _SUB_MIX_0, _SUB_MIX_1, _SUB_MIX_2, _SUB_MIX_3, _SBOX);\n    }\n  }, {\n    key: \"decryptBlock\",\n    value: function decryptBlock(M, offset) {\n      var _M = M; // Swap 2nd and 4th rows\n\n      var t = _M[offset + 1];\n      _M[offset + 1] = _M[offset + 3];\n      _M[offset + 3] = t;\n\n      this._doCryptBlock(_M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX); // Inv swap 2nd and 4th rows\n\n\n      t = _M[offset + 1];\n      _M[offset + 1] = _M[offset + 3];\n      _M[offset + 3] = t;\n    }\n  }, {\n    key: \"_doCryptBlock\",\n    value: function _doCryptBlock(M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {\n      var _M = M; // Shortcut\n\n      var nRounds = this._nRounds; // Get input, add round key\n\n      var s0 = _M[offset] ^ keySchedule[0];\n      var s1 = _M[offset + 1] ^ keySchedule[1];\n      var s2 = _M[offset + 2] ^ keySchedule[2];\n      var s3 = _M[offset + 3] ^ keySchedule[3]; // Key schedule row counter\n\n      var ksRow = 4; // Rounds\n\n      for (var round = 1; round < nRounds; round += 1) {\n        // Shift rows, sub bytes, mix columns, add round key\n        var _t = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[s1 >>> 16 & 0xff] ^ SUB_MIX_2[s2 >>> 8 & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow];\n\n        ksRow += 1;\n\n        var _t2 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[s2 >>> 16 & 0xff] ^ SUB_MIX_2[s3 >>> 8 & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow];\n\n        ksRow += 1;\n\n        var _t3 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[s3 >>> 16 & 0xff] ^ SUB_MIX_2[s0 >>> 8 & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow];\n\n        ksRow += 1;\n\n        var _t4 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[s0 >>> 16 & 0xff] ^ SUB_MIX_2[s1 >>> 8 & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow];\n\n        ksRow += 1; // Update state\n\n        s0 = _t;\n        s1 = _t2;\n        s2 = _t3;\n        s3 = _t4;\n      } // Shift rows, sub bytes, add round key\n\n\n      var t0 = (SBOX[s0 >>> 24] << 24 | SBOX[s1 >>> 16 & 0xff] << 16 | SBOX[s2 >>> 8 & 0xff] << 8 | SBOX[s3 & 0xff]) ^ keySchedule[ksRow];\n      ksRow += 1;\n      var t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 0xff] << 16 | SBOX[s3 >>> 8 & 0xff] << 8 | SBOX[s0 & 0xff]) ^ keySchedule[ksRow];\n      ksRow += 1;\n      var t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 0xff] << 16 | SBOX[s0 >>> 8 & 0xff] << 8 | SBOX[s1 & 0xff]) ^ keySchedule[ksRow];\n      ksRow += 1;\n      var t3 = (SBOX[s3 >>> 24] << 24 | SBOX[s0 >>> 16 & 0xff] << 16 | SBOX[s1 >>> 8 & 0xff] << 8 | SBOX[s2 & 0xff]) ^ keySchedule[ksRow];\n      ksRow += 1; // Set output\n\n      _M[offset] = t0;\n      _M[offset + 1] = t1;\n      _M[offset + 2] = t2;\n      _M[offset + 3] = t3;\n    }\n  }]);\n\n  return AESAlgo;\n}(BlockCipher);\nAESAlgo.keySize = 256 / 32;\n/**\n * Shortcut functions to the cipher's object interface.\n *\n * @example\n *\n *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);\n *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);\n */\n\nexport var AES = BlockCipher._createHelper(AESAlgo);","map":{"version":3,"sources":["/Users/sam/Desktop/kiwik/node_modules/crypto-es/lib/aes.js"],"names":["BlockCipher","_SBOX","INV_SBOX","_SUB_MIX_0","_SUB_MIX_1","_SUB_MIX_2","_SUB_MIX_3","INV_SUB_MIX_0","INV_SUB_MIX_1","INV_SUB_MIX_2","INV_SUB_MIX_3","d","i","x","xi","sx","x2","x4","x8","t","RCON","AESAlgo","_nRounds","_keyPriorReset","_key","key","keyWords","words","keySize","sigBytes","nRounds","ksRows","_keySchedule","keySchedule","ksRow","_invKeySchedule","invKeySchedule","invKsRow","M","offset","_doCryptBlock","_M","SUB_MIX_0","SUB_MIX_1","SUB_MIX_2","SUB_MIX_3","SBOX","s0","s1","s2","s3","round","t0","t1","t2","t3","AES","_createHelper"],"mappings":"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","sourcesContent":["import {\n  BlockCipher,\n} from './cipher-core.js';\n\n// Lookup tables\nconst _SBOX = [];\nconst INV_SBOX = [];\nconst _SUB_MIX_0 = [];\nconst _SUB_MIX_1 = [];\nconst _SUB_MIX_2 = [];\nconst _SUB_MIX_3 = [];\nconst INV_SUB_MIX_0 = [];\nconst INV_SUB_MIX_1 = [];\nconst INV_SUB_MIX_2 = [];\nconst INV_SUB_MIX_3 = [];\n\n// Compute lookup tables\n\n// Compute double table\nconst d = [];\nfor (let i = 0; i < 256; i += 1) {\n  if (i < 128) {\n    d[i] = i << 1;\n  } else {\n    d[i] = (i << 1) ^ 0x11b;\n  }\n}\n\n// Walk GF(2^8)\nlet x = 0;\nlet xi = 0;\nfor (let i = 0; i < 256; i += 1) {\n  // Compute sbox\n  let sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);\n  sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;\n  _SBOX[x] = sx;\n  INV_SBOX[sx] = x;\n\n  // Compute multiplication\n  const x2 = d[x];\n  const x4 = d[x2];\n  const x8 = d[x4];\n\n  // Compute sub bytes, mix columns tables\n  let t = (d[sx] * 0x101) ^ (sx * 0x1010100);\n  _SUB_MIX_0[x] = (t << 24) | (t >>> 8);\n  _SUB_MIX_1[x] = (t << 16) | (t >>> 16);\n  _SUB_MIX_2[x] = (t << 8) | (t >>> 24);\n  _SUB_MIX_3[x] = t;\n\n  // Compute inv sub bytes, inv mix columns tables\n  t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);\n  INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);\n  INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);\n  INV_SUB_MIX_2[sx] = (t << 8) | (t >>> 24);\n  INV_SUB_MIX_3[sx] = t;\n\n  // Compute next counter\n  if (!x) {\n    xi = 1;\n    x = xi;\n  } else {\n    x = x2 ^ d[d[d[x8 ^ x2]]];\n    xi ^= d[d[xi]];\n  }\n}\n\n// Precomputed Rcon lookup\nconst RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];\n\n/**\n * AES block cipher algorithm.\n */\nexport class AESAlgo extends BlockCipher {\n  _doReset() {\n    let t;\n\n    // Skip reset of nRounds has been set before and key did not change\n    if (this._nRounds && this._keyPriorReset === this._key) {\n      return;\n    }\n\n    // Shortcuts\n    this._keyPriorReset = this._key;\n    const key = this._keyPriorReset;\n    const keyWords = key.words;\n    const keySize = key.sigBytes / 4;\n\n    // Compute number of rounds\n    this._nRounds = keySize + 6;\n    const nRounds = this._nRounds;\n\n    // Compute number of key schedule rows\n    const ksRows = (nRounds + 1) * 4;\n\n    // Compute key schedule\n    this._keySchedule = [];\n    const keySchedule = this._keySchedule;\n    for (let ksRow = 0; ksRow < ksRows; ksRow += 1) {\n      if (ksRow < keySize) {\n        keySchedule[ksRow] = keyWords[ksRow];\n      } else {\n        t = keySchedule[ksRow - 1];\n\n        if (!(ksRow % keySize)) {\n          // Rot word\n          t = (t << 8) | (t >>> 24);\n\n          // Sub word\n          t = (_SBOX[t >>> 24] << 24)\n            | (_SBOX[(t >>> 16) & 0xff] << 16)\n            | (_SBOX[(t >>> 8) & 0xff] << 8)\n            | _SBOX[t & 0xff];\n\n          // Mix Rcon\n          t ^= RCON[(ksRow / keySize) | 0] << 24;\n        } else if (keySize > 6 && ksRow % keySize === 4) {\n          // Sub word\n          t = (_SBOX[t >>> 24] << 24)\n            | (_SBOX[(t >>> 16) & 0xff] << 16)\n            | (_SBOX[(t >>> 8) & 0xff] << 8)\n            | _SBOX[t & 0xff];\n        }\n\n        keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;\n      }\n    }\n\n    // Compute inv key schedule\n    this._invKeySchedule = [];\n    const invKeySchedule = this._invKeySchedule;\n    for (let invKsRow = 0; invKsRow < ksRows; invKsRow += 1) {\n      const ksRow = ksRows - invKsRow;\n\n      if (invKsRow % 4) {\n        t = keySchedule[ksRow];\n      } else {\n        t = keySchedule[ksRow - 4];\n      }\n\n      if (invKsRow < 4 || ksRow <= 4) {\n        invKeySchedule[invKsRow] = t;\n      } else {\n        invKeySchedule[invKsRow] = INV_SUB_MIX_0[_SBOX[t >>> 24]]\n          ^ INV_SUB_MIX_1[_SBOX[(t >>> 16) & 0xff]]\n          ^ INV_SUB_MIX_2[_SBOX[(t >>> 8) & 0xff]]\n          ^ INV_SUB_MIX_3[_SBOX[t & 0xff]];\n      }\n    }\n  }\n\n  encryptBlock(M, offset) {\n    this._doCryptBlock(\n      M, offset, this._keySchedule, _SUB_MIX_0, _SUB_MIX_1, _SUB_MIX_2, _SUB_MIX_3, _SBOX,\n    );\n  }\n\n  decryptBlock(M, offset) {\n    const _M = M;\n\n    // Swap 2nd and 4th rows\n    let t = _M[offset + 1];\n    _M[offset + 1] = _M[offset + 3];\n    _M[offset + 3] = t;\n\n    this._doCryptBlock(\n      _M,\n      offset,\n      this._invKeySchedule,\n      INV_SUB_MIX_0,\n      INV_SUB_MIX_1,\n      INV_SUB_MIX_2,\n      INV_SUB_MIX_3,\n      INV_SBOX,\n    );\n\n    // Inv swap 2nd and 4th rows\n    t = _M[offset + 1];\n    _M[offset + 1] = _M[offset + 3];\n    _M[offset + 3] = t;\n  }\n\n  _doCryptBlock(M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {\n    const _M = M;\n\n    // Shortcut\n    const nRounds = this._nRounds;\n\n    // Get input, add round key\n    let s0 = _M[offset] ^ keySchedule[0];\n    let s1 = _M[offset + 1] ^ keySchedule[1];\n    let s2 = _M[offset + 2] ^ keySchedule[2];\n    let s3 = _M[offset + 3] ^ keySchedule[3];\n\n    // Key schedule row counter\n    let ksRow = 4;\n\n    // Rounds\n    for (let round = 1; round < nRounds; round += 1) {\n      // Shift rows, sub bytes, mix columns, add round key\n      const t0 = SUB_MIX_0[s0 >>> 24]\n        ^ SUB_MIX_1[(s1 >>> 16) & 0xff]\n        ^ SUB_MIX_2[(s2 >>> 8) & 0xff]\n        ^ SUB_MIX_3[s3 & 0xff]\n        ^ keySchedule[ksRow];\n      ksRow += 1;\n      const t1 = SUB_MIX_0[s1 >>> 24]\n        ^ SUB_MIX_1[(s2 >>> 16) & 0xff]\n        ^ SUB_MIX_2[(s3 >>> 8) & 0xff]\n        ^ SUB_MIX_3[s0 & 0xff]\n        ^ keySchedule[ksRow];\n      ksRow += 1;\n      const t2 = SUB_MIX_0[s2 >>> 24]\n        ^ SUB_MIX_1[(s3 >>> 16) & 0xff]\n        ^ SUB_MIX_2[(s0 >>> 8) & 0xff]\n        ^ SUB_MIX_3[s1 & 0xff]\n        ^ keySchedule[ksRow];\n      ksRow += 1;\n      const t3 = SUB_MIX_0[s3 >>> 24]\n        ^ SUB_MIX_1[(s0 >>> 16) & 0xff]\n        ^ SUB_MIX_2[(s1 >>> 8) & 0xff]\n        ^ SUB_MIX_3[s2 & 0xff]\n        ^ keySchedule[ksRow];\n      ksRow += 1;\n\n      // Update state\n      s0 = t0;\n      s1 = t1;\n      s2 = t2;\n      s3 = t3;\n    }\n\n    // Shift rows, sub bytes, add round key\n    const t0 = (\n      (SBOX[s0 >>> 24] << 24)\n        | (SBOX[(s1 >>> 16) & 0xff] << 16)\n        | (SBOX[(s2 >>> 8) & 0xff] << 8)\n        | SBOX[s3 & 0xff]\n    ) ^ keySchedule[ksRow];\n    ksRow += 1;\n    const t1 = (\n      (SBOX[s1 >>> 24] << 24)\n        | (SBOX[(s2 >>> 16) & 0xff] << 16)\n        | (SBOX[(s3 >>> 8) & 0xff] << 8)\n        | SBOX[s0 & 0xff]\n    ) ^ keySchedule[ksRow];\n    ksRow += 1;\n    const t2 = (\n      (SBOX[s2 >>> 24] << 24)\n        | (SBOX[(s3 >>> 16) & 0xff] << 16)\n        | (SBOX[(s0 >>> 8) & 0xff] << 8)\n        | SBOX[s1 & 0xff]\n    ) ^ keySchedule[ksRow];\n    ksRow += 1;\n    const t3 = (\n      (SBOX[s3 >>> 24] << 24)\n        | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]\n    ) ^ keySchedule[ksRow];\n    ksRow += 1;\n\n    // Set output\n    _M[offset] = t0;\n    _M[offset + 1] = t1;\n    _M[offset + 2] = t2;\n    _M[offset + 3] = t3;\n  }\n}\nAESAlgo.keySize = 256 / 32;\n\n/**\n * Shortcut functions to the cipher's object interface.\n *\n * @example\n *\n *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);\n *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);\n */\nexport const AES = BlockCipher._createHelper(AESAlgo);\n"]},"metadata":{},"sourceType":"module"}