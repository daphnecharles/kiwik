{"ast":null,"code":"import { LexRules, ParseRules, isIgnored } from './Rules';\nimport { Kind } from 'graphql';\nexport default function onlineParser() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n    eatWhitespace: function eatWhitespace(stream) {\n      return stream.eatWhile(isIgnored);\n    },\n    lexRules: LexRules,\n    parseRules: ParseRules,\n    editorConfig: {}\n  };\n  return {\n    startState: function startState() {\n      var initialState = {\n        level: 0,\n        step: 0,\n        name: null,\n        kind: null,\n        type: null,\n        rule: null,\n        needsSeperator: false,\n        prevState: null\n      };\n      pushRule(options.parseRules, initialState, Kind.DOCUMENT);\n      return initialState;\n    },\n    token: function token(stream, state) {\n      return getToken(stream, state, options);\n    }\n  };\n}\n\nfunction getToken(stream, state, options) {\n  if (state.inBlockstring) {\n    if (stream.match(/.*\"\"\"/)) {\n      state.inBlockstring = false;\n      return 'string';\n    } else {\n      stream.skipToEnd();\n      return 'string';\n    }\n  }\n\n  var lexRules = options.lexRules,\n      parseRules = options.parseRules,\n      eatWhitespace = options.eatWhitespace,\n      editorConfig = options.editorConfig;\n\n  if (state.rule && state.rule.length === 0) {\n    popRule(state);\n  } else if (state.needsAdvance) {\n    state.needsAdvance = false;\n    advanceRule(state, true);\n  }\n\n  if (stream.sol()) {\n    var tabSize = editorConfig && editorConfig.tabSize || 2;\n    state.indentLevel = Math.floor(stream.indentation() / tabSize);\n  }\n\n  if (eatWhitespace(stream)) {\n    return 'ws';\n  }\n\n  var token = lex(lexRules, stream);\n\n  if (!token) {\n    var matchedSomething = stream.match(/\\S+/);\n\n    if (!matchedSomething) {\n      stream.match(/\\s/);\n    }\n\n    pushRule(SpecialParseRules, state, 'Invalid');\n    return 'invalidchar';\n  }\n\n  if (token.kind === 'Comment') {\n    pushRule(SpecialParseRules, state, 'Comment');\n    return 'comment';\n  }\n\n  var backupState = assign({}, state);\n\n  if (token.kind === 'Punctuation') {\n    if (/^[{([]/.test(token.value)) {\n      if (state.indentLevel !== undefined) {\n        state.levels = (state.levels || []).concat(state.indentLevel + 1);\n      }\n    } else if (/^[})\\]]/.test(token.value)) {\n      var levels = state.levels = (state.levels || []).slice(0, -1);\n\n      if (state.indentLevel) {\n        if (levels.length > 0 && levels[levels.length - 1] < state.indentLevel) {\n          state.indentLevel = levels[levels.length - 1];\n        }\n      }\n    }\n  }\n\n  while (state.rule) {\n    var expected = typeof state.rule === 'function' ? state.step === 0 ? state.rule(token, stream) : null : state.rule[state.step];\n\n    if (state.needsSeperator) {\n      expected = expected && (expected === null || expected === void 0 ? void 0 : expected.separator);\n    }\n\n    if (expected) {\n      if (expected.ofRule) {\n        expected = expected.ofRule;\n      }\n\n      if (typeof expected === 'string') {\n        pushRule(parseRules, state, expected);\n        continue;\n      }\n\n      if (expected.match && expected.match(token)) {\n        if (expected.update) {\n          expected.update(state, token);\n        }\n\n        if (token.kind === 'Punctuation') {\n          advanceRule(state, true);\n        } else {\n          state.needsAdvance = true;\n        }\n\n        return expected.style;\n      }\n    }\n\n    unsuccessful(state);\n  }\n\n  assign(state, backupState);\n  pushRule(SpecialParseRules, state, 'Invalid');\n  return 'invalidchar';\n}\n\nfunction assign(to, from) {\n  var keys = Object.keys(from);\n\n  for (var i = 0; i < keys.length; i++) {\n    to[keys[i]] = from[keys[i]];\n  }\n\n  return to;\n}\n\nvar SpecialParseRules = {\n  Invalid: [],\n  Comment: []\n};\n\nfunction pushRule(rules, state, ruleKind) {\n  if (!rules[ruleKind]) {\n    throw new TypeError('Unknown rule: ' + ruleKind);\n  }\n\n  state.prevState = Object.assign({}, state);\n  state.kind = ruleKind;\n  state.name = null;\n  state.type = null;\n  state.rule = rules[ruleKind];\n  state.step = 0;\n  state.needsSeperator = false;\n}\n\nfunction popRule(state) {\n  if (!state.prevState) {\n    return;\n  }\n\n  state.kind = state.prevState.kind;\n  state.name = state.prevState.name;\n  state.type = state.prevState.type;\n  state.rule = state.prevState.rule;\n  state.step = state.prevState.step;\n  state.needsSeperator = state.prevState.needsSeperator;\n  state.prevState = state.prevState.prevState;\n}\n\nfunction advanceRule(state, successful) {\n  if (isList(state) && state.rule) {\n    var step = state.rule[state.step];\n\n    if (step.separator) {\n      var separator = step.separator;\n      state.needsSeperator = !state.needsSeperator;\n\n      if (!state.needsSeperator && separator.ofRule) {\n        return;\n      }\n    }\n\n    if (successful) {\n      return;\n    }\n  }\n\n  state.needsSeperator = false;\n  state.step++;\n\n  while (state.rule && !(Array.isArray(state.rule) && state.step < state.rule.length)) {\n    popRule(state);\n\n    if (state.rule) {\n      if (isList(state)) {\n        if (state.rule && state.rule[state.step].separator) {\n          state.needsSeperator = !state.needsSeperator;\n        }\n      } else {\n        state.needsSeperator = false;\n        state.step++;\n      }\n    }\n  }\n}\n\nfunction isList(state) {\n  var step = Array.isArray(state.rule) && typeof state.rule[state.step] !== 'string' && state.rule[state.step];\n  return step && step.isList;\n}\n\nfunction unsuccessful(state) {\n  while (state.rule && !(Array.isArray(state.rule) && state.rule[state.step].ofRule)) {\n    popRule(state);\n  }\n\n  if (state.rule) {\n    advanceRule(state, false);\n  }\n}\n\nfunction lex(lexRules, stream) {\n  var kinds = Object.keys(lexRules);\n\n  for (var i = 0; i < kinds.length; i++) {\n    var match = stream.match(lexRules[kinds[i]]);\n\n    if (match && match instanceof Array) {\n      return {\n        kind: kinds[i],\n        value: match[0]\n      };\n    }\n  }\n}","map":{"version":3,"sources":["../src/onlineParser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { LexRules, ParseRules, isIgnored } from './Rules';\nimport { Kind } from 'graphql';\nexport default function onlineParser(options = {\n    eatWhitespace: stream => stream.eatWhile(isIgnored),\n    lexRules: LexRules,\n    parseRules: ParseRules,\n    editorConfig: {},\n}) {\n    return {\n        startState() {\n            const initialState = {\n                level: 0,\n                step: 0,\n                name: null,\n                kind: null,\n                type: null,\n                rule: null,\n                needsSeperator: false,\n                prevState: null,\n            };\n            pushRule(options.parseRules, initialState, Kind.DOCUMENT);\n            return initialState;\n        },\n        token(stream, state) {\n            return getToken(stream, state, options);\n        },\n    };\n}\nfunction getToken(stream, state, options) {\n    if (state.inBlockstring) {\n        if (stream.match(/.*\"\"\"/)) {\n            state.inBlockstring = false;\n            return 'string';\n        }\n        else {\n            stream.skipToEnd();\n            return 'string';\n        }\n    }\n    const { lexRules, parseRules, eatWhitespace, editorConfig } = options;\n    if (state.rule && state.rule.length === 0) {\n        popRule(state);\n    }\n    else if (state.needsAdvance) {\n        state.needsAdvance = false;\n        advanceRule(state, true);\n    }\n    if (stream.sol()) {\n        const tabSize = (editorConfig && editorConfig.tabSize) || 2;\n        state.indentLevel = Math.floor(stream.indentation() / tabSize);\n    }\n    if (eatWhitespace(stream)) {\n        return 'ws';\n    }\n    const token = lex(lexRules, stream);\n    if (!token) {\n        const matchedSomething = stream.match(/\\S+/);\n        if (!matchedSomething) {\n            stream.match(/\\s/);\n        }\n        pushRule(SpecialParseRules, state, 'Invalid');\n        return 'invalidchar';\n    }\n    if (token.kind === 'Comment') {\n        pushRule(SpecialParseRules, state, 'Comment');\n        return 'comment';\n    }\n    const backupState = assign({}, state);\n    if (token.kind === 'Punctuation') {\n        if (/^[{([]/.test(token.value)) {\n            if (state.indentLevel !== undefined) {\n                state.levels = (state.levels || []).concat(state.indentLevel + 1);\n            }\n        }\n        else if (/^[})\\]]/.test(token.value)) {\n            const levels = (state.levels = (state.levels || []).slice(0, -1));\n            if (state.indentLevel) {\n                if (levels.length > 0 &&\n                    levels[levels.length - 1] < state.indentLevel) {\n                    state.indentLevel = levels[levels.length - 1];\n                }\n            }\n        }\n    }\n    while (state.rule) {\n        let expected = typeof state.rule === 'function'\n            ? state.step === 0\n                ? state.rule(token, stream)\n                : null\n            : state.rule[state.step];\n        if (state.needsSeperator) {\n            expected = expected && (expected === null || expected === void 0 ? void 0 : expected.separator);\n        }\n        if (expected) {\n            if (expected.ofRule) {\n                expected = expected.ofRule;\n            }\n            if (typeof expected === 'string') {\n                pushRule(parseRules, state, expected);\n                continue;\n            }\n            if (expected.match && expected.match(token)) {\n                if (expected.update) {\n                    expected.update(state, token);\n                }\n                if (token.kind === 'Punctuation') {\n                    advanceRule(state, true);\n                }\n                else {\n                    state.needsAdvance = true;\n                }\n                return expected.style;\n            }\n        }\n        unsuccessful(state);\n    }\n    assign(state, backupState);\n    pushRule(SpecialParseRules, state, 'Invalid');\n    return 'invalidchar';\n}\nfunction assign(to, from) {\n    const keys = Object.keys(from);\n    for (let i = 0; i < keys.length; i++) {\n        to[keys[i]] = from[keys[i]];\n    }\n    return to;\n}\nconst SpecialParseRules = {\n    Invalid: [],\n    Comment: [],\n};\nfunction pushRule(rules, state, ruleKind) {\n    if (!rules[ruleKind]) {\n        throw new TypeError('Unknown rule: ' + ruleKind);\n    }\n    state.prevState = Object.assign({}, state);\n    state.kind = ruleKind;\n    state.name = null;\n    state.type = null;\n    state.rule = rules[ruleKind];\n    state.step = 0;\n    state.needsSeperator = false;\n}\nfunction popRule(state) {\n    if (!state.prevState) {\n        return;\n    }\n    state.kind = state.prevState.kind;\n    state.name = state.prevState.name;\n    state.type = state.prevState.type;\n    state.rule = state.prevState.rule;\n    state.step = state.prevState.step;\n    state.needsSeperator = state.prevState.needsSeperator;\n    state.prevState = state.prevState.prevState;\n}\nfunction advanceRule(state, successful) {\n    if (isList(state) && state.rule) {\n        const step = state.rule[state.step];\n        if (step.separator) {\n            const separator = step.separator;\n            state.needsSeperator = !state.needsSeperator;\n            if (!state.needsSeperator && separator.ofRule) {\n                return;\n            }\n        }\n        if (successful) {\n            return;\n        }\n    }\n    state.needsSeperator = false;\n    state.step++;\n    while (state.rule &&\n        !(Array.isArray(state.rule) && state.step < state.rule.length)) {\n        popRule(state);\n        if (state.rule) {\n            if (isList(state)) {\n                if (state.rule && state.rule[state.step].separator) {\n                    state.needsSeperator = !state.needsSeperator;\n                }\n            }\n            else {\n                state.needsSeperator = false;\n                state.step++;\n            }\n        }\n    }\n}\nfunction isList(state) {\n    const step = Array.isArray(state.rule) &&\n        typeof state.rule[state.step] !== 'string' &&\n        state.rule[state.step];\n    return step && step.isList;\n}\nfunction unsuccessful(state) {\n    while (state.rule &&\n        !(Array.isArray(state.rule) && state.rule[state.step].ofRule)) {\n        popRule(state);\n    }\n    if (state.rule) {\n        advanceRule(state, false);\n    }\n}\nfunction lex(lexRules, stream) {\n    const kinds = Object.keys(lexRules);\n    for (let i = 0; i < kinds.length; i++) {\n        const match = stream.match(lexRules[kinds[i]]);\n        if (match && match instanceof Array) {\n            return { kind: kinds[i], value: match[0] };\n        }\n    }\n}\n//# sourceMappingURL=onlineParser.js.map"]},"metadata":{},"sourceType":"module"}