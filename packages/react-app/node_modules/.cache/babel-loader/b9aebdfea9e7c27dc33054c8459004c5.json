{"ast":null,"code":"import _regeneratorRuntime from \"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _slicedToArray from \"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\nvar _jsxFileName = \"/Users/sam/Desktop/kiwik/packages/react-app/src/components/BytesStringInput.jsx\",\n    _s = $RefreshSig$();\n\nimport { Input } from \"antd\";\nimport React, { useEffect, useState } from \"react\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nvar _require = require(\"ethers\"),\n    utils = _require.utils,\n    constants = _require.constants;\n/** \n  ~ What it does? ~\n\n  Displays input field with options to convert between STRING and BYTES32\n\n  ~ How can I use? ~\n\n  <BytesStringInput\n    autofocus\n    value={\"scaffold-eth\"}\n    placeholder=\"Enter value...\"\n    onChange={value => {\n      setValue(value);\n    }}\n  />\n\n  ~ Features ~\n\n  - Provide value={value} to specify initial string\n  - Provide placeholder=\"Enter value...\" value for the input\n  - Control input change by onChange={value => { setValue(value);}}\n\n**/\n\n\nexport default function BytesStringInput(props) {\n  _s();\n\n  var _this = this;\n\n  var _useState = useState(\"STRING\"),\n      _useState2 = _slicedToArray(_useState, 2),\n      mode = _useState2[0],\n      setMode = _useState2[1];\n\n  var _useState3 = useState(),\n      _useState4 = _slicedToArray(_useState3, 2),\n      display = _useState4[0],\n      setDisplay = _useState4[1];\n\n  var _useState5 = useState(constants.HashZero),\n      _useState6 = _slicedToArray(_useState5, 2),\n      value = _useState6[0],\n      setValue = _useState6[1]; // current value is the value in bytes32\n\n\n  var currentValue = typeof props.value !== \"undefined\" ? props.value : value;\n\n  var option = function option(title) {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        cursor: \"pointer\"\n      },\n      onClick: function onClick() {\n        if (mode === \"STRING\") {\n          setMode(\"BYTES32\");\n\n          if (!utils.isHexString(currentValue)) {\n            /* in case user enters invalid bytes32 number,\n                 it considers it as string and converts to bytes32 */\n            var changedValue = utils.formatBytes32String(currentValue);\n            setDisplay(changedValue);\n          } else {\n            setDisplay(currentValue);\n          }\n        } else {\n          setMode(\"STRING\");\n\n          if (currentValue && utils.isHexString(currentValue)) {\n            setDisplay(utils.parseBytes32String(currentValue));\n          } else {\n            setDisplay(currentValue);\n          }\n        }\n      },\n      children: title\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 40,\n      columnNumber: 7\n    }, _this);\n  };\n\n  var addonAfter;\n\n  if (mode === \"STRING\") {\n    addonAfter = option(\"STRING ðŸ”€\");\n  } else {\n    addonAfter = option(\"BYTES32 ðŸ”€\");\n  }\n\n  useEffect(function () {\n    if (!currentValue) {\n      setDisplay(\"\");\n    }\n  }, [currentValue]);\n  return /*#__PURE__*/_jsxDEV(Input, {\n    placeholder: props.placeholder ? props.placeholder : \"Enter value in \" + mode,\n    autoFocus: props.autoFocus,\n    value: display,\n    addonAfter: addonAfter,\n    onChange: /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(e) {\n        var newValue;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                newValue = e.target.value;\n\n                if (mode === \"STRING\") {\n                  // const ethValue = parseFloat(newValue) / props.price;\n                  // setValue(ethValue);\n                  if (typeof props.onChange === \"function\") {\n                    props.onChange(utils.formatBytes32String(newValue));\n                  }\n\n                  setValue(utils.formatBytes32String(newValue));\n                  setDisplay(newValue);\n                } else {\n                  if (typeof props.onChange === \"function\") {\n                    props.onChange(newValue);\n                  }\n\n                  setValue(newValue);\n                  setDisplay(newValue);\n                }\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }()\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 82,\n    columnNumber: 5\n  }, this);\n}\n\n_s(BytesStringInput, \"Q0b/1t/0+Dyow4AhGaAVa+Dc/Gc=\");\n\n_c = BytesStringInput;\n\nvar _c;\n\n$RefreshReg$(_c, \"BytesStringInput\");","map":{"version":3,"sources":["/Users/sam/Desktop/kiwik/packages/react-app/src/components/BytesStringInput.jsx"],"names":["Input","React","useEffect","useState","require","utils","constants","BytesStringInput","props","mode","setMode","display","setDisplay","HashZero","value","setValue","currentValue","option","title","cursor","isHexString","changedValue","formatBytes32String","parseBytes32String","addonAfter","placeholder","autoFocus","e","newValue","target","onChange"],"mappings":"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","sourcesContent":["import { Input } from \"antd\";\nimport React, { useEffect, useState } from \"react\";\n\nconst { utils, constants } = require(\"ethers\");\n\n/** \n  ~ What it does? ~\n\n  Displays input field with options to convert between STRING and BYTES32\n\n  ~ How can I use? ~\n\n  <BytesStringInput\n    autofocus\n    value={\"scaffold-eth\"}\n    placeholder=\"Enter value...\"\n    onChange={value => {\n      setValue(value);\n    }}\n  />\n\n  ~ Features ~\n\n  - Provide value={value} to specify initial string\n  - Provide placeholder=\"Enter value...\" value for the input\n  - Control input change by onChange={value => { setValue(value);}}\n\n**/\n\nexport default function BytesStringInput(props) {\n  const [mode, setMode] = useState(\"STRING\");\n  const [display, setDisplay] = useState();\n  const [value, setValue] = useState(constants.HashZero);\n\n  // current value is the value in bytes32\n  const currentValue = typeof props.value !== \"undefined\" ? props.value : value;\n\n  const option = title => {\n    return (\n      <div\n        style={{ cursor: \"pointer\" }}\n        onClick={() => {\n          if (mode === \"STRING\") {\n            setMode(\"BYTES32\");\n            if (!utils.isHexString(currentValue)) {\n              /* in case user enters invalid bytes32 number,\n                   it considers it as string and converts to bytes32 */\n              const changedValue = utils.formatBytes32String(currentValue);\n              setDisplay(changedValue);\n            } else {\n              setDisplay(currentValue);\n            }\n          } else {\n            setMode(\"STRING\");\n            if (currentValue && utils.isHexString(currentValue)) {\n              setDisplay(utils.parseBytes32String(currentValue));\n            } else {\n              setDisplay(currentValue);\n            }\n          }\n        }}\n      >\n        {title}\n      </div>\n    );\n  };\n\n  let addonAfter;\n  if (mode === \"STRING\") {\n    addonAfter = option(\"STRING ðŸ”€\");\n  } else {\n    addonAfter = option(\"BYTES32 ðŸ”€\");\n  }\n\n  useEffect(() => {\n    if (!currentValue) {\n      setDisplay(\"\");\n    }\n  }, [currentValue]);\n\n  return (\n    <Input\n      placeholder={props.placeholder ? props.placeholder : \"Enter value in \" + mode}\n      autoFocus={props.autoFocus}\n      value={display}\n      addonAfter={addonAfter}\n      onChange={async e => {\n        const newValue = e.target.value;\n        if (mode === \"STRING\") {\n          // const ethValue = parseFloat(newValue) / props.price;\n          // setValue(ethValue);\n          if (typeof props.onChange === \"function\") {\n            props.onChange(utils.formatBytes32String(newValue));\n          }\n          setValue(utils.formatBytes32String(newValue));\n          setDisplay(newValue);\n        } else {\n          if (typeof props.onChange === \"function\") {\n            props.onChange(newValue);\n          }\n          setValue(newValue);\n          setDisplay(newValue);\n        }\n      }}\n    />\n  );\n}\n"]},"metadata":{},"sourceType":"module"}