{"ast":null,"code":"import _toConsumableArray from \"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { CompletionItemKind } from 'vscode-languageserver-types';\nimport { isInterfaceType, GraphQLInterfaceType, GraphQLObjectType, Kind, DirectiveLocation } from 'graphql';\nimport { GraphQLBoolean, GraphQLEnumType, GraphQLInputObjectType, GraphQLList, SchemaMetaFieldDef, TypeMetaFieldDef, TypeNameMetaFieldDef, assertAbstractType, doTypesOverlap, getNamedType, getNullableType, isAbstractType, isCompositeType, isInputType, visit, parse } from 'graphql';\nimport { CharacterStream, onlineParser, RuleKinds } from 'graphql-language-service-parser';\nimport { forEachState, getDefinitionState, getFieldDef, hintList, objectValues } from './autocompleteUtils';\n\nvar collectFragmentDefs = function collectFragmentDefs(op) {\n  var externalFragments = [];\n\n  if (op) {\n    visit(parse(op, {\n      allowLegacyFragmentVariables: true\n    }), {\n      FragmentDefinition: function FragmentDefinition(def) {\n        externalFragments.push(def);\n      }\n    });\n  }\n\n  return externalFragments;\n};\n\nexport function getAutocompleteSuggestions(schema, queryText, cursor, contextToken, fragmentDefs) {\n  var _a;\n\n  var token = contextToken || getTokenAtPosition(queryText, cursor);\n  var state = token.state.kind === 'Invalid' ? token.state.prevState : token.state;\n\n  if (!state) {\n    return [];\n  }\n\n  var kind = state.kind;\n  var step = state.step;\n  var typeInfo = getTypeInfo(schema, token.state);\n\n  if (kind === RuleKinds.DOCUMENT) {\n    return hintList(token, [{\n      label: 'query',\n      kind: CompletionItemKind.Function\n    }, {\n      label: 'mutation',\n      kind: CompletionItemKind.Function\n    }, {\n      label: 'subscription',\n      kind: CompletionItemKind.Function\n    }, {\n      label: 'fragment',\n      kind: CompletionItemKind.Function\n    }, {\n      label: '{',\n      kind: CompletionItemKind.Constructor\n    }]);\n  }\n\n  if (kind === RuleKinds.IMPLEMENTS || kind === RuleKinds.NAMED_TYPE && ((_a = state.prevState) === null || _a === void 0 ? void 0 : _a.kind) === RuleKinds.IMPLEMENTS) {\n    return getSuggestionsForImplements(token, state, schema, queryText, typeInfo);\n  }\n\n  if (kind === RuleKinds.SELECTION_SET || kind === RuleKinds.FIELD || kind === RuleKinds.ALIASED_FIELD) {\n    return getSuggestionsForFieldNames(token, typeInfo, schema);\n  }\n\n  if (kind === RuleKinds.ARGUMENTS || kind === RuleKinds.ARGUMENT && step === 0) {\n    var argDefs = typeInfo.argDefs;\n\n    if (argDefs) {\n      return hintList(token, argDefs.map(function (argDef) {\n        var _a;\n\n        return {\n          label: argDef.name,\n          detail: String(argDef.type),\n          documentation: (_a = argDef.description) !== null && _a !== void 0 ? _a : undefined,\n          kind: CompletionItemKind.Variable,\n          type: argDef.type\n        };\n      }));\n    }\n  }\n\n  if (kind === RuleKinds.OBJECT_VALUE || kind === RuleKinds.OBJECT_FIELD && step === 0) {\n    if (typeInfo.objectFieldDefs) {\n      var objectFields = objectValues(typeInfo.objectFieldDefs);\n      var completionKind = kind === RuleKinds.OBJECT_VALUE ? CompletionItemKind.Value : CompletionItemKind.Field;\n      return hintList(token, objectFields.map(function (field) {\n        var _a;\n\n        return {\n          label: field.name,\n          detail: String(field.type),\n          documentation: (_a = field.description) !== null && _a !== void 0 ? _a : undefined,\n          kind: completionKind,\n          type: field.type\n        };\n      }));\n    }\n  }\n\n  if (kind === RuleKinds.ENUM_VALUE || kind === RuleKinds.LIST_VALUE && step === 1 || kind === RuleKinds.OBJECT_FIELD && step === 2 || kind === RuleKinds.ARGUMENT && step === 2) {\n    return getSuggestionsForInputValues(token, typeInfo, queryText, schema);\n  }\n\n  if (kind === RuleKinds.VARIABLE && step === 1) {\n    var namedInputType = getNamedType(typeInfo.inputType);\n    var variableDefinitions = getVariableCompletions(queryText, schema);\n    return hintList(token, variableDefinitions.filter(function (v) {\n      return v.detail === (namedInputType === null || namedInputType === void 0 ? void 0 : namedInputType.name);\n    }));\n  }\n\n  if (kind === RuleKinds.TYPE_CONDITION && step === 1 || kind === RuleKinds.NAMED_TYPE && state.prevState != null && state.prevState.kind === RuleKinds.TYPE_CONDITION) {\n    return getSuggestionsForFragmentTypeConditions(token, typeInfo, schema, kind);\n  }\n\n  if (kind === RuleKinds.FRAGMENT_SPREAD && step === 1) {\n    return getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText, Array.isArray(fragmentDefs) ? fragmentDefs : collectFragmentDefs(fragmentDefs));\n  }\n\n  if (kind === RuleKinds.VARIABLE_DEFINITION && step === 2 || kind === RuleKinds.LIST_TYPE && step === 1 || kind === RuleKinds.NAMED_TYPE && state.prevState && (state.prevState.kind === RuleKinds.VARIABLE_DEFINITION || state.prevState.kind === RuleKinds.LIST_TYPE || state.prevState.kind === RuleKinds.NON_NULL_TYPE)) {\n    return getSuggestionsForVariableDefinition(token, schema, kind);\n  }\n\n  if (kind === RuleKinds.DIRECTIVE) {\n    return getSuggestionsForDirective(token, state, schema, kind);\n  }\n\n  return [];\n}\n\nfunction getSuggestionsForFieldNames(token, typeInfo, schema) {\n  if (typeInfo.parentType) {\n    var parentType = typeInfo.parentType;\n    var fields = [];\n\n    if ('getFields' in parentType) {\n      fields = objectValues(parentType.getFields());\n    }\n\n    if (isCompositeType(parentType)) {\n      fields.push(TypeNameMetaFieldDef);\n    }\n\n    if (parentType === schema.getQueryType()) {\n      fields.push(SchemaMetaFieldDef, TypeMetaFieldDef);\n    }\n\n    return hintList(token, fields.map(function (field, index) {\n      var _a;\n\n      return {\n        sortText: String(index) + field.name,\n        label: field.name,\n        detail: String(field.type),\n        documentation: (_a = field.description) !== null && _a !== void 0 ? _a : undefined,\n        deprecated: Boolean(field.deprecationReason),\n        isDeprecated: Boolean(field.deprecationReason),\n        deprecationReason: field.deprecationReason,\n        kind: CompletionItemKind.Field,\n        type: field.type\n      };\n    }));\n  }\n\n  return [];\n}\n\nfunction getSuggestionsForInputValues(token, typeInfo, queryText, schema) {\n  var namedInputType = getNamedType(typeInfo.inputType);\n  var queryVariables = getVariableCompletions(queryText, schema, true).filter(function (v) {\n    return v.detail === namedInputType.name;\n  });\n\n  if (namedInputType instanceof GraphQLEnumType) {\n    var values = namedInputType.getValues();\n    return hintList(token, values.map(function (value) {\n      var _a;\n\n      return {\n        label: value.name,\n        detail: String(namedInputType),\n        documentation: (_a = value.description) !== null && _a !== void 0 ? _a : undefined,\n        deprecated: Boolean(value.deprecationReason),\n        isDeprecated: Boolean(value.deprecationReason),\n        deprecationReason: value.deprecationReason,\n        kind: CompletionItemKind.EnumMember,\n        type: namedInputType\n      };\n    }).concat(queryVariables));\n  } else if (namedInputType === GraphQLBoolean) {\n    return hintList(token, queryVariables.concat([{\n      label: 'true',\n      detail: String(GraphQLBoolean),\n      documentation: 'Not false.',\n      kind: CompletionItemKind.Variable,\n      type: GraphQLBoolean\n    }, {\n      label: 'false',\n      detail: String(GraphQLBoolean),\n      documentation: 'Not true.',\n      kind: CompletionItemKind.Variable,\n      type: GraphQLBoolean\n    }]));\n  }\n\n  return queryVariables;\n}\n\nfunction getSuggestionsForImplements(token, tokenState, schema, documentText, typeInfo) {\n  if (tokenState.needsSeperator) {\n    return [];\n  }\n\n  var typeMap = schema.getTypeMap();\n  var schemaInterfaces = objectValues(typeMap).filter(isInterfaceType);\n  var schemaInterfaceNames = schemaInterfaces.map(function (_ref) {\n    var name = _ref.name;\n    return name;\n  });\n  var inlineInterfaces = new Set();\n  runOnlineParser(documentText, function (_, state) {\n    var _a, _b, _c, _d, _e;\n\n    if (state.name) {\n      if (state.kind === RuleKinds.INTERFACE_DEF && !schemaInterfaceNames.includes(state.name)) {\n        inlineInterfaces.add(state.name);\n      }\n\n      if (state.kind === RuleKinds.NAMED_TYPE && ((_a = state.prevState) === null || _a === void 0 ? void 0 : _a.kind) === RuleKinds.IMPLEMENTS) {\n        if (typeInfo.interfaceDef) {\n          var existingType = (_b = typeInfo.interfaceDef) === null || _b === void 0 ? void 0 : _b.getInterfaces().find(function (_ref2) {\n            var name = _ref2.name;\n            return name === state.name;\n          });\n\n          if (existingType) {\n            return;\n          }\n\n          var type = schema.getType(state.name);\n          var interfaceConfig = (_c = typeInfo.interfaceDef) === null || _c === void 0 ? void 0 : _c.toConfig();\n          typeInfo.interfaceDef = new GraphQLInterfaceType(Object.assign(Object.assign({}, interfaceConfig), {\n            interfaces: [].concat(_toConsumableArray(interfaceConfig.interfaces), [type || new GraphQLInterfaceType({\n              name: state.name,\n              fields: {}\n            })])\n          }));\n        } else if (typeInfo.objectTypeDef) {\n          var _existingType = (_d = typeInfo.objectTypeDef) === null || _d === void 0 ? void 0 : _d.getInterfaces().find(function (_ref3) {\n            var name = _ref3.name;\n            return name === state.name;\n          });\n\n          if (_existingType) {\n            return;\n          }\n\n          var _type = schema.getType(state.name);\n\n          var objectTypeConfig = (_e = typeInfo.objectTypeDef) === null || _e === void 0 ? void 0 : _e.toConfig();\n          typeInfo.objectTypeDef = new GraphQLObjectType(Object.assign(Object.assign({}, objectTypeConfig), {\n            interfaces: [].concat(_toConsumableArray(objectTypeConfig.interfaces), [_type || new GraphQLInterfaceType({\n              name: state.name,\n              fields: {}\n            })])\n          }));\n        }\n      }\n    }\n  });\n  var currentTypeToExtend = typeInfo.interfaceDef || typeInfo.objectTypeDef;\n  var siblingInterfaces = (currentTypeToExtend === null || currentTypeToExtend === void 0 ? void 0 : currentTypeToExtend.getInterfaces()) || [];\n  var siblingInterfaceNames = siblingInterfaces.map(function (_ref4) {\n    var name = _ref4.name;\n    return name;\n  });\n  var possibleInterfaces = schemaInterfaces.concat(_toConsumableArray(inlineInterfaces).map(function (name) {\n    return {\n      name: name\n    };\n  })).filter(function (_ref5) {\n    var name = _ref5.name;\n    return name !== (currentTypeToExtend === null || currentTypeToExtend === void 0 ? void 0 : currentTypeToExtend.name) && !siblingInterfaceNames.includes(name);\n  });\n  return hintList(token, possibleInterfaces.map(function (type) {\n    var result = {\n      label: type.name,\n      kind: CompletionItemKind.Interface,\n      type: type\n    };\n\n    if (type === null || type === void 0 ? void 0 : type.description) {\n      result.documentation = type.description;\n    }\n\n    return result;\n  }));\n}\n\nfunction getSuggestionsForFragmentTypeConditions(token, typeInfo, schema, _kind) {\n  var possibleTypes;\n\n  if (typeInfo.parentType) {\n    if (isAbstractType(typeInfo.parentType)) {\n      var abstractType = assertAbstractType(typeInfo.parentType);\n      var possibleObjTypes = schema.getPossibleTypes(abstractType);\n      var possibleIfaceMap = Object.create(null);\n      possibleObjTypes.forEach(function (type) {\n        type.getInterfaces().forEach(function (iface) {\n          possibleIfaceMap[iface.name] = iface;\n        });\n      });\n      possibleTypes = possibleObjTypes.concat(objectValues(possibleIfaceMap));\n    } else {\n      possibleTypes = [typeInfo.parentType];\n    }\n  } else {\n    var typeMap = schema.getTypeMap();\n    possibleTypes = objectValues(typeMap).filter(isCompositeType);\n  }\n\n  return hintList(token, possibleTypes.map(function (type) {\n    var namedType = getNamedType(type);\n    return {\n      label: String(type),\n      documentation: namedType && namedType.description || '',\n      kind: CompletionItemKind.Field\n    };\n  }));\n}\n\nfunction getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText, fragmentDefs) {\n  if (!queryText) {\n    return [];\n  }\n\n  var typeMap = schema.getTypeMap();\n  var defState = getDefinitionState(token.state);\n  var fragments = getFragmentDefinitions(queryText);\n\n  if (fragmentDefs && fragmentDefs.length > 0) {\n    fragments.push.apply(fragments, _toConsumableArray(fragmentDefs));\n  }\n\n  var relevantFrags = fragments.filter(function (frag) {\n    return typeMap[frag.typeCondition.name.value] && !(defState && defState.kind === RuleKinds.FRAGMENT_DEFINITION && defState.name === frag.name.value) && isCompositeType(typeInfo.parentType) && isCompositeType(typeMap[frag.typeCondition.name.value]) && doTypesOverlap(schema, typeInfo.parentType, typeMap[frag.typeCondition.name.value]);\n  });\n  return hintList(token, relevantFrags.map(function (frag) {\n    return {\n      label: frag.name.value,\n      detail: String(typeMap[frag.typeCondition.name.value]),\n      documentation: \"fragment \".concat(frag.name.value, \" on \").concat(frag.typeCondition.name.value),\n      kind: CompletionItemKind.Field,\n      type: typeMap[frag.typeCondition.name.value]\n    };\n  }));\n}\n\nvar getParentDefinition = function getParentDefinition(state, kind) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n\n  if (((_a = state.prevState) === null || _a === void 0 ? void 0 : _a.kind) === kind) {\n    return state.prevState;\n  }\n\n  if (((_c = (_b = state.prevState) === null || _b === void 0 ? void 0 : _b.prevState) === null || _c === void 0 ? void 0 : _c.kind) === kind) {\n    return state.prevState.prevState;\n  }\n\n  if (((_f = (_e = (_d = state.prevState) === null || _d === void 0 ? void 0 : _d.prevState) === null || _e === void 0 ? void 0 : _e.prevState) === null || _f === void 0 ? void 0 : _f.kind) === kind) {\n    return state.prevState.prevState.prevState;\n  }\n\n  if (((_k = (_j = (_h = (_g = state.prevState) === null || _g === void 0 ? void 0 : _g.prevState) === null || _h === void 0 ? void 0 : _h.prevState) === null || _j === void 0 ? void 0 : _j.prevState) === null || _k === void 0 ? void 0 : _k.kind) === kind) {\n    return state.prevState.prevState.prevState.prevState;\n  }\n};\n\nexport function getVariableCompletions(queryText, schema) {\n  var forcePrefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var variableName;\n  var variableType;\n  var definitions = Object.create({});\n  runOnlineParser(queryText, function (_, state) {\n    if (state.kind === RuleKinds.VARIABLE && state.name) {\n      variableName = state.name;\n    }\n\n    if (state.kind === RuleKinds.NAMED_TYPE && variableName) {\n      var parentDefinition = getParentDefinition(state, RuleKinds.TYPE);\n\n      if (parentDefinition === null || parentDefinition === void 0 ? void 0 : parentDefinition.type) {\n        variableType = schema.getType(parentDefinition === null || parentDefinition === void 0 ? void 0 : parentDefinition.type);\n      }\n    }\n\n    if (variableName && variableType) {\n      if (!definitions[variableName]) {\n        definitions[variableName] = {\n          detail: variableType.toString(),\n          label: \"$\".concat(variableName),\n          type: variableType,\n          kind: CompletionItemKind.Variable\n        };\n\n        if (forcePrefix) {\n          definitions[variableName].insertText = \"$\".concat(variableName);\n        }\n\n        variableName = null;\n        variableType = null;\n      }\n    }\n  });\n  return objectValues(definitions);\n}\nexport function getFragmentDefinitions(queryText) {\n  var fragmentDefs = [];\n  runOnlineParser(queryText, function (_, state) {\n    if (state.kind === RuleKinds.FRAGMENT_DEFINITION && state.name && state.type) {\n      fragmentDefs.push({\n        kind: RuleKinds.FRAGMENT_DEFINITION,\n        name: {\n          kind: Kind.NAME,\n          value: state.name\n        },\n        selectionSet: {\n          kind: RuleKinds.SELECTION_SET,\n          selections: []\n        },\n        typeCondition: {\n          kind: RuleKinds.NAMED_TYPE,\n          name: {\n            kind: Kind.NAME,\n            value: state.type\n          }\n        }\n      });\n    }\n  });\n  return fragmentDefs;\n}\n\nfunction getSuggestionsForVariableDefinition(token, schema, _kind) {\n  var inputTypeMap = schema.getTypeMap();\n  var inputTypes = objectValues(inputTypeMap).filter(isInputType);\n  return hintList(token, inputTypes.map(function (type) {\n    return {\n      label: type.name,\n      documentation: type.description,\n      kind: CompletionItemKind.Variable\n    };\n  }));\n}\n\nfunction getSuggestionsForDirective(token, state, schema, _kind) {\n  if (state.prevState && state.prevState.kind) {\n    var directives = schema.getDirectives().filter(function (directive) {\n      return canUseDirective(state.prevState, directive);\n    });\n    return hintList(token, directives.map(function (directive) {\n      return {\n        label: directive.name,\n        documentation: directive.description || '',\n        kind: CompletionItemKind.Function\n      };\n    }));\n  }\n\n  return [];\n}\n\nexport function getTokenAtPosition(queryText, cursor) {\n  var styleAtCursor = null;\n  var stateAtCursor = null;\n  var stringAtCursor = null;\n  var token = runOnlineParser(queryText, function (stream, state, style, index) {\n    if (index === cursor.line) {\n      if (stream.getCurrentPosition() >= cursor.character) {\n        styleAtCursor = style;\n        stateAtCursor = Object.assign({}, state);\n        stringAtCursor = stream.current();\n        return 'BREAK';\n      }\n    }\n  });\n  return {\n    start: token.start,\n    end: token.end,\n    string: stringAtCursor || token.string,\n    state: stateAtCursor || token.state,\n    style: styleAtCursor || token.style\n  };\n}\nexport function runOnlineParser(queryText, callback) {\n  var lines = queryText.split('\\n');\n  var parser = onlineParser();\n  var state = parser.startState();\n  var style = '';\n  var stream = new CharacterStream('');\n\n  for (var i = 0; i < lines.length; i++) {\n    stream = new CharacterStream(lines[i]);\n\n    while (!stream.eol()) {\n      style = parser.token(stream, state);\n      var code = callback(stream, state, style, i);\n\n      if (code === 'BREAK') {\n        break;\n      }\n    }\n\n    callback(stream, state, style, i);\n\n    if (!state.kind) {\n      state = parser.startState();\n    }\n  }\n\n  return {\n    start: stream.getStartOfToken(),\n    end: stream.getCurrentPosition(),\n    string: stream.current(),\n    state: state,\n    style: style\n  };\n}\nexport function canUseDirective(state, directive) {\n  if (!state || !state.kind) {\n    return false;\n  }\n\n  var kind = state.kind;\n  var locations = directive.locations;\n\n  switch (kind) {\n    case RuleKinds.QUERY:\n      return locations.indexOf(DirectiveLocation.QUERY) !== -1;\n\n    case RuleKinds.MUTATION:\n      return locations.indexOf(DirectiveLocation.MUTATION) !== -1;\n\n    case RuleKinds.SUBSCRIPTION:\n      return locations.indexOf(DirectiveLocation.SUBSCRIPTION) !== -1;\n\n    case RuleKinds.FIELD:\n    case RuleKinds.ALIASED_FIELD:\n      return locations.indexOf(DirectiveLocation.FIELD) !== -1;\n\n    case RuleKinds.FRAGMENT_DEFINITION:\n      return locations.indexOf(DirectiveLocation.FRAGMENT_DEFINITION) !== -1;\n\n    case RuleKinds.FRAGMENT_SPREAD:\n      return locations.indexOf(DirectiveLocation.FRAGMENT_SPREAD) !== -1;\n\n    case RuleKinds.INLINE_FRAGMENT:\n      return locations.indexOf(DirectiveLocation.INLINE_FRAGMENT) !== -1;\n\n    case RuleKinds.SCHEMA_DEF:\n      return locations.indexOf(DirectiveLocation.SCHEMA) !== -1;\n\n    case RuleKinds.SCALAR_DEF:\n      return locations.indexOf(DirectiveLocation.SCALAR) !== -1;\n\n    case RuleKinds.OBJECT_TYPE_DEF:\n      return locations.indexOf(DirectiveLocation.OBJECT) !== -1;\n\n    case RuleKinds.FIELD_DEF:\n      return locations.indexOf(DirectiveLocation.FIELD_DEFINITION) !== -1;\n\n    case RuleKinds.INTERFACE_DEF:\n      return locations.indexOf(DirectiveLocation.INTERFACE) !== -1;\n\n    case RuleKinds.UNION_DEF:\n      return locations.indexOf(DirectiveLocation.UNION) !== -1;\n\n    case RuleKinds.ENUM_DEF:\n      return locations.indexOf(DirectiveLocation.ENUM) !== -1;\n\n    case RuleKinds.ENUM_VALUE:\n      return locations.indexOf(DirectiveLocation.ENUM_VALUE) !== -1;\n\n    case RuleKinds.INPUT_DEF:\n      return locations.indexOf(DirectiveLocation.INPUT_OBJECT) !== -1;\n\n    case RuleKinds.INPUT_VALUE_DEF:\n      var prevStateKind = state.prevState && state.prevState.kind;\n\n      switch (prevStateKind) {\n        case RuleKinds.ARGUMENTS_DEF:\n          return locations.indexOf(DirectiveLocation.ARGUMENT_DEFINITION) !== -1;\n\n        case RuleKinds.INPUT_DEF:\n          return locations.indexOf(DirectiveLocation.INPUT_FIELD_DEFINITION) !== -1;\n      }\n\n  }\n\n  return false;\n}\nexport function getTypeInfo(schema, tokenState) {\n  var argDef;\n  var argDefs;\n  var directiveDef;\n  var enumValue;\n  var fieldDef;\n  var inputType;\n  var objectTypeDef;\n  var objectFieldDefs;\n  var parentType;\n  var type;\n  var interfaceDef;\n  forEachState(tokenState, function (state) {\n    switch (state.kind) {\n      case RuleKinds.QUERY:\n      case 'ShortQuery':\n        type = schema.getQueryType();\n        break;\n\n      case RuleKinds.MUTATION:\n        type = schema.getMutationType();\n        break;\n\n      case RuleKinds.SUBSCRIPTION:\n        type = schema.getSubscriptionType();\n        break;\n\n      case RuleKinds.INLINE_FRAGMENT:\n      case RuleKinds.FRAGMENT_DEFINITION:\n        if (state.type) {\n          type = schema.getType(state.type);\n        }\n\n        break;\n\n      case RuleKinds.FIELD:\n      case RuleKinds.ALIASED_FIELD:\n        {\n          if (!type || !state.name) {\n            fieldDef = null;\n          } else {\n            fieldDef = parentType ? getFieldDef(schema, parentType, state.name) : null;\n            type = fieldDef ? fieldDef.type : null;\n          }\n\n          break;\n        }\n\n      case RuleKinds.SELECTION_SET:\n        parentType = getNamedType(type);\n        break;\n\n      case RuleKinds.DIRECTIVE:\n        directiveDef = state.name ? schema.getDirective(state.name) : null;\n        break;\n\n      case RuleKinds.INTERFACE_DEF:\n        if (state.name) {\n          objectTypeDef = null;\n          interfaceDef = new GraphQLInterfaceType({\n            name: state.name,\n            interfaces: [],\n            fields: {}\n          });\n        }\n\n        break;\n\n      case RuleKinds.OBJECT_TYPE_DEF:\n        if (state.name) {\n          interfaceDef = null;\n          objectTypeDef = new GraphQLObjectType({\n            name: state.name,\n            interfaces: [],\n            fields: {}\n          });\n        }\n\n        break;\n\n      case RuleKinds.ARGUMENTS:\n        {\n          if (!state.prevState) {\n            argDefs = null;\n          } else {\n            switch (state.prevState.kind) {\n              case RuleKinds.FIELD:\n                argDefs = fieldDef && fieldDef.args;\n                break;\n\n              case RuleKinds.DIRECTIVE:\n                argDefs = directiveDef && directiveDef.args;\n                break;\n\n              case RuleKinds.ALIASED_FIELD:\n                {\n                  var name = state.prevState && state.prevState.name;\n\n                  if (!name) {\n                    argDefs = null;\n                    break;\n                  }\n\n                  var field = parentType ? getFieldDef(schema, parentType, name) : null;\n\n                  if (!field) {\n                    argDefs = null;\n                    break;\n                  }\n\n                  argDefs = field.args;\n                  break;\n                }\n\n              default:\n                argDefs = null;\n                break;\n            }\n          }\n\n          break;\n        }\n\n      case RuleKinds.ARGUMENT:\n        if (argDefs) {\n          for (var i = 0; i < argDefs.length; i++) {\n            if (argDefs[i].name === state.name) {\n              argDef = argDefs[i];\n              break;\n            }\n          }\n        }\n\n        inputType = argDef && argDef.type;\n        break;\n\n      case RuleKinds.ENUM_VALUE:\n        var enumType = getNamedType(inputType);\n        enumValue = enumType instanceof GraphQLEnumType ? find(enumType.getValues(), function (val) {\n          return val.value === state.name;\n        }) : null;\n        break;\n\n      case RuleKinds.LIST_VALUE:\n        var nullableType = getNullableType(inputType);\n        inputType = nullableType instanceof GraphQLList ? nullableType.ofType : null;\n        break;\n\n      case RuleKinds.OBJECT_VALUE:\n        var objectType = getNamedType(inputType);\n        objectFieldDefs = objectType instanceof GraphQLInputObjectType ? objectType.getFields() : null;\n        break;\n\n      case RuleKinds.OBJECT_FIELD:\n        var objectField = state.name && objectFieldDefs ? objectFieldDefs[state.name] : null;\n        inputType = objectField && objectField.type;\n        break;\n\n      case RuleKinds.NAMED_TYPE:\n        if (state.name) {\n          type = schema.getType(state.name);\n        }\n\n        break;\n    }\n  });\n  return {\n    argDef: argDef,\n    argDefs: argDefs,\n    directiveDef: directiveDef,\n    enumValue: enumValue,\n    fieldDef: fieldDef,\n    inputType: inputType,\n    objectFieldDefs: objectFieldDefs,\n    parentType: parentType,\n    type: type,\n    interfaceDef: interfaceDef,\n    objectTypeDef: objectTypeDef\n  };\n}\n\nfunction find(array, predicate) {\n  for (var i = 0; i < array.length; i++) {\n    if (predicate(array[i])) {\n      return array[i];\n    }\n  }\n\n  return null;\n}","map":{"version":3,"sources":["../src/getAutocompleteSuggestions.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { CompletionItemKind } from 'vscode-languageserver-types';\nimport { isInterfaceType, GraphQLInterfaceType, GraphQLObjectType, Kind, DirectiveLocation, } from 'graphql';\nimport { GraphQLBoolean, GraphQLEnumType, GraphQLInputObjectType, GraphQLList, SchemaMetaFieldDef, TypeMetaFieldDef, TypeNameMetaFieldDef, assertAbstractType, doTypesOverlap, getNamedType, getNullableType, isAbstractType, isCompositeType, isInputType, visit, parse, } from 'graphql';\nimport { CharacterStream, onlineParser, RuleKinds, } from 'graphql-language-service-parser';\nimport { forEachState, getDefinitionState, getFieldDef, hintList, objectValues, } from './autocompleteUtils';\nconst collectFragmentDefs = (op) => {\n    const externalFragments = [];\n    if (op) {\n        visit(parse(op, {\n            allowLegacyFragmentVariables: true,\n        }), {\n            FragmentDefinition(def) {\n                externalFragments.push(def);\n            },\n        });\n    }\n    return externalFragments;\n};\nexport function getAutocompleteSuggestions(schema, queryText, cursor, contextToken, fragmentDefs) {\n    var _a;\n    const token = contextToken || getTokenAtPosition(queryText, cursor);\n    const state = token.state.kind === 'Invalid' ? token.state.prevState : token.state;\n    if (!state) {\n        return [];\n    }\n    const kind = state.kind;\n    const step = state.step;\n    const typeInfo = getTypeInfo(schema, token.state);\n    if (kind === RuleKinds.DOCUMENT) {\n        return hintList(token, [\n            { label: 'query', kind: CompletionItemKind.Function },\n            { label: 'mutation', kind: CompletionItemKind.Function },\n            { label: 'subscription', kind: CompletionItemKind.Function },\n            { label: 'fragment', kind: CompletionItemKind.Function },\n            { label: '{', kind: CompletionItemKind.Constructor },\n        ]);\n    }\n    if (kind === RuleKinds.IMPLEMENTS ||\n        (kind === RuleKinds.NAMED_TYPE &&\n            ((_a = state.prevState) === null || _a === void 0 ? void 0 : _a.kind) === RuleKinds.IMPLEMENTS)) {\n        return getSuggestionsForImplements(token, state, schema, queryText, typeInfo);\n    }\n    if (kind === RuleKinds.SELECTION_SET ||\n        kind === RuleKinds.FIELD ||\n        kind === RuleKinds.ALIASED_FIELD) {\n        return getSuggestionsForFieldNames(token, typeInfo, schema);\n    }\n    if (kind === RuleKinds.ARGUMENTS ||\n        (kind === RuleKinds.ARGUMENT && step === 0)) {\n        const argDefs = typeInfo.argDefs;\n        if (argDefs) {\n            return hintList(token, argDefs.map(argDef => {\n                var _a;\n                return ({\n                    label: argDef.name,\n                    detail: String(argDef.type),\n                    documentation: (_a = argDef.description) !== null && _a !== void 0 ? _a : undefined,\n                    kind: CompletionItemKind.Variable,\n                    type: argDef.type,\n                });\n            }));\n        }\n    }\n    if (kind === RuleKinds.OBJECT_VALUE ||\n        (kind === RuleKinds.OBJECT_FIELD && step === 0)) {\n        if (typeInfo.objectFieldDefs) {\n            const objectFields = objectValues(typeInfo.objectFieldDefs);\n            const completionKind = kind === RuleKinds.OBJECT_VALUE\n                ? CompletionItemKind.Value\n                : CompletionItemKind.Field;\n            return hintList(token, objectFields.map(field => {\n                var _a;\n                return ({\n                    label: field.name,\n                    detail: String(field.type),\n                    documentation: (_a = field.description) !== null && _a !== void 0 ? _a : undefined,\n                    kind: completionKind,\n                    type: field.type,\n                });\n            }));\n        }\n    }\n    if (kind === RuleKinds.ENUM_VALUE ||\n        (kind === RuleKinds.LIST_VALUE && step === 1) ||\n        (kind === RuleKinds.OBJECT_FIELD && step === 2) ||\n        (kind === RuleKinds.ARGUMENT && step === 2)) {\n        return getSuggestionsForInputValues(token, typeInfo, queryText, schema);\n    }\n    if (kind === RuleKinds.VARIABLE && step === 1) {\n        const namedInputType = getNamedType(typeInfo.inputType);\n        const variableDefinitions = getVariableCompletions(queryText, schema);\n        return hintList(token, variableDefinitions.filter(v => v.detail === (namedInputType === null || namedInputType === void 0 ? void 0 : namedInputType.name)));\n    }\n    if ((kind === RuleKinds.TYPE_CONDITION && step === 1) ||\n        (kind === RuleKinds.NAMED_TYPE &&\n            state.prevState != null &&\n            state.prevState.kind === RuleKinds.TYPE_CONDITION)) {\n        return getSuggestionsForFragmentTypeConditions(token, typeInfo, schema, kind);\n    }\n    if (kind === RuleKinds.FRAGMENT_SPREAD && step === 1) {\n        return getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText, Array.isArray(fragmentDefs)\n            ? fragmentDefs\n            : collectFragmentDefs(fragmentDefs));\n    }\n    if ((kind === RuleKinds.VARIABLE_DEFINITION && step === 2) ||\n        (kind === RuleKinds.LIST_TYPE && step === 1) ||\n        (kind === RuleKinds.NAMED_TYPE &&\n            state.prevState &&\n            (state.prevState.kind === RuleKinds.VARIABLE_DEFINITION ||\n                state.prevState.kind === RuleKinds.LIST_TYPE ||\n                state.prevState.kind === RuleKinds.NON_NULL_TYPE))) {\n        return getSuggestionsForVariableDefinition(token, schema, kind);\n    }\n    if (kind === RuleKinds.DIRECTIVE) {\n        return getSuggestionsForDirective(token, state, schema, kind);\n    }\n    return [];\n}\nfunction getSuggestionsForFieldNames(token, typeInfo, schema) {\n    if (typeInfo.parentType) {\n        const parentType = typeInfo.parentType;\n        let fields = [];\n        if ('getFields' in parentType) {\n            fields = objectValues(parentType.getFields());\n        }\n        if (isCompositeType(parentType)) {\n            fields.push(TypeNameMetaFieldDef);\n        }\n        if (parentType === schema.getQueryType()) {\n            fields.push(SchemaMetaFieldDef, TypeMetaFieldDef);\n        }\n        return hintList(token, fields.map((field, index) => {\n            var _a;\n            return ({\n                sortText: String(index) + field.name,\n                label: field.name,\n                detail: String(field.type),\n                documentation: (_a = field.description) !== null && _a !== void 0 ? _a : undefined,\n                deprecated: Boolean(field.deprecationReason),\n                isDeprecated: Boolean(field.deprecationReason),\n                deprecationReason: field.deprecationReason,\n                kind: CompletionItemKind.Field,\n                type: field.type,\n            });\n        }));\n    }\n    return [];\n}\nfunction getSuggestionsForInputValues(token, typeInfo, queryText, schema) {\n    const namedInputType = getNamedType(typeInfo.inputType);\n    const queryVariables = getVariableCompletions(queryText, schema, true).filter(v => v.detail === namedInputType.name);\n    if (namedInputType instanceof GraphQLEnumType) {\n        const values = namedInputType.getValues();\n        return hintList(token, values\n            .map((value) => {\n            var _a;\n            return ({\n                label: value.name,\n                detail: String(namedInputType),\n                documentation: (_a = value.description) !== null && _a !== void 0 ? _a : undefined,\n                deprecated: Boolean(value.deprecationReason),\n                isDeprecated: Boolean(value.deprecationReason),\n                deprecationReason: value.deprecationReason,\n                kind: CompletionItemKind.EnumMember,\n                type: namedInputType,\n            });\n        })\n            .concat(queryVariables));\n    }\n    else if (namedInputType === GraphQLBoolean) {\n        return hintList(token, queryVariables.concat([\n            {\n                label: 'true',\n                detail: String(GraphQLBoolean),\n                documentation: 'Not false.',\n                kind: CompletionItemKind.Variable,\n                type: GraphQLBoolean,\n            },\n            {\n                label: 'false',\n                detail: String(GraphQLBoolean),\n                documentation: 'Not true.',\n                kind: CompletionItemKind.Variable,\n                type: GraphQLBoolean,\n            },\n        ]));\n    }\n    return queryVariables;\n}\nfunction getSuggestionsForImplements(token, tokenState, schema, documentText, typeInfo) {\n    if (tokenState.needsSeperator) {\n        return [];\n    }\n    const typeMap = schema.getTypeMap();\n    const schemaInterfaces = objectValues(typeMap).filter(isInterfaceType);\n    const schemaInterfaceNames = schemaInterfaces.map(({ name }) => name);\n    const inlineInterfaces = new Set();\n    runOnlineParser(documentText, (_, state) => {\n        var _a, _b, _c, _d, _e;\n        if (state.name) {\n            if (state.kind === RuleKinds.INTERFACE_DEF &&\n                !schemaInterfaceNames.includes(state.name)) {\n                inlineInterfaces.add(state.name);\n            }\n            if (state.kind === RuleKinds.NAMED_TYPE &&\n                ((_a = state.prevState) === null || _a === void 0 ? void 0 : _a.kind) === RuleKinds.IMPLEMENTS) {\n                if (typeInfo.interfaceDef) {\n                    const existingType = (_b = typeInfo.interfaceDef) === null || _b === void 0 ? void 0 : _b.getInterfaces().find(({ name }) => name === state.name);\n                    if (existingType) {\n                        return;\n                    }\n                    const type = schema.getType(state.name);\n                    const interfaceConfig = (_c = typeInfo.interfaceDef) === null || _c === void 0 ? void 0 : _c.toConfig();\n                    typeInfo.interfaceDef = new GraphQLInterfaceType(Object.assign(Object.assign({}, interfaceConfig), { interfaces: [\n                            ...interfaceConfig.interfaces,\n                            type ||\n                                new GraphQLInterfaceType({ name: state.name, fields: {} }),\n                        ] }));\n                }\n                else if (typeInfo.objectTypeDef) {\n                    const existingType = (_d = typeInfo.objectTypeDef) === null || _d === void 0 ? void 0 : _d.getInterfaces().find(({ name }) => name === state.name);\n                    if (existingType) {\n                        return;\n                    }\n                    const type = schema.getType(state.name);\n                    const objectTypeConfig = (_e = typeInfo.objectTypeDef) === null || _e === void 0 ? void 0 : _e.toConfig();\n                    typeInfo.objectTypeDef = new GraphQLObjectType(Object.assign(Object.assign({}, objectTypeConfig), { interfaces: [\n                            ...objectTypeConfig.interfaces,\n                            type ||\n                                new GraphQLInterfaceType({ name: state.name, fields: {} }),\n                        ] }));\n                }\n            }\n        }\n    });\n    const currentTypeToExtend = typeInfo.interfaceDef || typeInfo.objectTypeDef;\n    const siblingInterfaces = (currentTypeToExtend === null || currentTypeToExtend === void 0 ? void 0 : currentTypeToExtend.getInterfaces()) || [];\n    const siblingInterfaceNames = siblingInterfaces.map(({ name }) => name);\n    const possibleInterfaces = schemaInterfaces\n        .concat([...inlineInterfaces].map(name => ({ name })))\n        .filter(({ name }) => name !== (currentTypeToExtend === null || currentTypeToExtend === void 0 ? void 0 : currentTypeToExtend.name) &&\n        !siblingInterfaceNames.includes(name));\n    return hintList(token, possibleInterfaces.map(type => {\n        const result = {\n            label: type.name,\n            kind: CompletionItemKind.Interface,\n            type,\n        };\n        if (type === null || type === void 0 ? void 0 : type.description) {\n            result.documentation = type.description;\n        }\n        return result;\n    }));\n}\nfunction getSuggestionsForFragmentTypeConditions(token, typeInfo, schema, _kind) {\n    let possibleTypes;\n    if (typeInfo.parentType) {\n        if (isAbstractType(typeInfo.parentType)) {\n            const abstractType = assertAbstractType(typeInfo.parentType);\n            const possibleObjTypes = schema.getPossibleTypes(abstractType);\n            const possibleIfaceMap = Object.create(null);\n            possibleObjTypes.forEach(type => {\n                type.getInterfaces().forEach(iface => {\n                    possibleIfaceMap[iface.name] = iface;\n                });\n            });\n            possibleTypes = possibleObjTypes.concat(objectValues(possibleIfaceMap));\n        }\n        else {\n            possibleTypes = [typeInfo.parentType];\n        }\n    }\n    else {\n        const typeMap = schema.getTypeMap();\n        possibleTypes = objectValues(typeMap).filter(isCompositeType);\n    }\n    return hintList(token, possibleTypes.map(type => {\n        const namedType = getNamedType(type);\n        return {\n            label: String(type),\n            documentation: (namedType && namedType.description) || '',\n            kind: CompletionItemKind.Field,\n        };\n    }));\n}\nfunction getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText, fragmentDefs) {\n    if (!queryText) {\n        return [];\n    }\n    const typeMap = schema.getTypeMap();\n    const defState = getDefinitionState(token.state);\n    const fragments = getFragmentDefinitions(queryText);\n    if (fragmentDefs && fragmentDefs.length > 0) {\n        fragments.push(...fragmentDefs);\n    }\n    const relevantFrags = fragments.filter(frag => typeMap[frag.typeCondition.name.value] &&\n        !(defState &&\n            defState.kind === RuleKinds.FRAGMENT_DEFINITION &&\n            defState.name === frag.name.value) &&\n        isCompositeType(typeInfo.parentType) &&\n        isCompositeType(typeMap[frag.typeCondition.name.value]) &&\n        doTypesOverlap(schema, typeInfo.parentType, typeMap[frag.typeCondition.name.value]));\n    return hintList(token, relevantFrags.map(frag => ({\n        label: frag.name.value,\n        detail: String(typeMap[frag.typeCondition.name.value]),\n        documentation: `fragment ${frag.name.value} on ${frag.typeCondition.name.value}`,\n        kind: CompletionItemKind.Field,\n        type: typeMap[frag.typeCondition.name.value],\n    })));\n}\nconst getParentDefinition = (state, kind) => {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n    if (((_a = state.prevState) === null || _a === void 0 ? void 0 : _a.kind) === kind) {\n        return state.prevState;\n    }\n    if (((_c = (_b = state.prevState) === null || _b === void 0 ? void 0 : _b.prevState) === null || _c === void 0 ? void 0 : _c.kind) === kind) {\n        return state.prevState.prevState;\n    }\n    if (((_f = (_e = (_d = state.prevState) === null || _d === void 0 ? void 0 : _d.prevState) === null || _e === void 0 ? void 0 : _e.prevState) === null || _f === void 0 ? void 0 : _f.kind) === kind) {\n        return state.prevState.prevState.prevState;\n    }\n    if (((_k = (_j = (_h = (_g = state.prevState) === null || _g === void 0 ? void 0 : _g.prevState) === null || _h === void 0 ? void 0 : _h.prevState) === null || _j === void 0 ? void 0 : _j.prevState) === null || _k === void 0 ? void 0 : _k.kind) === kind) {\n        return state.prevState.prevState.prevState.prevState;\n    }\n};\nexport function getVariableCompletions(queryText, schema, forcePrefix = false) {\n    let variableName;\n    let variableType;\n    const definitions = Object.create({});\n    runOnlineParser(queryText, (_, state) => {\n        if (state.kind === RuleKinds.VARIABLE && state.name) {\n            variableName = state.name;\n        }\n        if (state.kind === RuleKinds.NAMED_TYPE && variableName) {\n            const parentDefinition = getParentDefinition(state, RuleKinds.TYPE);\n            if (parentDefinition === null || parentDefinition === void 0 ? void 0 : parentDefinition.type) {\n                variableType = schema.getType(parentDefinition === null || parentDefinition === void 0 ? void 0 : parentDefinition.type);\n            }\n        }\n        if (variableName && variableType) {\n            if (!definitions[variableName]) {\n                definitions[variableName] = {\n                    detail: variableType.toString(),\n                    label: `$${variableName}`,\n                    type: variableType,\n                    kind: CompletionItemKind.Variable,\n                };\n                if (forcePrefix) {\n                    definitions[variableName].insertText = `$${variableName}`;\n                }\n                variableName = null;\n                variableType = null;\n            }\n        }\n    });\n    return objectValues(definitions);\n}\nexport function getFragmentDefinitions(queryText) {\n    const fragmentDefs = [];\n    runOnlineParser(queryText, (_, state) => {\n        if (state.kind === RuleKinds.FRAGMENT_DEFINITION &&\n            state.name &&\n            state.type) {\n            fragmentDefs.push({\n                kind: RuleKinds.FRAGMENT_DEFINITION,\n                name: {\n                    kind: Kind.NAME,\n                    value: state.name,\n                },\n                selectionSet: {\n                    kind: RuleKinds.SELECTION_SET,\n                    selections: [],\n                },\n                typeCondition: {\n                    kind: RuleKinds.NAMED_TYPE,\n                    name: {\n                        kind: Kind.NAME,\n                        value: state.type,\n                    },\n                },\n            });\n        }\n    });\n    return fragmentDefs;\n}\nfunction getSuggestionsForVariableDefinition(token, schema, _kind) {\n    const inputTypeMap = schema.getTypeMap();\n    const inputTypes = objectValues(inputTypeMap).filter(isInputType);\n    return hintList(token, inputTypes.map((type) => ({\n        label: type.name,\n        documentation: type.description,\n        kind: CompletionItemKind.Variable,\n    })));\n}\nfunction getSuggestionsForDirective(token, state, schema, _kind) {\n    if (state.prevState && state.prevState.kind) {\n        const directives = schema\n            .getDirectives()\n            .filter(directive => canUseDirective(state.prevState, directive));\n        return hintList(token, directives.map(directive => ({\n            label: directive.name,\n            documentation: directive.description || '',\n            kind: CompletionItemKind.Function,\n        })));\n    }\n    return [];\n}\nexport function getTokenAtPosition(queryText, cursor) {\n    let styleAtCursor = null;\n    let stateAtCursor = null;\n    let stringAtCursor = null;\n    const token = runOnlineParser(queryText, (stream, state, style, index) => {\n        if (index === cursor.line) {\n            if (stream.getCurrentPosition() >= cursor.character) {\n                styleAtCursor = style;\n                stateAtCursor = Object.assign({}, state);\n                stringAtCursor = stream.current();\n                return 'BREAK';\n            }\n        }\n    });\n    return {\n        start: token.start,\n        end: token.end,\n        string: stringAtCursor || token.string,\n        state: stateAtCursor || token.state,\n        style: styleAtCursor || token.style,\n    };\n}\nexport function runOnlineParser(queryText, callback) {\n    const lines = queryText.split('\\n');\n    const parser = onlineParser();\n    let state = parser.startState();\n    let style = '';\n    let stream = new CharacterStream('');\n    for (let i = 0; i < lines.length; i++) {\n        stream = new CharacterStream(lines[i]);\n        while (!stream.eol()) {\n            style = parser.token(stream, state);\n            const code = callback(stream, state, style, i);\n            if (code === 'BREAK') {\n                break;\n            }\n        }\n        callback(stream, state, style, i);\n        if (!state.kind) {\n            state = parser.startState();\n        }\n    }\n    return {\n        start: stream.getStartOfToken(),\n        end: stream.getCurrentPosition(),\n        string: stream.current(),\n        state,\n        style,\n    };\n}\nexport function canUseDirective(state, directive) {\n    if (!state || !state.kind) {\n        return false;\n    }\n    const kind = state.kind;\n    const locations = directive.locations;\n    switch (kind) {\n        case RuleKinds.QUERY:\n            return locations.indexOf(DirectiveLocation.QUERY) !== -1;\n        case RuleKinds.MUTATION:\n            return locations.indexOf(DirectiveLocation.MUTATION) !== -1;\n        case RuleKinds.SUBSCRIPTION:\n            return locations.indexOf(DirectiveLocation.SUBSCRIPTION) !== -1;\n        case RuleKinds.FIELD:\n        case RuleKinds.ALIASED_FIELD:\n            return locations.indexOf(DirectiveLocation.FIELD) !== -1;\n        case RuleKinds.FRAGMENT_DEFINITION:\n            return locations.indexOf(DirectiveLocation.FRAGMENT_DEFINITION) !== -1;\n        case RuleKinds.FRAGMENT_SPREAD:\n            return locations.indexOf(DirectiveLocation.FRAGMENT_SPREAD) !== -1;\n        case RuleKinds.INLINE_FRAGMENT:\n            return locations.indexOf(DirectiveLocation.INLINE_FRAGMENT) !== -1;\n        case RuleKinds.SCHEMA_DEF:\n            return locations.indexOf(DirectiveLocation.SCHEMA) !== -1;\n        case RuleKinds.SCALAR_DEF:\n            return locations.indexOf(DirectiveLocation.SCALAR) !== -1;\n        case RuleKinds.OBJECT_TYPE_DEF:\n            return locations.indexOf(DirectiveLocation.OBJECT) !== -1;\n        case RuleKinds.FIELD_DEF:\n            return locations.indexOf(DirectiveLocation.FIELD_DEFINITION) !== -1;\n        case RuleKinds.INTERFACE_DEF:\n            return locations.indexOf(DirectiveLocation.INTERFACE) !== -1;\n        case RuleKinds.UNION_DEF:\n            return locations.indexOf(DirectiveLocation.UNION) !== -1;\n        case RuleKinds.ENUM_DEF:\n            return locations.indexOf(DirectiveLocation.ENUM) !== -1;\n        case RuleKinds.ENUM_VALUE:\n            return locations.indexOf(DirectiveLocation.ENUM_VALUE) !== -1;\n        case RuleKinds.INPUT_DEF:\n            return locations.indexOf(DirectiveLocation.INPUT_OBJECT) !== -1;\n        case RuleKinds.INPUT_VALUE_DEF:\n            const prevStateKind = state.prevState && state.prevState.kind;\n            switch (prevStateKind) {\n                case RuleKinds.ARGUMENTS_DEF:\n                    return (locations.indexOf(DirectiveLocation.ARGUMENT_DEFINITION) !== -1);\n                case RuleKinds.INPUT_DEF:\n                    return (locations.indexOf(DirectiveLocation.INPUT_FIELD_DEFINITION) !== -1);\n            }\n    }\n    return false;\n}\nexport function getTypeInfo(schema, tokenState) {\n    let argDef;\n    let argDefs;\n    let directiveDef;\n    let enumValue;\n    let fieldDef;\n    let inputType;\n    let objectTypeDef;\n    let objectFieldDefs;\n    let parentType;\n    let type;\n    let interfaceDef;\n    forEachState(tokenState, state => {\n        switch (state.kind) {\n            case RuleKinds.QUERY:\n            case 'ShortQuery':\n                type = schema.getQueryType();\n                break;\n            case RuleKinds.MUTATION:\n                type = schema.getMutationType();\n                break;\n            case RuleKinds.SUBSCRIPTION:\n                type = schema.getSubscriptionType();\n                break;\n            case RuleKinds.INLINE_FRAGMENT:\n            case RuleKinds.FRAGMENT_DEFINITION:\n                if (state.type) {\n                    type = schema.getType(state.type);\n                }\n                break;\n            case RuleKinds.FIELD:\n            case RuleKinds.ALIASED_FIELD: {\n                if (!type || !state.name) {\n                    fieldDef = null;\n                }\n                else {\n                    fieldDef = parentType\n                        ? getFieldDef(schema, parentType, state.name)\n                        : null;\n                    type = fieldDef ? fieldDef.type : null;\n                }\n                break;\n            }\n            case RuleKinds.SELECTION_SET:\n                parentType = getNamedType(type);\n                break;\n            case RuleKinds.DIRECTIVE:\n                directiveDef = state.name ? schema.getDirective(state.name) : null;\n                break;\n            case RuleKinds.INTERFACE_DEF:\n                if (state.name) {\n                    objectTypeDef = null;\n                    interfaceDef = new GraphQLInterfaceType({\n                        name: state.name,\n                        interfaces: [],\n                        fields: {},\n                    });\n                }\n                break;\n            case RuleKinds.OBJECT_TYPE_DEF:\n                if (state.name) {\n                    interfaceDef = null;\n                    objectTypeDef = new GraphQLObjectType({\n                        name: state.name,\n                        interfaces: [],\n                        fields: {},\n                    });\n                }\n                break;\n            case RuleKinds.ARGUMENTS: {\n                if (!state.prevState) {\n                    argDefs = null;\n                }\n                else {\n                    switch (state.prevState.kind) {\n                        case RuleKinds.FIELD:\n                            argDefs = fieldDef && fieldDef.args;\n                            break;\n                        case RuleKinds.DIRECTIVE:\n                            argDefs =\n                                directiveDef && directiveDef.args;\n                            break;\n                        case RuleKinds.ALIASED_FIELD: {\n                            const name = state.prevState && state.prevState.name;\n                            if (!name) {\n                                argDefs = null;\n                                break;\n                            }\n                            const field = parentType\n                                ? getFieldDef(schema, parentType, name)\n                                : null;\n                            if (!field) {\n                                argDefs = null;\n                                break;\n                            }\n                            argDefs = field.args;\n                            break;\n                        }\n                        default:\n                            argDefs = null;\n                            break;\n                    }\n                }\n                break;\n            }\n            case RuleKinds.ARGUMENT:\n                if (argDefs) {\n                    for (let i = 0; i < argDefs.length; i++) {\n                        if (argDefs[i].name === state.name) {\n                            argDef = argDefs[i];\n                            break;\n                        }\n                    }\n                }\n                inputType = argDef && argDef.type;\n                break;\n            case RuleKinds.ENUM_VALUE:\n                const enumType = getNamedType(inputType);\n                enumValue =\n                    enumType instanceof GraphQLEnumType\n                        ? find(enumType.getValues(), (val) => val.value === state.name)\n                        : null;\n                break;\n            case RuleKinds.LIST_VALUE:\n                const nullableType = getNullableType(inputType);\n                inputType =\n                    nullableType instanceof GraphQLList ? nullableType.ofType : null;\n                break;\n            case RuleKinds.OBJECT_VALUE:\n                const objectType = getNamedType(inputType);\n                objectFieldDefs =\n                    objectType instanceof GraphQLInputObjectType\n                        ? objectType.getFields()\n                        : null;\n                break;\n            case RuleKinds.OBJECT_FIELD:\n                const objectField = state.name && objectFieldDefs ? objectFieldDefs[state.name] : null;\n                inputType = objectField && objectField.type;\n                break;\n            case RuleKinds.NAMED_TYPE:\n                if (state.name) {\n                    type = schema.getType(state.name);\n                }\n                break;\n        }\n    });\n    return {\n        argDef,\n        argDefs,\n        directiveDef,\n        enumValue,\n        fieldDef,\n        inputType,\n        objectFieldDefs,\n        parentType,\n        type,\n        interfaceDef,\n        objectTypeDef,\n    };\n}\nfunction find(array, predicate) {\n    for (let i = 0; i < array.length; i++) {\n        if (predicate(array[i])) {\n            return array[i];\n        }\n    }\n    return null;\n}\n//# sourceMappingURL=getAutocompleteSuggestions.js.map"]},"metadata":{},"sourceType":"module"}