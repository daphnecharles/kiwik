{"ast":null,"code":"// fences (``` lang, ~~~ lang)\n'use strict';\n\nmodule.exports = function fence(state, startLine, endLine, silent) {\n  var marker,\n      len,\n      params,\n      nextLine,\n      mem,\n      token,\n      markup,\n      haveEndMarker = false,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine]; // if it's indented more than 3 spaces, it should be a code block\n\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false;\n  }\n\n  if (pos + 3 > max) {\n    return false;\n  }\n\n  marker = state.src.charCodeAt(pos);\n\n  if (marker !== 0x7E\n  /* ~ */\n  && marker !== 0x60\n  /* ` */\n  ) {\n    return false;\n  } // scan marker length\n\n\n  mem = pos;\n  pos = state.skipChars(pos, marker);\n  len = pos - mem;\n\n  if (len < 3) {\n    return false;\n  }\n\n  markup = state.src.slice(mem, pos);\n  params = state.src.slice(pos, max);\n\n  if (marker === 0x60\n  /* ` */\n  ) {\n    if (params.indexOf(String.fromCharCode(marker)) >= 0) {\n      return false;\n    }\n  } // Since start is found, we can report success here in validation mode\n\n\n  if (silent) {\n    return true;\n  } // search end of block\n\n\n  nextLine = startLine;\n\n  for (;;) {\n    nextLine++;\n\n    if (nextLine >= endLine) {\n      // unclosed block should be autoclosed by end of document.\n      // also block seems to be autoclosed by end of parent\n      break;\n    }\n\n    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];\n    max = state.eMarks[nextLine];\n\n    if (pos < max && state.sCount[nextLine] < state.blkIndent) {\n      // non-empty line with negative indent should stop the list:\n      // - ```\n      //  test\n      break;\n    }\n\n    if (state.src.charCodeAt(pos) !== marker) {\n      continue;\n    }\n\n    if (state.sCount[nextLine] - state.blkIndent >= 4) {\n      // closing fence should be indented less than 4 spaces\n      continue;\n    }\n\n    pos = state.skipChars(pos, marker); // closing code fence must be at least as long as the opening one\n\n    if (pos - mem < len) {\n      continue;\n    } // make sure tail has spaces only\n\n\n    pos = state.skipSpaces(pos);\n\n    if (pos < max) {\n      continue;\n    }\n\n    haveEndMarker = true; // found!\n\n    break;\n  } // If a fence has heading spaces, they should be removed from its inner block\n\n\n  len = state.sCount[startLine];\n  state.line = nextLine + (haveEndMarker ? 1 : 0);\n  token = state.push('fence', 'code', 0);\n  token.info = params;\n  token.content = state.getLines(startLine + 1, nextLine, len, true);\n  token.markup = markup;\n  token.map = [startLine, state.line];\n  return true;\n};","map":{"version":3,"sources":["/Users/sam/Desktop/kiwik/node_modules/markdown-it/lib/rules_block/fence.js"],"names":["module","exports","fence","state","startLine","endLine","silent","marker","len","params","nextLine","mem","token","markup","haveEndMarker","pos","bMarks","tShift","max","eMarks","sCount","blkIndent","src","charCodeAt","skipChars","slice","indexOf","String","fromCharCode","skipSpaces","line","push","info","content","getLines","map"],"mappings":"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","sourcesContent":["// fences (``` lang, ~~~ lang)\n\n'use strict';\n\n\nmodule.exports = function fence(state, startLine, endLine, silent) {\n  var marker, len, params, nextLine, mem, token, markup,\n      haveEndMarker = false,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  if (pos + 3 > max) { return false; }\n\n  marker = state.src.charCodeAt(pos);\n\n  if (marker !== 0x7E/* ~ */ && marker !== 0x60 /* ` */) {\n    return false;\n  }\n\n  // scan marker length\n  mem = pos;\n  pos = state.skipChars(pos, marker);\n\n  len = pos - mem;\n\n  if (len < 3) { return false; }\n\n  markup = state.src.slice(mem, pos);\n  params = state.src.slice(pos, max);\n\n  if (marker === 0x60 /* ` */) {\n    if (params.indexOf(String.fromCharCode(marker)) >= 0) {\n      return false;\n    }\n  }\n\n  // Since start is found, we can report success here in validation mode\n  if (silent) { return true; }\n\n  // search end of block\n  nextLine = startLine;\n\n  for (;;) {\n    nextLine++;\n    if (nextLine >= endLine) {\n      // unclosed block should be autoclosed by end of document.\n      // also block seems to be autoclosed by end of parent\n      break;\n    }\n\n    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];\n    max = state.eMarks[nextLine];\n\n    if (pos < max && state.sCount[nextLine] < state.blkIndent) {\n      // non-empty line with negative indent should stop the list:\n      // - ```\n      //  test\n      break;\n    }\n\n    if (state.src.charCodeAt(pos) !== marker) { continue; }\n\n    if (state.sCount[nextLine] - state.blkIndent >= 4) {\n      // closing fence should be indented less than 4 spaces\n      continue;\n    }\n\n    pos = state.skipChars(pos, marker);\n\n    // closing code fence must be at least as long as the opening one\n    if (pos - mem < len) { continue; }\n\n    // make sure tail has spaces only\n    pos = state.skipSpaces(pos);\n\n    if (pos < max) { continue; }\n\n    haveEndMarker = true;\n    // found!\n    break;\n  }\n\n  // If a fence has heading spaces, they should be removed from its inner block\n  len = state.sCount[startLine];\n\n  state.line = nextLine + (haveEndMarker ? 1 : 0);\n\n  token         = state.push('fence', 'code', 0);\n  token.info    = params;\n  token.content = state.getLines(startLine + 1, nextLine, len, true);\n  token.markup  = markup;\n  token.map     = [ startLine, state.line ];\n\n  return true;\n};\n"]},"metadata":{},"sourceType":"script"}