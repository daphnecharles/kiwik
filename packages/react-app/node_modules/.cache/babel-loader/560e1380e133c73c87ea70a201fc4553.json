{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spread = this && this.__spread || function () {\n  for (var ar = [], i = 0; i < arguments.length; i++) {\n    ar = ar.concat(__read(arguments[i]));\n  }\n\n  return ar;\n};\n\nimport { TypeInfo, getNamedType, visit, visitWithTypeInfo } from 'graphql';\nexport function uniqueBy(array, iteratee) {\n  var e_1, _a;\n\n  var FilteredMap = new Map();\n  var result = [];\n\n  try {\n    for (var array_1 = __values(array), array_1_1 = array_1.next(); !array_1_1.done; array_1_1 = array_1.next()) {\n      var item = array_1_1.value;\n\n      if (item.kind === 'Field') {\n        var uniqueValue = iteratee(item);\n        var existing = FilteredMap.get(uniqueValue);\n\n        if (item.directives && item.directives.length) {\n          var itemClone = __assign({}, item);\n\n          result.push(itemClone);\n        } else if (existing && existing.selectionSet && item.selectionSet) {\n          existing.selectionSet.selections = __spread(existing.selectionSet.selections, item.selectionSet.selections);\n        } else if (!existing) {\n          var itemClone = __assign({}, item);\n\n          FilteredMap.set(uniqueValue, itemClone);\n          result.push(itemClone);\n        }\n      } else {\n        result.push(item);\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (array_1_1 && !array_1_1.done && (_a = array_1.return)) _a.call(array_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  return result;\n}\nexport function inlineRelevantFragmentSpreads(fragmentDefinitions, selections, selectionSetType) {\n  var e_2, _a;\n\n  var _b;\n\n  var selectionSetTypeName = selectionSetType ? getNamedType(selectionSetType).name : null;\n  var outputSelections = [];\n  var seenSpreads = [];\n\n  try {\n    for (var selections_1 = __values(selections), selections_1_1 = selections_1.next(); !selections_1_1.done; selections_1_1 = selections_1.next()) {\n      var selection = selections_1_1.value;\n\n      if (selection.kind === 'FragmentSpread') {\n        var fragmentName = selection.name.value;\n\n        if (!selection.directives || selection.directives.length === 0) {\n          if (seenSpreads.indexOf(fragmentName) >= 0) {\n            continue;\n          } else {\n            seenSpreads.push(fragmentName);\n          }\n        }\n\n        var fragmentDefinition = fragmentDefinitions[selection.name.value];\n\n        if (fragmentDefinition) {\n          var typeCondition = fragmentDefinition.typeCondition,\n              directives = fragmentDefinition.directives,\n              selectionSet = fragmentDefinition.selectionSet;\n          selection = {\n            kind: 'InlineFragment',\n            typeCondition: typeCondition,\n            directives: directives,\n            selectionSet: selectionSet\n          };\n        }\n      }\n\n      if (selection.kind === 'InlineFragment' && (!selection.directives || ((_b = selection.directives) === null || _b === void 0 ? void 0 : _b.length) === 0)) {\n        var fragmentTypeName = selection.typeCondition ? selection.typeCondition.name.value : null;\n\n        if (!fragmentTypeName || fragmentTypeName === selectionSetTypeName) {\n          outputSelections.push.apply(outputSelections, __spread(inlineRelevantFragmentSpreads(fragmentDefinitions, selection.selectionSet.selections, selectionSetType)));\n          continue;\n        }\n      }\n\n      outputSelections.push(selection);\n    }\n  } catch (e_2_1) {\n    e_2 = {\n      error: e_2_1\n    };\n  } finally {\n    try {\n      if (selections_1_1 && !selections_1_1.done && (_a = selections_1.return)) _a.call(selections_1);\n    } finally {\n      if (e_2) throw e_2.error;\n    }\n  }\n\n  return outputSelections;\n}\nexport default function mergeAST(documentAST, schema) {\n  var e_3, _a;\n\n  var typeInfo = schema ? new TypeInfo(schema) : null;\n  var fragmentDefinitions = Object.create(null);\n\n  try {\n    for (var _b = __values(documentAST.definitions), _c = _b.next(); !_c.done; _c = _b.next()) {\n      var definition = _c.value;\n\n      if (definition.kind === 'FragmentDefinition') {\n        fragmentDefinitions[definition.name.value] = definition;\n      }\n    }\n  } catch (e_3_1) {\n    e_3 = {\n      error: e_3_1\n    };\n  } finally {\n    try {\n      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n    } finally {\n      if (e_3) throw e_3.error;\n    }\n  }\n\n  var visitors = {\n    SelectionSet: function SelectionSet(node) {\n      var selectionSetType = typeInfo ? typeInfo.getParentType() : null;\n      var selections = node.selections;\n      selections = inlineRelevantFragmentSpreads(fragmentDefinitions, selections, selectionSetType);\n      selections = uniqueBy(selections, function (selection) {\n        return selection.alias ? selection.alias.value : selection.name.value;\n      });\n      return __assign(__assign({}, node), {\n        selections: selections\n      });\n    },\n    FragmentDefinition: function FragmentDefinition() {\n      return null;\n    }\n  };\n  return visit(documentAST, typeInfo ? visitWithTypeInfo(typeInfo, visitors) : visitors);\n}","map":{"version":3,"sources":["../../src/utility/mergeAst.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spread = (this && this.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\nimport { TypeInfo, getNamedType, visit, visitWithTypeInfo, } from 'graphql';\nexport function uniqueBy(array, iteratee) {\n    var e_1, _a;\n    var FilteredMap = new Map();\n    var result = [];\n    try {\n        for (var array_1 = __values(array), array_1_1 = array_1.next(); !array_1_1.done; array_1_1 = array_1.next()) {\n            var item = array_1_1.value;\n            if (item.kind === 'Field') {\n                var uniqueValue = iteratee(item);\n                var existing = FilteredMap.get(uniqueValue);\n                if (item.directives && item.directives.length) {\n                    var itemClone = __assign({}, item);\n                    result.push(itemClone);\n                }\n                else if (existing && existing.selectionSet && item.selectionSet) {\n                    existing.selectionSet.selections = __spread(existing.selectionSet.selections, item.selectionSet.selections);\n                }\n                else if (!existing) {\n                    var itemClone = __assign({}, item);\n                    FilteredMap.set(uniqueValue, itemClone);\n                    result.push(itemClone);\n                }\n            }\n            else {\n                result.push(item);\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (array_1_1 && !array_1_1.done && (_a = array_1.return)) _a.call(array_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return result;\n}\nexport function inlineRelevantFragmentSpreads(fragmentDefinitions, selections, selectionSetType) {\n    var e_2, _a;\n    var _b;\n    var selectionSetTypeName = selectionSetType\n        ? getNamedType(selectionSetType).name\n        : null;\n    var outputSelections = [];\n    var seenSpreads = [];\n    try {\n        for (var selections_1 = __values(selections), selections_1_1 = selections_1.next(); !selections_1_1.done; selections_1_1 = selections_1.next()) {\n            var selection = selections_1_1.value;\n            if (selection.kind === 'FragmentSpread') {\n                var fragmentName = selection.name.value;\n                if (!selection.directives || selection.directives.length === 0) {\n                    if (seenSpreads.indexOf(fragmentName) >= 0) {\n                        continue;\n                    }\n                    else {\n                        seenSpreads.push(fragmentName);\n                    }\n                }\n                var fragmentDefinition = fragmentDefinitions[selection.name.value];\n                if (fragmentDefinition) {\n                    var typeCondition = fragmentDefinition.typeCondition, directives = fragmentDefinition.directives, selectionSet = fragmentDefinition.selectionSet;\n                    selection = {\n                        kind: 'InlineFragment',\n                        typeCondition: typeCondition,\n                        directives: directives,\n                        selectionSet: selectionSet,\n                    };\n                }\n            }\n            if (selection.kind === 'InlineFragment' &&\n                (!selection.directives || ((_b = selection.directives) === null || _b === void 0 ? void 0 : _b.length) === 0)) {\n                var fragmentTypeName = selection.typeCondition\n                    ? selection.typeCondition.name.value\n                    : null;\n                if (!fragmentTypeName || fragmentTypeName === selectionSetTypeName) {\n                    outputSelections.push.apply(outputSelections, __spread(inlineRelevantFragmentSpreads(fragmentDefinitions, selection.selectionSet.selections, selectionSetType)));\n                    continue;\n                }\n            }\n            outputSelections.push(selection);\n        }\n    }\n    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n    finally {\n        try {\n            if (selections_1_1 && !selections_1_1.done && (_a = selections_1.return)) _a.call(selections_1);\n        }\n        finally { if (e_2) throw e_2.error; }\n    }\n    return outputSelections;\n}\nexport default function mergeAST(documentAST, schema) {\n    var e_3, _a;\n    var typeInfo = schema ? new TypeInfo(schema) : null;\n    var fragmentDefinitions = Object.create(null);\n    try {\n        for (var _b = __values(documentAST.definitions), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var definition = _c.value;\n            if (definition.kind === 'FragmentDefinition') {\n                fragmentDefinitions[definition.name.value] = definition;\n            }\n        }\n    }\n    catch (e_3_1) { e_3 = { error: e_3_1 }; }\n    finally {\n        try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        }\n        finally { if (e_3) throw e_3.error; }\n    }\n    var visitors = {\n        SelectionSet: function (node) {\n            var selectionSetType = typeInfo ? typeInfo.getParentType() : null;\n            var selections = node.selections;\n            selections = inlineRelevantFragmentSpreads(fragmentDefinitions, selections, selectionSetType);\n            selections = uniqueBy(selections, function (selection) {\n                return selection.alias ? selection.alias.value : selection.name.value;\n            });\n            return __assign(__assign({}, node), { selections: selections });\n        },\n        FragmentDefinition: function () {\n            return null;\n        },\n    };\n    return visit(documentAST, typeInfo ? visitWithTypeInfo(typeInfo, visitors) : visitors);\n}\n//# sourceMappingURL=mergeAst.js.map"]},"metadata":{},"sourceType":"module"}