{"ast":null,"code":"var _regeneratorRuntime = require(\"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\n/**\n * JsonRpcEngine only accepts callback-based middleware directly.\n * createAsyncMiddleware exists to enable consumers to pass in async middleware\n * functions.\n *\n * Async middleware have no \"end\" function. Instead, they \"end\" if they return\n * without calling \"next\". Rather than passing in explicit return handlers,\n * async middleware can simply await \"next\", and perform operations on the\n * response object when execution resumes.\n *\n * To accomplish this, createAsyncMiddleware passes the async middleware a\n * wrapped \"next\" function. That function calls the internal JsonRpcEngine\n * \"next\" function with a return handler that resolves a promise when called.\n *\n * The return handler will always be called. Its resolution of the promise\n * enables the control flow described above.\n */\nmodule.exports = function createAsyncMiddleware(asyncMiddleware) {\n  return function (req, res, next, end) {\n    // nextPromise is the key to the implementation\n    // it is resolved by the return handler passed to the\n    // \"next\" function\n    var resolveNextPromise;\n    var nextPromise = new Promise(function (resolve) {\n      resolveNextPromise = resolve;\n    });\n    var returnHandlerCallback, nextWasCalled;\n\n    var asyncNext = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                nextWasCalled = true;\n                next(function (callback) {\n                  // eslint-disable-line callback-return\n                  returnHandlerCallback = callback;\n                  resolveNextPromise();\n                });\n                _context.next = 4;\n                return nextPromise;\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function asyncNext() {\n        return _ref.apply(this, arguments);\n      };\n    }();\n\n    asyncMiddleware(req, res, asyncNext).then( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!nextWasCalled) {\n                _context2.next = 6;\n                break;\n              }\n\n              _context2.next = 3;\n              return nextPromise;\n\n            case 3:\n              // we must wait until the return handler is called\n              returnHandlerCallback(null);\n              _context2.next = 7;\n              break;\n\n            case 6:\n              end(null);\n\n            case 7:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }))).catch(function (error) {\n      if (returnHandlerCallback) {\n        returnHandlerCallback(error);\n      } else {\n        end(error);\n      }\n    });\n  };\n};","map":{"version":3,"sources":["/Users/sam/Desktop/kiwik/node_modules/json-rpc-engine/src/createAsyncMiddleware.js"],"names":["module","exports","createAsyncMiddleware","asyncMiddleware","req","res","next","end","resolveNextPromise","nextPromise","Promise","resolve","returnHandlerCallback","nextWasCalled","asyncNext","callback","then","catch","error"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEAA,MAAM,CAACC,OAAP,GAAiB,SAASC,qBAAT,CAAgCC,eAAhC,EAAiD;AAChE,SAAO,UAACC,GAAD,EAAMC,GAAN,EAAWC,IAAX,EAAiBC,GAAjB,EAAyB;AAE9B;AACA;AACA;AACA,QAAIC,kBAAJ;AACA,QAAMC,WAAW,GAAG,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAa;AAC3CH,MAAAA,kBAAkB,GAAGG,OAArB;AACD,KAFmB,CAApB;AAIA,QAAIC,qBAAJ,EAA2BC,aAA3B;;AAEA,QAAMC,SAAS;AAAA,0EAAG;AAAA;AAAA;AAAA;AAAA;AAEhBD,gBAAAA,aAAa,GAAG,IAAhB;AAEAP,gBAAAA,IAAI,CAAC,UAACS,QAAD,EAAc;AAAE;AACnBH,kBAAAA,qBAAqB,GAAGG,QAAxB;AACAP,kBAAAA,kBAAkB;AACnB,iBAHG,CAAJ;AAJgB;AAAA,uBAQVC,WARU;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAH;;AAAA,sBAATK,SAAS;AAAA;AAAA;AAAA,OAAf;;AAWAX,IAAAA,eAAe,CAACC,GAAD,EAAMC,GAAN,EAAWS,SAAX,CAAf,CACGE,IADH,wEACQ;AAAA;AAAA;AAAA;AAAA;AAAA,mBACAH,aADA;AAAA;AAAA;AAAA;;AAAA;AAAA,qBAEIJ,WAFJ;;AAAA;AAEgB;AAClBG,cAAAA,qBAAqB,CAAC,IAAD,CAArB;AAHE;AAAA;;AAAA;AAKFL,cAAAA,GAAG,CAAC,IAAD,CAAH;;AALE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KADR,IASGU,KATH,CASS,UAACC,KAAD,EAAW;AAChB,UAAIN,qBAAJ,EAA2B;AACzBA,QAAAA,qBAAqB,CAACM,KAAD,CAArB;AACD,OAFD,MAEO;AACLX,QAAAA,GAAG,CAACW,KAAD,CAAH;AACD;AACF,KAfH;AAgBD,GAvCD;AAwCD,CAzCD","sourcesContent":["/**\n * JsonRpcEngine only accepts callback-based middleware directly.\n * createAsyncMiddleware exists to enable consumers to pass in async middleware\n * functions.\n *\n * Async middleware have no \"end\" function. Instead, they \"end\" if they return\n * without calling \"next\". Rather than passing in explicit return handlers,\n * async middleware can simply await \"next\", and perform operations on the\n * response object when execution resumes.\n *\n * To accomplish this, createAsyncMiddleware passes the async middleware a\n * wrapped \"next\" function. That function calls the internal JsonRpcEngine\n * \"next\" function with a return handler that resolves a promise when called.\n *\n * The return handler will always be called. Its resolution of the promise\n * enables the control flow described above.\n */\n\nmodule.exports = function createAsyncMiddleware (asyncMiddleware) {\n  return (req, res, next, end) => {\n\n    // nextPromise is the key to the implementation\n    // it is resolved by the return handler passed to the\n    // \"next\" function\n    let resolveNextPromise\n    const nextPromise = new Promise((resolve) => {\n      resolveNextPromise = resolve\n    })\n\n    let returnHandlerCallback, nextWasCalled\n\n    const asyncNext = async () => {\n\n      nextWasCalled = true\n\n      next((callback) => { // eslint-disable-line callback-return\n        returnHandlerCallback = callback\n        resolveNextPromise()\n      })\n      await nextPromise\n    }\n\n    asyncMiddleware(req, res, asyncNext)\n      .then(async () => {\n        if (nextWasCalled) {\n          await nextPromise // we must wait until the return handler is called\n          returnHandlerCallback(null)\n        } else {\n          end(null)\n        }\n      })\n      .catch((error) => {\n        if (returnHandlerCallback) {\n          returnHandlerCallback(error)\n        } else {\n          end(error)\n        }\n      })\n  }\n}\n"]},"metadata":{},"sourceType":"script"}