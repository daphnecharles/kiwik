{"ast":null,"code":"import { parse, visit } from 'graphql';\nimport nullthrows from 'nullthrows';\nexport var getFragmentDependencies = function getFragmentDependencies(operationString, fragmentDefinitions) {\n  if (!fragmentDefinitions) {\n    return [];\n  }\n\n  var parsedOperation;\n\n  try {\n    parsedOperation = parse(operationString);\n  } catch (error) {\n    return [];\n  }\n\n  return getFragmentDependenciesForAST(parsedOperation, fragmentDefinitions);\n};\nexport var getFragmentDependenciesForAST = function getFragmentDependenciesForAST(parsedOperation, fragmentDefinitions) {\n  if (!fragmentDefinitions) {\n    return [];\n  }\n\n  var existingFrags = new Map();\n  var referencedFragNames = new Set();\n  visit(parsedOperation, {\n    FragmentDefinition: function FragmentDefinition(node) {\n      existingFrags.set(node.name.value, true);\n    },\n    FragmentSpread: function FragmentSpread(node) {\n      if (!referencedFragNames.has(node.name.value)) {\n        referencedFragNames.add(node.name.value);\n      }\n    }\n  });\n  var asts = new Set();\n  referencedFragNames.forEach(function (name) {\n    if (!existingFrags.has(name) && fragmentDefinitions.has(name)) {\n      asts.add(nullthrows(fragmentDefinitions.get(name)));\n    }\n  });\n  var referencedFragments = [];\n  asts.forEach(function (ast) {\n    visit(ast, {\n      FragmentSpread: function FragmentSpread(node) {\n        if (!referencedFragNames.has(node.name.value) && fragmentDefinitions.get(node.name.value)) {\n          asts.add(nullthrows(fragmentDefinitions.get(node.name.value)));\n          referencedFragNames.add(node.name.value);\n        }\n      }\n    });\n\n    if (!existingFrags.has(ast.name.value)) {\n      referencedFragments.push(ast);\n    }\n  });\n  return referencedFragments;\n};","map":{"version":3,"sources":["../src/fragmentDependencies.ts"],"names":[],"mappings":"AAAA,SAA+C,KAA/C,EAAsD,KAAtD,QAAmE,SAAnE;AACA,OAAO,UAAP,MAAuB,YAAvB;AAEA,OAAO,IAAM,uBAAuB,GAAG,SAA1B,uBAA0B,CACrC,eADqC,EAErC,mBAFqC,EAGT;AAG5B,MAAI,CAAC,mBAAL,EAA0B;AACxB,WAAO,EAAP;AACD;;AAGD,MAAI,eAAJ;;AACA,MAAI;AACF,IAAA,eAAe,GAAG,KAAK,CAAC,eAAD,CAAvB;AACD,GAFD,CAEE,OAAO,KAAP,EAAc;AACd,WAAO,EAAP;AACD;;AACD,SAAO,6BAA6B,CAAC,eAAD,EAAkB,mBAAlB,CAApC;AACD,CAlBM;AAoBP,OAAO,IAAM,6BAA6B,GAAG,SAAhC,6BAAgC,CAC3C,eAD2C,EAE3C,mBAF2C,EAGf;AAC5B,MAAI,CAAC,mBAAL,EAA0B;AACxB,WAAO,EAAP;AACD;;AAED,MAAM,aAAa,GAAG,IAAI,GAAJ,EAAtB;AACA,MAAM,mBAAmB,GAAG,IAAI,GAAJ,EAA5B;AAEA,EAAA,KAAK,CAAC,eAAD,EAAkB;AACrB,IAAA,kBADqB,8BACF,IADE,EACE;AACrB,MAAA,aAAa,CAAC,GAAd,CAAkB,IAAI,CAAC,IAAL,CAAU,KAA5B,EAAmC,IAAnC;AACD,KAHoB;AAIrB,IAAA,cAJqB,0BAIN,IAJM,EAIF;AACjB,UAAI,CAAC,mBAAmB,CAAC,GAApB,CAAwB,IAAI,CAAC,IAAL,CAAU,KAAlC,CAAL,EAA+C;AAC7C,QAAA,mBAAmB,CAAC,GAApB,CAAwB,IAAI,CAAC,IAAL,CAAU,KAAlC;AACD;AACF;AARoB,GAAlB,CAAL;AAWA,MAAM,IAAI,GAAG,IAAI,GAAJ,EAAb;AACA,EAAA,mBAAmB,CAAC,OAApB,CAA4B,UAAA,IAAI,EAAG;AACjC,QAAI,CAAC,aAAa,CAAC,GAAd,CAAkB,IAAlB,CAAD,IAA4B,mBAAmB,CAAC,GAApB,CAAwB,IAAxB,CAAhC,EAA+D;AAC7D,MAAA,IAAI,CAAC,GAAL,CAAS,UAAU,CAAC,mBAAmB,CAAC,GAApB,CAAwB,IAAxB,CAAD,CAAnB;AACD;AACF,GAJD;AAMA,MAAM,mBAAmB,GAA6B,EAAtD;AAEA,EAAA,IAAI,CAAC,OAAL,CAAa,UAAA,GAAG,EAAG;AACjB,IAAA,KAAK,CAAC,GAAD,EAAM;AACT,MAAA,cADS,0BACM,IADN,EACU;AACjB,YACE,CAAC,mBAAmB,CAAC,GAApB,CAAwB,IAAI,CAAC,IAAL,CAAU,KAAlC,CAAD,IACA,mBAAmB,CAAC,GAApB,CAAwB,IAAI,CAAC,IAAL,CAAU,KAAlC,CAFF,EAGE;AACA,UAAA,IAAI,CAAC,GAAL,CAAS,UAAU,CAAC,mBAAmB,CAAC,GAApB,CAAwB,IAAI,CAAC,IAAL,CAAU,KAAlC,CAAD,CAAnB;AACA,UAAA,mBAAmB,CAAC,GAApB,CAAwB,IAAI,CAAC,IAAL,CAAU,KAAlC;AACD;AACF;AATQ,KAAN,CAAL;;AAWA,QAAI,CAAC,aAAa,CAAC,GAAd,CAAkB,GAAG,CAAC,IAAJ,CAAS,KAA3B,CAAL,EAAwC;AACtC,MAAA,mBAAmB,CAAC,IAApB,CAAyB,GAAzB;AACD;AACF,GAfD;AAiBA,SAAO,mBAAP;AACD,CAjDM","sourceRoot":"","sourcesContent":["import { parse, visit } from 'graphql';\nimport nullthrows from 'nullthrows';\nexport const getFragmentDependencies = (operationString, fragmentDefinitions) => {\n    if (!fragmentDefinitions) {\n        return [];\n    }\n    let parsedOperation;\n    try {\n        parsedOperation = parse(operationString);\n    }\n    catch (error) {\n        return [];\n    }\n    return getFragmentDependenciesForAST(parsedOperation, fragmentDefinitions);\n};\nexport const getFragmentDependenciesForAST = (parsedOperation, fragmentDefinitions) => {\n    if (!fragmentDefinitions) {\n        return [];\n    }\n    const existingFrags = new Map();\n    const referencedFragNames = new Set();\n    visit(parsedOperation, {\n        FragmentDefinition(node) {\n            existingFrags.set(node.name.value, true);\n        },\n        FragmentSpread(node) {\n            if (!referencedFragNames.has(node.name.value)) {\n                referencedFragNames.add(node.name.value);\n            }\n        },\n    });\n    const asts = new Set();\n    referencedFragNames.forEach(name => {\n        if (!existingFrags.has(name) && fragmentDefinitions.has(name)) {\n            asts.add(nullthrows(fragmentDefinitions.get(name)));\n        }\n    });\n    const referencedFragments = [];\n    asts.forEach(ast => {\n        visit(ast, {\n            FragmentSpread(node) {\n                if (!referencedFragNames.has(node.name.value) &&\n                    fragmentDefinitions.get(node.name.value)) {\n                    asts.add(nullthrows(fragmentDefinitions.get(node.name.value)));\n                    referencedFragNames.add(node.name.value);\n                }\n            },\n        });\n        if (!existingFrags.has(ast.name.value)) {\n            referencedFragments.push(ast);\n        }\n    });\n    return referencedFragments;\n};\n//# sourceMappingURL=fragmentDependencies.js.map"]},"metadata":{},"sourceType":"module"}