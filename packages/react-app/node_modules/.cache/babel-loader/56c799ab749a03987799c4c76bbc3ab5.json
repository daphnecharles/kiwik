{"ast":null,"code":"var randomHex = function randomHex(size, callback) {\n  var crypto = require('./crypto.js');\n\n  var isCallback = typeof callback === 'function';\n\n  if (size > 65536) {\n    if (isCallback) {\n      callback(new Error('Requested too many random bytes.'));\n    } else {\n      throw new Error('Requested too many random bytes.');\n    }\n  }\n\n  ; // is node\n\n  if (typeof crypto !== 'undefined' && crypto.randomBytes) {\n    if (isCallback) {\n      crypto.randomBytes(size, function (err, result) {\n        if (!err) {\n          callback(null, '0x' + result.toString('hex'));\n        } else {\n          callback(error);\n        }\n      });\n    } else {\n      return '0x' + crypto.randomBytes(size).toString('hex');\n    } // is browser\n\n  } else {\n    var cryptoLib;\n\n    if (typeof crypto !== 'undefined') {\n      cryptoLib = crypto;\n    } else if (typeof msCrypto !== 'undefined') {\n      cryptoLib = msCrypto;\n    }\n\n    if (cryptoLib && cryptoLib.getRandomValues) {\n      var randomBytes = cryptoLib.getRandomValues(new Uint8Array(size));\n      var returnValue = '0x' + Array.from(randomBytes).map(function (arr) {\n        return arr.toString(16);\n      }).join('');\n\n      if (isCallback) {\n        callback(null, returnValue);\n      } else {\n        return returnValue;\n      } // not crypto object\n\n    } else {\n      var error = new Error('No \"crypto\" object available. This Browser doesn\\'t support generating secure random bytes.');\n\n      if (isCallback) {\n        callback(error);\n      } else {\n        throw error;\n      }\n    }\n  }\n};\n\nmodule.exports = randomHex;","map":{"version":3,"sources":["/Users/sam/Desktop/kiwik/node_modules/randomhex/src/index.js"],"names":["randomHex","size","callback","crypto","require","isCallback","Error","randomBytes","err","result","toString","error","cryptoLib","msCrypto","getRandomValues","Uint8Array","returnValue","Array","from","map","arr","join","module","exports"],"mappings":"AAAA,IAAIA,SAAS,GAAG,SAAZA,SAAY,CAASC,IAAT,EAAeC,QAAf,EAAyB;AACrC,MAAIC,MAAM,GAAGC,OAAO,CAAC,aAAD,CAApB;;AACA,MAAIC,UAAU,GAAI,OAAOH,QAAP,KAAoB,UAAtC;;AAGA,MAAID,IAAI,GAAG,KAAX,EAAkB;AACd,QAAGI,UAAH,EAAe;AACXH,MAAAA,QAAQ,CAAC,IAAII,KAAJ,CAAU,kCAAV,CAAD,CAAR;AACH,KAFD,MAEO;AACH,YAAM,IAAIA,KAAJ,CAAU,kCAAV,CAAN;AACH;AACJ;;AAAA,GAXoC,CAcrC;;AACA,MAAI,OAAOH,MAAP,KAAkB,WAAlB,IAAiCA,MAAM,CAACI,WAA5C,EAAyD;AAErD,QAAGF,UAAH,EAAe;AACXF,MAAAA,MAAM,CAACI,WAAP,CAAmBN,IAAnB,EAAyB,UAASO,GAAT,EAAcC,MAAd,EAAqB;AAC1C,YAAG,CAACD,GAAJ,EAAS;AACLN,UAAAA,QAAQ,CAAC,IAAD,EAAO,OAAMO,MAAM,CAACC,QAAP,CAAgB,KAAhB,CAAb,CAAR;AACH,SAFD,MAEO;AACHR,UAAAA,QAAQ,CAACS,KAAD,CAAR;AACH;AACJ,OAND;AAOH,KARD,MAQO;AACH,aAAO,OAAMR,MAAM,CAACI,WAAP,CAAmBN,IAAnB,EAAyBS,QAAzB,CAAkC,KAAlC,CAAb;AACH,KAZoD,CAczD;;AACC,GAfD,MAeO;AACH,QAAIE,SAAJ;;AAEA,QAAI,OAAOT,MAAP,KAAkB,WAAtB,EAAmC;AAC/BS,MAAAA,SAAS,GAAGT,MAAZ;AACH,KAFD,MAEO,IAAG,OAAOU,QAAP,KAAoB,WAAvB,EAAoC;AACvCD,MAAAA,SAAS,GAAGC,QAAZ;AACH;;AAED,QAAID,SAAS,IAAIA,SAAS,CAACE,eAA3B,EAA4C;AACxC,UAAIP,WAAW,GAAGK,SAAS,CAACE,eAAV,CAA0B,IAAIC,UAAJ,CAAed,IAAf,CAA1B,CAAlB;AACA,UAAIe,WAAW,GAAG,OAAMC,KAAK,CAACC,IAAN,CAAWX,WAAX,EAAwBY,GAAxB,CAA4B,UAASC,GAAT,EAAa;AAAE,eAAOA,GAAG,CAACV,QAAJ,CAAa,EAAb,CAAP;AAA0B,OAArE,EAAuEW,IAAvE,CAA4E,EAA5E,CAAxB;;AAEA,UAAGhB,UAAH,EAAe;AACXH,QAAAA,QAAQ,CAAC,IAAD,EAAOc,WAAP,CAAR;AACH,OAFD,MAEO;AACH,eAAOA,WAAP;AACH,OARuC,CAU5C;;AACC,KAXD,MAWO;AACH,UAAIL,KAAK,GAAG,IAAIL,KAAJ,CAAU,6FAAV,CAAZ;;AAEA,UAAGD,UAAH,EAAe;AACXH,QAAAA,QAAQ,CAACS,KAAD,CAAR;AACH,OAFD,MAEO;AACJ,cAAMA,KAAN;AACF;AACJ;AACJ;AACJ,CA5DD;;AA+DAW,MAAM,CAACC,OAAP,GAAiBvB,SAAjB","sourcesContent":["var randomHex = function(size, callback) {\n    var crypto = require('./crypto.js');\n    var isCallback = (typeof callback === 'function');\n\n    \n    if (size > 65536) {\n        if(isCallback) {\n            callback(new Error('Requested too many random bytes.'));\n        } else {\n            throw new Error('Requested too many random bytes.');\n        }\n    };\n\n\n    // is node\n    if (typeof crypto !== 'undefined' && crypto.randomBytes) {\n\n        if(isCallback) {\n            crypto.randomBytes(size, function(err, result){\n                if(!err) {\n                    callback(null, '0x'+ result.toString('hex'));\n                } else {\n                    callback(error);\n                }\n            })\n        } else {\n            return '0x'+ crypto.randomBytes(size).toString('hex');\n        }\n\n    // is browser\n    } else {\n        var cryptoLib;\n\n        if (typeof crypto !== 'undefined') {\n            cryptoLib = crypto;\n        } else if(typeof msCrypto !== 'undefined') {\n            cryptoLib = msCrypto;\n        }\n\n        if (cryptoLib && cryptoLib.getRandomValues) {\n            var randomBytes = cryptoLib.getRandomValues(new Uint8Array(size));\n            var returnValue = '0x'+ Array.from(randomBytes).map(function(arr){ return arr.toString(16); }).join('');\n\n            if(isCallback) {\n                callback(null, returnValue);\n            } else {\n                return returnValue;\n            }\n\n        // not crypto object\n        } else {\n            var error = new Error('No \"crypto\" object available. This Browser doesn\\'t support generating secure random bytes.');\n\n            if(isCallback) {\n                callback(error);\n            } else {\n               throw error;\n            }\n        }\n    }\n};\n\n\nmodule.exports = randomHex;\n"]},"metadata":{},"sourceType":"script"}