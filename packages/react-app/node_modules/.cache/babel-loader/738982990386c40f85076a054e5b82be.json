{"ast":null,"code":"import _toConsumableArray from \"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { Kind, parse, visit } from 'graphql';\nimport { offsetToPosition } from 'graphql-language-service-utils';\nvar INLINE_FRAGMENT = Kind.INLINE_FRAGMENT;\nvar OUTLINEABLE_KINDS = {\n  Field: true,\n  OperationDefinition: true,\n  Document: true,\n  SelectionSet: true,\n  Name: true,\n  FragmentDefinition: true,\n  FragmentSpread: true,\n  InlineFragment: true,\n  ObjectTypeDefinition: true,\n  InputObjectTypeDefinition: true,\n  InterfaceTypeDefinition: true,\n  EnumTypeDefinition: true,\n  EnumValueDefinition: true,\n  InputValueDefinition: true,\n  FieldDefinition: true\n};\nexport function getOutline(documentText) {\n  var ast;\n\n  try {\n    ast = parse(documentText);\n  } catch (error) {\n    return null;\n  }\n\n  var visitorFns = outlineTreeConverter(documentText);\n  var outlineTrees = visit(ast, {\n    leave: function leave(node) {\n      if (visitorFns !== undefined && node.kind in visitorFns) {\n        return visitorFns[node.kind](node);\n      }\n\n      return null;\n    }\n  });\n  return {\n    outlineTrees: outlineTrees\n  };\n}\n\nfunction outlineTreeConverter(docText) {\n  var meta = function meta(node) {\n    return {\n      representativeName: node.name,\n      startPosition: offsetToPosition(docText, node.loc.start),\n      endPosition: offsetToPosition(docText, node.loc.end),\n      kind: node.kind,\n      children: node.selectionSet || node.fields || node.values || node.arguments || []\n    };\n  };\n\n  return {\n    Field: function Field(node) {\n      var tokenizedText = node.alias ? [buildToken('plain', node.alias), buildToken('plain', ': ')] : [];\n      tokenizedText.push(buildToken('plain', node.name));\n      return Object.assign({\n        tokenizedText: tokenizedText\n      }, meta(node));\n    },\n    OperationDefinition: function OperationDefinition(node) {\n      return Object.assign({\n        tokenizedText: [buildToken('keyword', node.operation), buildToken('whitespace', ' '), buildToken('class-name', node.name)]\n      }, meta(node));\n    },\n    Document: function Document(node) {\n      return node.definitions;\n    },\n    SelectionSet: function SelectionSet(node) {\n      return concatMap(node.selections, function (child) {\n        return child.kind === INLINE_FRAGMENT ? child.selectionSet : child;\n      });\n    },\n    Name: function Name(node) {\n      return node.value;\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      return Object.assign({\n        tokenizedText: [buildToken('keyword', 'fragment'), buildToken('whitespace', ' '), buildToken('class-name', node.name)]\n      }, meta(node));\n    },\n    InterfaceTypeDefinition: function InterfaceTypeDefinition(node) {\n      return Object.assign({\n        tokenizedText: [buildToken('keyword', 'interface'), buildToken('whitespace', ' '), buildToken('class-name', node.name)]\n      }, meta(node));\n    },\n    EnumTypeDefinition: function EnumTypeDefinition(node) {\n      return Object.assign({\n        tokenizedText: [buildToken('keyword', 'enum'), buildToken('whitespace', ' '), buildToken('class-name', node.name)]\n      }, meta(node));\n    },\n    EnumValueDefinition: function EnumValueDefinition(node) {\n      return Object.assign({\n        tokenizedText: [buildToken('plain', node.name)]\n      }, meta(node));\n    },\n    ObjectTypeDefinition: function ObjectTypeDefinition(node) {\n      return Object.assign({\n        tokenizedText: [buildToken('keyword', 'type'), buildToken('whitespace', ' '), buildToken('class-name', node.name)]\n      }, meta(node));\n    },\n    InputObjectTypeDefinition: function InputObjectTypeDefinition(node) {\n      return Object.assign({\n        tokenizedText: [buildToken('keyword', 'input'), buildToken('whitespace', ' '), buildToken('class-name', node.name)]\n      }, meta(node));\n    },\n    FragmentSpread: function FragmentSpread(node) {\n      return Object.assign({\n        tokenizedText: [buildToken('plain', '...'), buildToken('class-name', node.name)]\n      }, meta(node));\n    },\n    InputValueDefinition: function InputValueDefinition(node) {\n      return Object.assign({\n        tokenizedText: [buildToken('plain', node.name)]\n      }, meta(node));\n    },\n    FieldDefinition: function FieldDefinition(node) {\n      return Object.assign({\n        tokenizedText: [buildToken('plain', node.name)]\n      }, meta(node));\n    },\n    InlineFragment: function InlineFragment(node) {\n      return node.selectionSet;\n    }\n  };\n}\n\nfunction buildToken(kind, value) {\n  return {\n    kind: kind,\n    value: value\n  };\n}\n\nfunction concatMap(arr, fn) {\n  var res = [];\n\n  for (var i = 0; i < arr.length; i++) {\n    var x = fn(arr[i], i);\n\n    if (Array.isArray(x)) {\n      res.push.apply(res, _toConsumableArray(x));\n    } else {\n      res.push(x);\n    }\n  }\n\n  return res;\n}","map":{"version":3,"sources":["../src/getOutline.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Kind, parse, visit, } from 'graphql';\nimport { offsetToPosition } from 'graphql-language-service-utils';\nconst { INLINE_FRAGMENT } = Kind;\nconst OUTLINEABLE_KINDS = {\n    Field: true,\n    OperationDefinition: true,\n    Document: true,\n    SelectionSet: true,\n    Name: true,\n    FragmentDefinition: true,\n    FragmentSpread: true,\n    InlineFragment: true,\n    ObjectTypeDefinition: true,\n    InputObjectTypeDefinition: true,\n    InterfaceTypeDefinition: true,\n    EnumTypeDefinition: true,\n    EnumValueDefinition: true,\n    InputValueDefinition: true,\n    FieldDefinition: true,\n};\nexport function getOutline(documentText) {\n    let ast;\n    try {\n        ast = parse(documentText);\n    }\n    catch (error) {\n        return null;\n    }\n    const visitorFns = outlineTreeConverter(documentText);\n    const outlineTrees = visit(ast, {\n        leave(node) {\n            if (visitorFns !== undefined && node.kind in visitorFns) {\n                return visitorFns[node.kind](node);\n            }\n            return null;\n        },\n    });\n    return { outlineTrees };\n}\nfunction outlineTreeConverter(docText) {\n    const meta = (node) => {\n        return {\n            representativeName: node.name,\n            startPosition: offsetToPosition(docText, node.loc.start),\n            endPosition: offsetToPosition(docText, node.loc.end),\n            kind: node.kind,\n            children: node.selectionSet || node.fields || node.values || node.arguments || [],\n        };\n    };\n    return {\n        Field: (node) => {\n            const tokenizedText = node.alias\n                ? [buildToken('plain', node.alias), buildToken('plain', ': ')]\n                : [];\n            tokenizedText.push(buildToken('plain', node.name));\n            return Object.assign({ tokenizedText }, meta(node));\n        },\n        OperationDefinition: (node) => (Object.assign({ tokenizedText: [\n                buildToken('keyword', node.operation),\n                buildToken('whitespace', ' '),\n                buildToken('class-name', node.name),\n            ] }, meta(node))),\n        Document: (node) => node.definitions,\n        SelectionSet: (node) => concatMap(node.selections, (child) => {\n            return child.kind === INLINE_FRAGMENT ? child.selectionSet : child;\n        }),\n        Name: (node) => node.value,\n        FragmentDefinition: (node) => (Object.assign({ tokenizedText: [\n                buildToken('keyword', 'fragment'),\n                buildToken('whitespace', ' '),\n                buildToken('class-name', node.name),\n            ] }, meta(node))),\n        InterfaceTypeDefinition: (node) => (Object.assign({ tokenizedText: [\n                buildToken('keyword', 'interface'),\n                buildToken('whitespace', ' '),\n                buildToken('class-name', node.name),\n            ] }, meta(node))),\n        EnumTypeDefinition: (node) => (Object.assign({ tokenizedText: [\n                buildToken('keyword', 'enum'),\n                buildToken('whitespace', ' '),\n                buildToken('class-name', node.name),\n            ] }, meta(node))),\n        EnumValueDefinition: (node) => (Object.assign({ tokenizedText: [buildToken('plain', node.name)] }, meta(node))),\n        ObjectTypeDefinition: (node) => (Object.assign({ tokenizedText: [\n                buildToken('keyword', 'type'),\n                buildToken('whitespace', ' '),\n                buildToken('class-name', node.name),\n            ] }, meta(node))),\n        InputObjectTypeDefinition: (node) => (Object.assign({ tokenizedText: [\n                buildToken('keyword', 'input'),\n                buildToken('whitespace', ' '),\n                buildToken('class-name', node.name),\n            ] }, meta(node))),\n        FragmentSpread: (node) => (Object.assign({ tokenizedText: [\n                buildToken('plain', '...'),\n                buildToken('class-name', node.name),\n            ] }, meta(node))),\n        InputValueDefinition: (node) => {\n            return Object.assign({ tokenizedText: [buildToken('plain', node.name)] }, meta(node));\n        },\n        FieldDefinition: (node) => {\n            return Object.assign({ tokenizedText: [buildToken('plain', node.name)] }, meta(node));\n        },\n        InlineFragment: (node) => node.selectionSet,\n    };\n}\nfunction buildToken(kind, value) {\n    return { kind, value };\n}\nfunction concatMap(arr, fn) {\n    const res = [];\n    for (let i = 0; i < arr.length; i++) {\n        const x = fn(arr[i], i);\n        if (Array.isArray(x)) {\n            res.push(...x);\n        }\n        else {\n            res.push(x);\n        }\n    }\n    return res;\n}\n//# sourceMappingURL=getOutline.js.map"]},"metadata":{},"sourceType":"module"}