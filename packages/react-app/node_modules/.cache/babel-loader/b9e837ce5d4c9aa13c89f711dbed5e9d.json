{"ast":null,"code":"// Parser state class\n'use strict';\n\nvar Token = require('../token');\n\nvar isSpace = require('../common/utils').isSpace;\n\nfunction StateBlock(src, md, env, tokens) {\n  var ch, s, start, pos, len, indent, offset, indent_found;\n  this.src = src; // link to parser instance\n\n  this.md = md;\n  this.env = env; //\n  // Internal state vartiables\n  //\n\n  this.tokens = tokens;\n  this.bMarks = []; // line begin offsets for fast jumps\n\n  this.eMarks = []; // line end offsets for fast jumps\n\n  this.tShift = []; // offsets of the first non-space characters (tabs not expanded)\n\n  this.sCount = []; // indents for each line (tabs expanded)\n  // An amount of virtual spaces (tabs expanded) between beginning\n  // of each line (bMarks) and real beginning of that line.\n  //\n  // It exists only as a hack because blockquotes override bMarks\n  // losing information in the process.\n  //\n  // It's used only when expanding tabs, you can think about it as\n  // an initial tab length, e.g. bsCount=21 applied to string `\\t123`\n  // means first tab should be expanded to 4-21%4 === 3 spaces.\n  //\n\n  this.bsCount = []; // block parser variables\n\n  this.blkIndent = 0; // required block content indent (for example, if we are\n  // inside a list, it would be positioned after list marker)\n\n  this.line = 0; // line index in src\n\n  this.lineMax = 0; // lines count\n\n  this.tight = false; // loose/tight mode for lists\n\n  this.ddIndent = -1; // indent of the current dd block (-1 if there isn't any)\n\n  this.listIndent = -1; // indent of the current list block (-1 if there isn't any)\n  // can be 'blockquote', 'list', 'root', 'paragraph' or 'reference'\n  // used in lists to determine if they interrupt a paragraph\n\n  this.parentType = 'root';\n  this.level = 0; // renderer\n\n  this.result = ''; // Create caches\n  // Generate markers.\n\n  s = this.src;\n  indent_found = false;\n\n  for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {\n    ch = s.charCodeAt(pos);\n\n    if (!indent_found) {\n      if (isSpace(ch)) {\n        indent++;\n\n        if (ch === 0x09) {\n          offset += 4 - offset % 4;\n        } else {\n          offset++;\n        }\n\n        continue;\n      } else {\n        indent_found = true;\n      }\n    }\n\n    if (ch === 0x0A || pos === len - 1) {\n      if (ch !== 0x0A) {\n        pos++;\n      }\n\n      this.bMarks.push(start);\n      this.eMarks.push(pos);\n      this.tShift.push(indent);\n      this.sCount.push(offset);\n      this.bsCount.push(0);\n      indent_found = false;\n      indent = 0;\n      offset = 0;\n      start = pos + 1;\n    }\n  } // Push fake entry to simplify cache bounds checks\n\n\n  this.bMarks.push(s.length);\n  this.eMarks.push(s.length);\n  this.tShift.push(0);\n  this.sCount.push(0);\n  this.bsCount.push(0);\n  this.lineMax = this.bMarks.length - 1; // don't count last fake line\n} // Push new token to \"stream\".\n//\n\n\nStateBlock.prototype.push = function (type, tag, nesting) {\n  var token = new Token(type, tag, nesting);\n  token.block = true;\n  if (nesting < 0) this.level--; // closing tag\n\n  token.level = this.level;\n  if (nesting > 0) this.level++; // opening tag\n\n  this.tokens.push(token);\n  return token;\n};\n\nStateBlock.prototype.isEmpty = function isEmpty(line) {\n  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];\n};\n\nStateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {\n  for (var max = this.lineMax; from < max; from++) {\n    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {\n      break;\n    }\n  }\n\n  return from;\n}; // Skip spaces from given position.\n\n\nStateBlock.prototype.skipSpaces = function skipSpaces(pos) {\n  var ch;\n\n  for (var max = this.src.length; pos < max; pos++) {\n    ch = this.src.charCodeAt(pos);\n\n    if (!isSpace(ch)) {\n      break;\n    }\n  }\n\n  return pos;\n}; // Skip spaces from given position in reverse.\n\n\nStateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {\n  if (pos <= min) {\n    return pos;\n  }\n\n  while (pos > min) {\n    if (!isSpace(this.src.charCodeAt(--pos))) {\n      return pos + 1;\n    }\n  }\n\n  return pos;\n}; // Skip char codes from given position\n\n\nStateBlock.prototype.skipChars = function skipChars(pos, code) {\n  for (var max = this.src.length; pos < max; pos++) {\n    if (this.src.charCodeAt(pos) !== code) {\n      break;\n    }\n  }\n\n  return pos;\n}; // Skip char codes reverse from given position - 1\n\n\nStateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {\n  if (pos <= min) {\n    return pos;\n  }\n\n  while (pos > min) {\n    if (code !== this.src.charCodeAt(--pos)) {\n      return pos + 1;\n    }\n  }\n\n  return pos;\n}; // cut lines range from source.\n\n\nStateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {\n  var i,\n      lineIndent,\n      ch,\n      first,\n      last,\n      queue,\n      lineStart,\n      line = begin;\n\n  if (begin >= end) {\n    return '';\n  }\n\n  queue = new Array(end - begin);\n\n  for (i = 0; line < end; line++, i++) {\n    lineIndent = 0;\n    lineStart = first = this.bMarks[line];\n\n    if (line + 1 < end || keepLastLF) {\n      // No need for bounds check because we have fake entry on tail.\n      last = this.eMarks[line] + 1;\n    } else {\n      last = this.eMarks[line];\n    }\n\n    while (first < last && lineIndent < indent) {\n      ch = this.src.charCodeAt(first);\n\n      if (isSpace(ch)) {\n        if (ch === 0x09) {\n          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;\n        } else {\n          lineIndent++;\n        }\n      } else if (first - lineStart < this.tShift[line]) {\n        // patched tShift masked characters to look like spaces (blockquotes, list markers)\n        lineIndent++;\n      } else {\n        break;\n      }\n\n      first++;\n    }\n\n    if (lineIndent > indent) {\n      // partially expanding tabs in code blocks, e.g '\\t\\tfoobar'\n      // with indent=2 becomes '  \\tfoobar'\n      queue[i] = new Array(lineIndent - indent + 1).join(' ') + this.src.slice(first, last);\n    } else {\n      queue[i] = this.src.slice(first, last);\n    }\n  }\n\n  return queue.join('');\n}; // re-export Token class to use in block rules\n\n\nStateBlock.prototype.Token = Token;\nmodule.exports = StateBlock;","map":{"version":3,"sources":["/Users/sam/Desktop/kiwik/node_modules/markdown-it/lib/rules_block/state_block.js"],"names":["Token","require","isSpace","StateBlock","src","md","env","tokens","ch","s","start","pos","len","indent","offset","indent_found","bMarks","eMarks","tShift","sCount","bsCount","blkIndent","line","lineMax","tight","ddIndent","listIndent","parentType","level","result","length","charCodeAt","push","prototype","type","tag","nesting","token","block","isEmpty","skipEmptyLines","from","max","skipSpaces","skipSpacesBack","min","skipChars","code","skipCharsBack","getLines","begin","end","keepLastLF","i","lineIndent","first","last","queue","lineStart","Array","join","slice","module","exports"],"mappings":"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","sourcesContent":["// Parser state class\n\n'use strict';\n\nvar Token = require('../token');\nvar isSpace = require('../common/utils').isSpace;\n\n\nfunction StateBlock(src, md, env, tokens) {\n  var ch, s, start, pos, len, indent, offset, indent_found;\n\n  this.src = src;\n\n  // link to parser instance\n  this.md     = md;\n\n  this.env = env;\n\n  //\n  // Internal state vartiables\n  //\n\n  this.tokens = tokens;\n\n  this.bMarks = [];  // line begin offsets for fast jumps\n  this.eMarks = [];  // line end offsets for fast jumps\n  this.tShift = [];  // offsets of the first non-space characters (tabs not expanded)\n  this.sCount = [];  // indents for each line (tabs expanded)\n\n  // An amount of virtual spaces (tabs expanded) between beginning\n  // of each line (bMarks) and real beginning of that line.\n  //\n  // It exists only as a hack because blockquotes override bMarks\n  // losing information in the process.\n  //\n  // It's used only when expanding tabs, you can think about it as\n  // an initial tab length, e.g. bsCount=21 applied to string `\\t123`\n  // means first tab should be expanded to 4-21%4 === 3 spaces.\n  //\n  this.bsCount = [];\n\n  // block parser variables\n  this.blkIndent  = 0; // required block content indent (for example, if we are\n                       // inside a list, it would be positioned after list marker)\n  this.line       = 0; // line index in src\n  this.lineMax    = 0; // lines count\n  this.tight      = false;  // loose/tight mode for lists\n  this.ddIndent   = -1; // indent of the current dd block (-1 if there isn't any)\n  this.listIndent = -1; // indent of the current list block (-1 if there isn't any)\n\n  // can be 'blockquote', 'list', 'root', 'paragraph' or 'reference'\n  // used in lists to determine if they interrupt a paragraph\n  this.parentType = 'root';\n\n  this.level = 0;\n\n  // renderer\n  this.result = '';\n\n  // Create caches\n  // Generate markers.\n  s = this.src;\n  indent_found = false;\n\n  for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {\n    ch = s.charCodeAt(pos);\n\n    if (!indent_found) {\n      if (isSpace(ch)) {\n        indent++;\n\n        if (ch === 0x09) {\n          offset += 4 - offset % 4;\n        } else {\n          offset++;\n        }\n        continue;\n      } else {\n        indent_found = true;\n      }\n    }\n\n    if (ch === 0x0A || pos === len - 1) {\n      if (ch !== 0x0A) { pos++; }\n      this.bMarks.push(start);\n      this.eMarks.push(pos);\n      this.tShift.push(indent);\n      this.sCount.push(offset);\n      this.bsCount.push(0);\n\n      indent_found = false;\n      indent = 0;\n      offset = 0;\n      start = pos + 1;\n    }\n  }\n\n  // Push fake entry to simplify cache bounds checks\n  this.bMarks.push(s.length);\n  this.eMarks.push(s.length);\n  this.tShift.push(0);\n  this.sCount.push(0);\n  this.bsCount.push(0);\n\n  this.lineMax = this.bMarks.length - 1; // don't count last fake line\n}\n\n// Push new token to \"stream\".\n//\nStateBlock.prototype.push = function (type, tag, nesting) {\n  var token = new Token(type, tag, nesting);\n  token.block = true;\n\n  if (nesting < 0) this.level--; // closing tag\n  token.level = this.level;\n  if (nesting > 0) this.level++; // opening tag\n\n  this.tokens.push(token);\n  return token;\n};\n\nStateBlock.prototype.isEmpty = function isEmpty(line) {\n  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];\n};\n\nStateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {\n  for (var max = this.lineMax; from < max; from++) {\n    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {\n      break;\n    }\n  }\n  return from;\n};\n\n// Skip spaces from given position.\nStateBlock.prototype.skipSpaces = function skipSpaces(pos) {\n  var ch;\n\n  for (var max = this.src.length; pos < max; pos++) {\n    ch = this.src.charCodeAt(pos);\n    if (!isSpace(ch)) { break; }\n  }\n  return pos;\n};\n\n// Skip spaces from given position in reverse.\nStateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {\n  if (pos <= min) { return pos; }\n\n  while (pos > min) {\n    if (!isSpace(this.src.charCodeAt(--pos))) { return pos + 1; }\n  }\n  return pos;\n};\n\n// Skip char codes from given position\nStateBlock.prototype.skipChars = function skipChars(pos, code) {\n  for (var max = this.src.length; pos < max; pos++) {\n    if (this.src.charCodeAt(pos) !== code) { break; }\n  }\n  return pos;\n};\n\n// Skip char codes reverse from given position - 1\nStateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {\n  if (pos <= min) { return pos; }\n\n  while (pos > min) {\n    if (code !== this.src.charCodeAt(--pos)) { return pos + 1; }\n  }\n  return pos;\n};\n\n// cut lines range from source.\nStateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {\n  var i, lineIndent, ch, first, last, queue, lineStart,\n      line = begin;\n\n  if (begin >= end) {\n    return '';\n  }\n\n  queue = new Array(end - begin);\n\n  for (i = 0; line < end; line++, i++) {\n    lineIndent = 0;\n    lineStart = first = this.bMarks[line];\n\n    if (line + 1 < end || keepLastLF) {\n      // No need for bounds check because we have fake entry on tail.\n      last = this.eMarks[line] + 1;\n    } else {\n      last = this.eMarks[line];\n    }\n\n    while (first < last && lineIndent < indent) {\n      ch = this.src.charCodeAt(first);\n\n      if (isSpace(ch)) {\n        if (ch === 0x09) {\n          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;\n        } else {\n          lineIndent++;\n        }\n      } else if (first - lineStart < this.tShift[line]) {\n        // patched tShift masked characters to look like spaces (blockquotes, list markers)\n        lineIndent++;\n      } else {\n        break;\n      }\n\n      first++;\n    }\n\n    if (lineIndent > indent) {\n      // partially expanding tabs in code blocks, e.g '\\t\\tfoobar'\n      // with indent=2 becomes '  \\tfoobar'\n      queue[i] = new Array(lineIndent - indent + 1).join(' ') + this.src.slice(first, last);\n    } else {\n      queue[i] = this.src.slice(first, last);\n    }\n  }\n\n  return queue.join('');\n};\n\n// re-export Token class to use in block rules\nStateBlock.prototype.Token = Token;\n\n\nmodule.exports = StateBlock;\n"]},"metadata":{},"sourceType":"script"}