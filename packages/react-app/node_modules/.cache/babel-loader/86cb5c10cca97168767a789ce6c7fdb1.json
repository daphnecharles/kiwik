{"ast":null,"code":"import _regeneratorRuntime from \"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _toConsumableArray from \"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _asyncToGenerator from \"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _slicedToArray from \"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\nvar _this = this;\n\nimport { useCallback, useEffect, useState } from 'react';\nimport { useOnRepetition } from \"./useOnRepetition\";\nvar DEBUG = false;\n/**\n * Enables you to call functions in contracts and read their values.  It helps keep track of them in the local React states\n *\n  ~ Features ~\n  - Provide readContracts by loading contracts (see more on ContractLoader.js)\n  - Specify the name of the contract, in this case it is \"YourContract\"\n  - Specify the name of the variable in the contract, in this case we keep track of \"purpose\" variable\n  - Pass an args array if the function requires\n  - Pass pollTime - if no pollTime is specified, the function will update on every new block\n * @param contracts (Record<string, Contract>) :: a record of contractName/contract\n * @param contractName (string) :: The contract name\n * @param functionName (string) :: The function name in the contract\n * @param functionArgs (any[]) :: arguments to functions\n * @param pollTime (number) :: optional :: if >0 use polling, else use instead of onBlock event\n * @param formatter ((_value: T) => T) :: optional :: function to format the result\n * @param onChange (string) :: optional :: callback to call with the function\n * @returns (<T>) :: generic return type\n */\n\nexport var useContractReader = function useContractReader(contracts, contractName, functionName) {\n  var functionArgs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  var pollTime = arguments.length > 4 ? arguments[4] : undefined;\n  var formatter = arguments.length > 5 ? arguments[5] : undefined;\n  var onChange = arguments.length > 6 ? arguments[6] : undefined;\n\n  var _a;\n\n  var _useState = useState(),\n      _useState2 = _slicedToArray(_useState, 2),\n      value = _useState2[0],\n      setValue = _useState2[1];\n\n  useEffect(function () {\n    if (typeof onChange === 'function') {\n      setTimeout(onChange.bind(_this, value), 1);\n    }\n  }, [value, onChange]);\n  var updateValue = useCallback( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var _a, contractFunction, newValue;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            contractFunction = (_a = contracts === null || contracts === void 0 ? void 0 : contracts[contractName]) === null || _a === void 0 ? void 0 : _a[functionName];\n            if (DEBUG) console.log('CALLING ', contractName, functionName, 'with args', functionArgs);\n\n            if (!contractFunction) {\n              _context.next = 16;\n              break;\n            }\n\n            if (!(functionArgs && functionArgs.length > 0)) {\n              _context.next = 11;\n              break;\n            }\n\n            _context.next = 7;\n            return contractFunction.apply(void 0, _toConsumableArray(functionArgs));\n\n          case 7:\n            newValue = _context.sent;\n            if (DEBUG) console.log('contractName', contractName, 'functionName', functionName, 'functionArgs', functionArgs, 'RESULT:', newValue);\n            _context.next = 14;\n            break;\n\n          case 11:\n            _context.next = 13;\n            return contractFunction();\n\n          case 13:\n            newValue = _context.sent;\n\n          case 14:\n            if (formatter && typeof formatter === 'function') {\n              newValue = formatter(newValue);\n            }\n\n            setValue(newValue);\n\n          case 16:\n            _context.next = 21;\n            break;\n\n          case 18:\n            _context.prev = 18;\n            _context.t0 = _context[\"catch\"](0);\n            console.log(_context.t0);\n\n          case 21:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[0, 18]]);\n  })), [contracts, contractName, functionName, functionArgs, formatter]);\n  useOnRepetition(updateValue, {\n    pollTime: pollTime,\n    leadingTrigger: (contracts === null || contracts === void 0 ? void 0 : contracts[contractName]) != null,\n    provider: (_a = contracts === null || contracts === void 0 ? void 0 : contracts[contractName]) === null || _a === void 0 ? void 0 : _a.provider\n  }, functionArgs);\n  return value;\n};","map":{"version":3,"sources":["/Users/sam/Desktop/kiwik/node_modules/eth-hooks/useContractReader.js"],"names":["useCallback","useEffect","useState","useOnRepetition","DEBUG","useContractReader","contracts","contractName","functionName","functionArgs","pollTime","formatter","onChange","_a","value","setValue","setTimeout","bind","updateValue","contractFunction","console","log","length","newValue","leadingTrigger","provider"],"mappings":"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","sourcesContent":["import { useCallback, useEffect, useState } from 'react';\nimport { useOnRepetition } from \"./useOnRepetition\";\nconst DEBUG = false;\n/**\n * Enables you to call functions in contracts and read their values.  It helps keep track of them in the local React states\n *\n  ~ Features ~\n  - Provide readContracts by loading contracts (see more on ContractLoader.js)\n  - Specify the name of the contract, in this case it is \"YourContract\"\n  - Specify the name of the variable in the contract, in this case we keep track of \"purpose\" variable\n  - Pass an args array if the function requires\n  - Pass pollTime - if no pollTime is specified, the function will update on every new block\n * @param contracts (Record<string, Contract>) :: a record of contractName/contract\n * @param contractName (string) :: The contract name\n * @param functionName (string) :: The function name in the contract\n * @param functionArgs (any[]) :: arguments to functions\n * @param pollTime (number) :: optional :: if >0 use polling, else use instead of onBlock event\n * @param formatter ((_value: T) => T) :: optional :: function to format the result\n * @param onChange (string) :: optional :: callback to call with the function\n * @returns (<T>) :: generic return type\n */\nexport const useContractReader = (contracts, contractName, functionName, functionArgs = [], pollTime, formatter, onChange) => {\n    var _a;\n    const [value, setValue] = useState();\n    useEffect(() => {\n        if (typeof onChange === 'function') {\n            setTimeout(onChange.bind(this, value), 1);\n        }\n    }, [value, onChange]);\n    const updateValue = useCallback(async () => {\n        var _a;\n        try {\n            const contractFunction = (_a = contracts === null || contracts === void 0 ? void 0 : contracts[contractName]) === null || _a === void 0 ? void 0 : _a[functionName];\n            let newValue;\n            if (DEBUG)\n                console.log('CALLING ', contractName, functionName, 'with args', functionArgs);\n            if (contractFunction) {\n                if (functionArgs && functionArgs.length > 0) {\n                    newValue = await contractFunction(...functionArgs);\n                    if (DEBUG)\n                        console.log('contractName', contractName, 'functionName', functionName, 'functionArgs', functionArgs, 'RESULT:', newValue);\n                }\n                else {\n                    newValue = await contractFunction();\n                }\n                if (formatter && typeof formatter === 'function') {\n                    newValue = formatter(newValue);\n                }\n                setValue(newValue);\n            }\n        }\n        catch (e) {\n            console.log(e);\n        }\n    }, [contracts, contractName, functionName, functionArgs, formatter]);\n    useOnRepetition(updateValue, {\n        pollTime,\n        leadingTrigger: (contracts === null || contracts === void 0 ? void 0 : contracts[contractName]) != null,\n        provider: (_a = contracts === null || contracts === void 0 ? void 0 : contracts[contractName]) === null || _a === void 0 ? void 0 : _a.provider,\n    }, functionArgs);\n    return value;\n};\n"]},"metadata":{},"sourceType":"module"}