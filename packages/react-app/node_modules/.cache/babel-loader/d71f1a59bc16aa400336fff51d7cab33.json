{"ast":null,"code":"// Convert straight quotation marks to typographic ones\n//\n'use strict';\n\nvar isWhiteSpace = require('../common/utils').isWhiteSpace;\n\nvar isPunctChar = require('../common/utils').isPunctChar;\n\nvar isMdAsciiPunct = require('../common/utils').isMdAsciiPunct;\n\nvar QUOTE_TEST_RE = /['\"]/;\nvar QUOTE_RE = /['\"]/g;\nvar APOSTROPHE = \"\\u2019\";\n/* â€™ */\n\nfunction replaceAt(str, index, ch) {\n  return str.substr(0, index) + ch + str.substr(index + 1);\n}\n\nfunction process_inlines(tokens, state) {\n  var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;\n  stack = [];\n\n  for (i = 0; i < tokens.length; i++) {\n    token = tokens[i];\n    thisLevel = tokens[i].level;\n\n    for (j = stack.length - 1; j >= 0; j--) {\n      if (stack[j].level <= thisLevel) {\n        break;\n      }\n    }\n\n    stack.length = j + 1;\n\n    if (token.type !== 'text') {\n      continue;\n    }\n\n    text = token.content;\n    pos = 0;\n    max = text.length;\n    /*eslint no-labels:0,block-scoped-var:0*/\n\n    OUTER: while (pos < max) {\n      QUOTE_RE.lastIndex = pos;\n      t = QUOTE_RE.exec(text);\n\n      if (!t) {\n        break;\n      }\n\n      canOpen = canClose = true;\n      pos = t.index + 1;\n      isSingle = t[0] === \"'\"; // Find previous character,\n      // default to space if it's the beginning of the line\n      //\n\n      lastChar = 0x20;\n\n      if (t.index - 1 >= 0) {\n        lastChar = text.charCodeAt(t.index - 1);\n      } else {\n        for (j = i - 1; j >= 0; j--) {\n          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // lastChar defaults to 0x20\n\n          if (!tokens[j].content) continue; // should skip all tokens except 'text', 'html_inline' or 'code_inline'\n\n          lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);\n          break;\n        }\n      } // Find next character,\n      // default to space if it's the end of the line\n      //\n\n\n      nextChar = 0x20;\n\n      if (pos < max) {\n        nextChar = text.charCodeAt(pos);\n      } else {\n        for (j = i + 1; j < tokens.length; j++) {\n          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // nextChar defaults to 0x20\n\n          if (!tokens[j].content) continue; // should skip all tokens except 'text', 'html_inline' or 'code_inline'\n\n          nextChar = tokens[j].content.charCodeAt(0);\n          break;\n        }\n      }\n\n      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));\n      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));\n      isLastWhiteSpace = isWhiteSpace(lastChar);\n      isNextWhiteSpace = isWhiteSpace(nextChar);\n\n      if (isNextWhiteSpace) {\n        canOpen = false;\n      } else if (isNextPunctChar) {\n        if (!(isLastWhiteSpace || isLastPunctChar)) {\n          canOpen = false;\n        }\n      }\n\n      if (isLastWhiteSpace) {\n        canClose = false;\n      } else if (isLastPunctChar) {\n        if (!(isNextWhiteSpace || isNextPunctChar)) {\n          canClose = false;\n        }\n      }\n\n      if (nextChar === 0x22\n      /* \" */\n      && t[0] === '\"') {\n        if (lastChar >= 0x30\n        /* 0 */\n        && lastChar <= 0x39\n        /* 9 */\n        ) {\n          // special case: 1\"\" - count first quote as an inch\n          canClose = canOpen = false;\n        }\n      }\n\n      if (canOpen && canClose) {\n        // Replace quotes in the middle of punctuation sequence, but not\n        // in the middle of the words, i.e.:\n        //\n        // 1. foo \" bar \" baz - not replaced\n        // 2. foo-\"-bar-\"-baz - replaced\n        // 3. foo\"bar\"baz     - not replaced\n        //\n        canOpen = isLastPunctChar;\n        canClose = isNextPunctChar;\n      }\n\n      if (!canOpen && !canClose) {\n        // middle of word\n        if (isSingle) {\n          token.content = replaceAt(token.content, t.index, APOSTROPHE);\n        }\n\n        continue;\n      }\n\n      if (canClose) {\n        // this could be a closing quote, rewind the stack to get a match\n        for (j = stack.length - 1; j >= 0; j--) {\n          item = stack[j];\n\n          if (stack[j].level < thisLevel) {\n            break;\n          }\n\n          if (item.single === isSingle && stack[j].level === thisLevel) {\n            item = stack[j];\n\n            if (isSingle) {\n              openQuote = state.md.options.quotes[2];\n              closeQuote = state.md.options.quotes[3];\n            } else {\n              openQuote = state.md.options.quotes[0];\n              closeQuote = state.md.options.quotes[1];\n            } // replace token.content *before* tokens[item.token].content,\n            // because, if they are pointing at the same token, replaceAt\n            // could mess up indices when quote length != 1\n\n\n            token.content = replaceAt(token.content, t.index, closeQuote);\n            tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, openQuote);\n            pos += closeQuote.length - 1;\n\n            if (item.token === i) {\n              pos += openQuote.length - 1;\n            }\n\n            text = token.content;\n            max = text.length;\n            stack.length = j;\n            continue OUTER;\n          }\n        }\n      }\n\n      if (canOpen) {\n        stack.push({\n          token: i,\n          pos: t.index,\n          single: isSingle,\n          level: thisLevel\n        });\n      } else if (canClose && isSingle) {\n        token.content = replaceAt(token.content, t.index, APOSTROPHE);\n      }\n    }\n  }\n}\n\nmodule.exports = function smartquotes(state) {\n  /*eslint max-depth:0*/\n  var blkIdx;\n\n  if (!state.md.options.typographer) {\n    return;\n  }\n\n  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n    if (state.tokens[blkIdx].type !== 'inline' || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {\n      continue;\n    }\n\n    process_inlines(state.tokens[blkIdx].children, state);\n  }\n};","map":{"version":3,"sources":["/Users/sam/Desktop/kiwik/node_modules/markdown-it/lib/rules_core/smartquotes.js"],"names":["isWhiteSpace","require","isPunctChar","isMdAsciiPunct","QUOTE_TEST_RE","QUOTE_RE","APOSTROPHE","replaceAt","str","index","ch","substr","process_inlines","tokens","state","i","token","text","t","pos","max","thisLevel","item","lastChar","nextChar","isLastPunctChar","isNextPunctChar","isLastWhiteSpace","isNextWhiteSpace","canOpen","canClose","j","isSingle","stack","openQuote","closeQuote","length","level","type","content","OUTER","lastIndex","exec","charCodeAt","String","fromCharCode","single","md","options","quotes","push","module","exports","smartquotes","blkIdx","typographer","test","children"],"mappings":"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","sourcesContent":["// Convert straight quotation marks to typographic ones\n//\n'use strict';\n\n\nvar isWhiteSpace   = require('../common/utils').isWhiteSpace;\nvar isPunctChar    = require('../common/utils').isPunctChar;\nvar isMdAsciiPunct = require('../common/utils').isMdAsciiPunct;\n\nvar QUOTE_TEST_RE = /['\"]/;\nvar QUOTE_RE = /['\"]/g;\nvar APOSTROPHE = '\\u2019'; /* â€™ */\n\n\nfunction replaceAt(str, index, ch) {\n  return str.substr(0, index) + ch + str.substr(index + 1);\n}\n\nfunction process_inlines(tokens, state) {\n  var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar,\n      isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace,\n      canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;\n\n  stack = [];\n\n  for (i = 0; i < tokens.length; i++) {\n    token = tokens[i];\n\n    thisLevel = tokens[i].level;\n\n    for (j = stack.length - 1; j >= 0; j--) {\n      if (stack[j].level <= thisLevel) { break; }\n    }\n    stack.length = j + 1;\n\n    if (token.type !== 'text') { continue; }\n\n    text = token.content;\n    pos = 0;\n    max = text.length;\n\n    /*eslint no-labels:0,block-scoped-var:0*/\n    OUTER:\n    while (pos < max) {\n      QUOTE_RE.lastIndex = pos;\n      t = QUOTE_RE.exec(text);\n      if (!t) { break; }\n\n      canOpen = canClose = true;\n      pos = t.index + 1;\n      isSingle = (t[0] === \"'\");\n\n      // Find previous character,\n      // default to space if it's the beginning of the line\n      //\n      lastChar = 0x20;\n\n      if (t.index - 1 >= 0) {\n        lastChar = text.charCodeAt(t.index - 1);\n      } else {\n        for (j = i - 1; j >= 0; j--) {\n          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // lastChar defaults to 0x20\n          if (!tokens[j].content) continue; // should skip all tokens except 'text', 'html_inline' or 'code_inline'\n\n          lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);\n          break;\n        }\n      }\n\n      // Find next character,\n      // default to space if it's the end of the line\n      //\n      nextChar = 0x20;\n\n      if (pos < max) {\n        nextChar = text.charCodeAt(pos);\n      } else {\n        for (j = i + 1; j < tokens.length; j++) {\n          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // nextChar defaults to 0x20\n          if (!tokens[j].content) continue; // should skip all tokens except 'text', 'html_inline' or 'code_inline'\n\n          nextChar = tokens[j].content.charCodeAt(0);\n          break;\n        }\n      }\n\n      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));\n      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));\n\n      isLastWhiteSpace = isWhiteSpace(lastChar);\n      isNextWhiteSpace = isWhiteSpace(nextChar);\n\n      if (isNextWhiteSpace) {\n        canOpen = false;\n      } else if (isNextPunctChar) {\n        if (!(isLastWhiteSpace || isLastPunctChar)) {\n          canOpen = false;\n        }\n      }\n\n      if (isLastWhiteSpace) {\n        canClose = false;\n      } else if (isLastPunctChar) {\n        if (!(isNextWhiteSpace || isNextPunctChar)) {\n          canClose = false;\n        }\n      }\n\n      if (nextChar === 0x22 /* \" */ && t[0] === '\"') {\n        if (lastChar >= 0x30 /* 0 */ && lastChar <= 0x39 /* 9 */) {\n          // special case: 1\"\" - count first quote as an inch\n          canClose = canOpen = false;\n        }\n      }\n\n      if (canOpen && canClose) {\n        // Replace quotes in the middle of punctuation sequence, but not\n        // in the middle of the words, i.e.:\n        //\n        // 1. foo \" bar \" baz - not replaced\n        // 2. foo-\"-bar-\"-baz - replaced\n        // 3. foo\"bar\"baz     - not replaced\n        //\n        canOpen = isLastPunctChar;\n        canClose = isNextPunctChar;\n      }\n\n      if (!canOpen && !canClose) {\n        // middle of word\n        if (isSingle) {\n          token.content = replaceAt(token.content, t.index, APOSTROPHE);\n        }\n        continue;\n      }\n\n      if (canClose) {\n        // this could be a closing quote, rewind the stack to get a match\n        for (j = stack.length - 1; j >= 0; j--) {\n          item = stack[j];\n          if (stack[j].level < thisLevel) { break; }\n          if (item.single === isSingle && stack[j].level === thisLevel) {\n            item = stack[j];\n\n            if (isSingle) {\n              openQuote = state.md.options.quotes[2];\n              closeQuote = state.md.options.quotes[3];\n            } else {\n              openQuote = state.md.options.quotes[0];\n              closeQuote = state.md.options.quotes[1];\n            }\n\n            // replace token.content *before* tokens[item.token].content,\n            // because, if they are pointing at the same token, replaceAt\n            // could mess up indices when quote length != 1\n            token.content = replaceAt(token.content, t.index, closeQuote);\n            tokens[item.token].content = replaceAt(\n              tokens[item.token].content, item.pos, openQuote);\n\n            pos += closeQuote.length - 1;\n            if (item.token === i) { pos += openQuote.length - 1; }\n\n            text = token.content;\n            max = text.length;\n\n            stack.length = j;\n            continue OUTER;\n          }\n        }\n      }\n\n      if (canOpen) {\n        stack.push({\n          token: i,\n          pos: t.index,\n          single: isSingle,\n          level: thisLevel\n        });\n      } else if (canClose && isSingle) {\n        token.content = replaceAt(token.content, t.index, APOSTROPHE);\n      }\n    }\n  }\n}\n\n\nmodule.exports = function smartquotes(state) {\n  /*eslint max-depth:0*/\n  var blkIdx;\n\n  if (!state.md.options.typographer) { return; }\n\n  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n\n    if (state.tokens[blkIdx].type !== 'inline' ||\n        !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {\n      continue;\n    }\n\n    process_inlines(state.tokens[blkIdx].children, state);\n  }\n};\n"]},"metadata":{},"sourceType":"script"}