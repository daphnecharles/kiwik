{"ast":null,"code":"import _defineProperty from \"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\n\nvar _DIAGNOSTIC_SEVERITY;\n\nimport { print, validate, NoDeprecatedCustomRule } from 'graphql';\nimport { parse } from 'graphql';\nimport { CharacterStream, onlineParser } from 'graphql-language-service-parser';\nimport { Range, validateWithCustomRules, Position } from 'graphql-language-service-utils';\nexport var SEVERITY = {\n  Error: 'Error',\n  Warning: 'Warning',\n  Information: 'Information',\n  Hint: 'Hint'\n};\nexport var DIAGNOSTIC_SEVERITY = (_DIAGNOSTIC_SEVERITY = {}, _defineProperty(_DIAGNOSTIC_SEVERITY, SEVERITY.Error, 1), _defineProperty(_DIAGNOSTIC_SEVERITY, SEVERITY.Warning, 2), _defineProperty(_DIAGNOSTIC_SEVERITY, SEVERITY.Information, 3), _defineProperty(_DIAGNOSTIC_SEVERITY, SEVERITY.Hint, 4), _DIAGNOSTIC_SEVERITY);\n\nvar invariant = function invariant(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n};\n\nexport function getDiagnostics(query) {\n  var schema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var customRules = arguments.length > 2 ? arguments[2] : undefined;\n  var isRelayCompatMode = arguments.length > 3 ? arguments[3] : undefined;\n  var externalFragments = arguments.length > 4 ? arguments[4] : undefined;\n  var ast = null;\n\n  if (externalFragments) {\n    if (typeof externalFragments === 'string') {\n      query += '\\n\\n' + externalFragments;\n    } else {\n      query += '\\n\\n' + externalFragments.reduce(function (agg, node) {\n        agg += print(node) + '\\n\\n';\n        return agg;\n      }, '');\n    }\n  }\n\n  try {\n    ast = parse(query);\n  } catch (error) {\n    var range = getRange(error.locations[0], query);\n    return [{\n      severity: DIAGNOSTIC_SEVERITY.Error,\n      message: error.message,\n      source: 'GraphQL: Syntax',\n      range: range\n    }];\n  }\n\n  return validateQuery(ast, schema, customRules, isRelayCompatMode);\n}\nexport function validateQuery(ast) {\n  var schema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var customRules = arguments.length > 2 ? arguments[2] : undefined;\n  var isRelayCompatMode = arguments.length > 3 ? arguments[3] : undefined;\n\n  if (!schema) {\n    return [];\n  }\n\n  var validationErrorAnnotations = mapCat(validateWithCustomRules(schema, ast, customRules, isRelayCompatMode), function (error) {\n    return annotations(error, DIAGNOSTIC_SEVERITY.Error, 'Validation');\n  });\n  var deprecationWarningAnnotations = mapCat(validate(schema, ast, [NoDeprecatedCustomRule]), function (error) {\n    return annotations(error, DIAGNOSTIC_SEVERITY.Warning, 'Deprecation');\n  });\n  return validationErrorAnnotations.concat(deprecationWarningAnnotations);\n}\n\nfunction mapCat(array, mapper) {\n  return Array.prototype.concat.apply([], array.map(mapper));\n}\n\nfunction annotations(error, severity, type) {\n  if (!error.nodes) {\n    return [];\n  }\n\n  var highlightedNodes = [];\n  error.nodes.forEach(function (node) {\n    var highlightNode = node.kind !== 'Variable' && 'name' in node && node.name !== undefined ? node.name : 'variable' in node && node.variable !== undefined ? node.variable : node;\n\n    if (highlightNode) {\n      invariant(error.locations, 'GraphQL validation error requires locations.');\n      var loc = error.locations[0];\n      var highlightLoc = getLocation(highlightNode);\n      var end = loc.column + (highlightLoc.end - highlightLoc.start);\n      highlightedNodes.push({\n        source: \"GraphQL: \".concat(type),\n        message: error.message,\n        severity: severity,\n        range: new Range(new Position(loc.line - 1, loc.column - 1), new Position(loc.line - 1, end))\n      });\n    }\n  });\n  return highlightedNodes;\n}\n\nexport function getRange(location, queryText) {\n  var parser = onlineParser();\n  var state = parser.startState();\n  var lines = queryText.split('\\n');\n  invariant(lines.length >= location.line, 'Query text must have more lines than where the error happened');\n  var stream = null;\n\n  for (var i = 0; i < location.line; i++) {\n    stream = new CharacterStream(lines[i]);\n\n    while (!stream.eol()) {\n      var style = parser.token(stream, state);\n\n      if (style === 'invalidchar') {\n        break;\n      }\n    }\n  }\n\n  invariant(stream, 'Expected Parser stream to be available.');\n  var line = location.line - 1;\n  var start = stream.getStartOfToken();\n  var end = stream.getCurrentPosition();\n  return new Range(new Position(line, start), new Position(line, end));\n}\n\nfunction getLocation(node) {\n  var typeCastedNode = node;\n  var location = typeCastedNode.loc;\n  invariant(location, 'Expected ASTNode to have a location.');\n  return location;\n}","map":{"version":3,"sources":["../src/getDiagnostics.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { print, validate, NoDeprecatedCustomRule, } from 'graphql';\nimport { parse } from 'graphql';\nimport { CharacterStream, onlineParser } from 'graphql-language-service-parser';\nimport { Range, validateWithCustomRules, Position, } from 'graphql-language-service-utils';\nexport const SEVERITY = {\n    Error: 'Error',\n    Warning: 'Warning',\n    Information: 'Information',\n    Hint: 'Hint',\n};\nexport const DIAGNOSTIC_SEVERITY = {\n    [SEVERITY.Error]: 1,\n    [SEVERITY.Warning]: 2,\n    [SEVERITY.Information]: 3,\n    [SEVERITY.Hint]: 4,\n};\nconst invariant = (condition, message) => {\n    if (!condition) {\n        throw new Error(message);\n    }\n};\nexport function getDiagnostics(query, schema = null, customRules, isRelayCompatMode, externalFragments) {\n    let ast = null;\n    if (externalFragments) {\n        if (typeof externalFragments === 'string') {\n            query += '\\n\\n' + externalFragments;\n        }\n        else {\n            query +=\n                '\\n\\n' +\n                    externalFragments.reduce((agg, node) => {\n                        agg += print(node) + '\\n\\n';\n                        return agg;\n                    }, '');\n        }\n    }\n    try {\n        ast = parse(query);\n    }\n    catch (error) {\n        const range = getRange(error.locations[0], query);\n        return [\n            {\n                severity: DIAGNOSTIC_SEVERITY.Error,\n                message: error.message,\n                source: 'GraphQL: Syntax',\n                range,\n            },\n        ];\n    }\n    return validateQuery(ast, schema, customRules, isRelayCompatMode);\n}\nexport function validateQuery(ast, schema = null, customRules, isRelayCompatMode) {\n    if (!schema) {\n        return [];\n    }\n    const validationErrorAnnotations = mapCat(validateWithCustomRules(schema, ast, customRules, isRelayCompatMode), error => annotations(error, DIAGNOSTIC_SEVERITY.Error, 'Validation'));\n    const deprecationWarningAnnotations = mapCat(validate(schema, ast, [NoDeprecatedCustomRule]), error => annotations(error, DIAGNOSTIC_SEVERITY.Warning, 'Deprecation'));\n    return validationErrorAnnotations.concat(deprecationWarningAnnotations);\n}\nfunction mapCat(array, mapper) {\n    return Array.prototype.concat.apply([], array.map(mapper));\n}\nfunction annotations(error, severity, type) {\n    if (!error.nodes) {\n        return [];\n    }\n    const highlightedNodes = [];\n    error.nodes.forEach(node => {\n        const highlightNode = node.kind !== 'Variable' && 'name' in node && node.name !== undefined\n            ? node.name\n            : 'variable' in node && node.variable !== undefined\n                ? node.variable\n                : node;\n        if (highlightNode) {\n            invariant(error.locations, 'GraphQL validation error requires locations.');\n            const loc = error.locations[0];\n            const highlightLoc = getLocation(highlightNode);\n            const end = loc.column + (highlightLoc.end - highlightLoc.start);\n            highlightedNodes.push({\n                source: `GraphQL: ${type}`,\n                message: error.message,\n                severity,\n                range: new Range(new Position(loc.line - 1, loc.column - 1), new Position(loc.line - 1, end)),\n            });\n        }\n    });\n    return highlightedNodes;\n}\nexport function getRange(location, queryText) {\n    const parser = onlineParser();\n    const state = parser.startState();\n    const lines = queryText.split('\\n');\n    invariant(lines.length >= location.line, 'Query text must have more lines than where the error happened');\n    let stream = null;\n    for (let i = 0; i < location.line; i++) {\n        stream = new CharacterStream(lines[i]);\n        while (!stream.eol()) {\n            const style = parser.token(stream, state);\n            if (style === 'invalidchar') {\n                break;\n            }\n        }\n    }\n    invariant(stream, 'Expected Parser stream to be available.');\n    const line = location.line - 1;\n    const start = stream.getStartOfToken();\n    const end = stream.getCurrentPosition();\n    return new Range(new Position(line, start), new Position(line, end));\n}\nfunction getLocation(node) {\n    const typeCastedNode = node;\n    const location = typeCastedNode.loc;\n    invariant(location, 'Expected ASTNode to have a location.');\n    return location;\n}\n//# sourceMappingURL=getDiagnostics.js.map"]},"metadata":{},"sourceType":"module"}