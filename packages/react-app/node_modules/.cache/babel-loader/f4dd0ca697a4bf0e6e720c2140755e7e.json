{"ast":null,"code":"// Extracted from https://github.com/ethereumjs/ethereumjs-util and stripped out irrelevant code\n// Original code licensed under the Mozilla Public License Version 2.0\nvar createKeccakHash = require('../keccak');\n\nvar BN = require('bn.js');\n/**\n * Returns a buffer filled with 0s\n * @method zeros\n * @param {Number} bytes  the number of bytes the buffer should be\n * @return {Buffer}\n */\n\n\nfunction zeros(bytes) {\n  return Buffer.allocUnsafe(bytes).fill(0);\n}\n/**\n * Left Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.\n * Or it truncates the beginning if it exceeds.\n * @method setLength\n * @param {Buffer|Array} msg the value to pad\n * @param {Number} length the number of bytes the output should be\n * @param {Boolean} [right=false] whether to start padding form the left or right\n * @return {Buffer|Array}\n */\n\n\nfunction setLength(msg, length, right) {\n  var buf = zeros(length);\n  msg = toBuffer(msg);\n\n  if (right) {\n    if (msg.length < length) {\n      msg.copy(buf);\n      return buf;\n    }\n\n    return msg.slice(0, length);\n  } else {\n    if (msg.length < length) {\n      msg.copy(buf, length - msg.length);\n      return buf;\n    }\n\n    return msg.slice(-length);\n  }\n}\n/**\n * Right Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.\n * Or it truncates the beginning if it exceeds.\n * @param {Buffer|Array} msg the value to pad\n * @param {Number} length the number of bytes the output should be\n * @return {Buffer|Array}\n */\n\n\nfunction setLengthRight(msg, length) {\n  return setLength(msg, length, true);\n}\n/**\n * Attempts to turn a value into a `Buffer`. As input it supports `Buffer`, `String`, `Number`, null/undefined, `BN` and other objects with a `toArray()` method.\n * @param {*} v the value\n */\n\n\nfunction toBuffer(v) {\n  if (!Buffer.isBuffer(v)) {\n    if (Array.isArray(v)) {\n      v = Buffer.from(v);\n    } else if (typeof v === 'string') {\n      if (isHexString(v)) {\n        v = Buffer.from(padToEven(stripHexPrefix(v)), 'hex');\n      } else {\n        v = Buffer.from(v);\n      }\n    } else if (typeof v === 'number') {\n      v = intToBuffer(v);\n    } else if (v === null || v === undefined) {\n      v = Buffer.allocUnsafe(0);\n    } else if (BN.isBN(v)) {\n      v = v.toArrayLike(Buffer);\n    } else if (v.toArray) {\n      // converts a BN to a Buffer\n      v = Buffer.from(v.toArray());\n    } else {\n      throw new Error('invalid type');\n    }\n  }\n\n  return v;\n}\n/**\n * Converts a `Buffer` into a hex `String`\n * @param {Buffer} buf\n * @return {String}\n */\n\n\nfunction bufferToHex(buf) {\n  buf = toBuffer(buf);\n  return '0x' + buf.toString('hex');\n}\n/**\n * Creates Keccak hash of the input\n * @param {Buffer|Array|String|Number} a the input data\n * @param {Number} [bits=256] the Keccak width\n * @return {Buffer}\n */\n\n\nfunction keccak(a, bits) {\n  a = toBuffer(a);\n  if (!bits) bits = 256;\n  return createKeccakHash('keccak' + bits).update(a).digest();\n}\n\nfunction padToEven(str) {\n  return str.length % 2 ? '0' + str : str;\n}\n\nfunction isHexString(str) {\n  return typeof str === 'string' && str.match(/^0x[0-9A-Fa-f]*$/);\n}\n\nfunction stripHexPrefix(str) {\n  if (typeof str === 'string' && str.startsWith('0x')) {\n    return str.slice(2);\n  }\n\n  return str;\n}\n\nmodule.exports = {\n  zeros: zeros,\n  setLength: setLength,\n  setLengthRight: setLengthRight,\n  isHexString: isHexString,\n  stripHexPrefix: stripHexPrefix,\n  toBuffer: toBuffer,\n  bufferToHex: bufferToHex,\n  keccak: keccak\n};","map":{"version":3,"sources":["/Users/sam/Desktop/kiwik/node_modules/walletlink/dist/vendor-js/eth-eip712-util/util.js"],"names":["createKeccakHash","require","BN","zeros","bytes","Buffer","allocUnsafe","fill","setLength","msg","length","right","buf","toBuffer","copy","slice","setLengthRight","v","isBuffer","Array","isArray","from","isHexString","padToEven","stripHexPrefix","intToBuffer","undefined","isBN","toArrayLike","toArray","Error","bufferToHex","toString","keccak","a","bits","update","digest","str","match","startsWith","module","exports"],"mappings":"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","sourcesContent":["// Extracted from https://github.com/ethereumjs/ethereumjs-util and stripped out irrelevant code\n// Original code licensed under the Mozilla Public License Version 2.0\n\nconst createKeccakHash = require('../keccak')\nconst BN = require('bn.js')\n\n/**\n * Returns a buffer filled with 0s\n * @method zeros\n * @param {Number} bytes  the number of bytes the buffer should be\n * @return {Buffer}\n */\nfunction zeros (bytes) {\n  return Buffer.allocUnsafe(bytes).fill(0)\n}\n\n/**\n * Left Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.\n * Or it truncates the beginning if it exceeds.\n * @method setLength\n * @param {Buffer|Array} msg the value to pad\n * @param {Number} length the number of bytes the output should be\n * @param {Boolean} [right=false] whether to start padding form the left or right\n * @return {Buffer|Array}\n */\nfunction setLength (msg, length, right) {\n  const buf = zeros(length)\n  msg = toBuffer(msg)\n  if (right) {\n    if (msg.length < length) {\n      msg.copy(buf)\n      return buf\n    }\n    return msg.slice(0, length)\n  } else {\n    if (msg.length < length) {\n      msg.copy(buf, length - msg.length)\n      return buf\n    }\n    return msg.slice(-length)\n  }\n}\n\n/**\n * Right Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.\n * Or it truncates the beginning if it exceeds.\n * @param {Buffer|Array} msg the value to pad\n * @param {Number} length the number of bytes the output should be\n * @return {Buffer|Array}\n */\nfunction setLengthRight (msg, length) {\n  return setLength(msg, length, true)\n}\n\n/**\n * Attempts to turn a value into a `Buffer`. As input it supports `Buffer`, `String`, `Number`, null/undefined, `BN` and other objects with a `toArray()` method.\n * @param {*} v the value\n */\nfunction toBuffer (v) {\n  if (!Buffer.isBuffer(v)) {\n    if (Array.isArray(v)) {\n      v = Buffer.from(v)\n    } else if (typeof v === 'string') {\n      if (isHexString(v)) {\n        v = Buffer.from(padToEven(stripHexPrefix(v)), 'hex')\n      } else {\n        v = Buffer.from(v)\n      }\n    } else if (typeof v === 'number') {\n      v = intToBuffer(v)\n    } else if (v === null || v === undefined) {\n      v = Buffer.allocUnsafe(0)\n    } else if (BN.isBN(v)) {\n      v = v.toArrayLike(Buffer)\n    } else if (v.toArray) {\n      // converts a BN to a Buffer\n      v = Buffer.from(v.toArray())\n    } else {\n      throw new Error('invalid type')\n    }\n  }\n  return v\n}\n\n/**\n * Converts a `Buffer` into a hex `String`\n * @param {Buffer} buf\n * @return {String}\n */\nfunction bufferToHex (buf) {\n  buf = toBuffer(buf)\n  return '0x' + buf.toString('hex')\n}\n\n/**\n * Creates Keccak hash of the input\n * @param {Buffer|Array|String|Number} a the input data\n * @param {Number} [bits=256] the Keccak width\n * @return {Buffer}\n */\nfunction keccak (a, bits) {\n  a = toBuffer(a)\n  if (!bits) bits = 256\n\n  return createKeccakHash('keccak' + bits).update(a).digest()\n}\n\nfunction padToEven (str) {\n  return str.length % 2 ? '0' + str : str\n}\n\nfunction isHexString (str) {\n  return typeof str === 'string' && str.match(/^0x[0-9A-Fa-f]*$/)\n}\n\nfunction stripHexPrefix (str) {\n  if (typeof str === 'string' && str.startsWith('0x')) {\n    return str.slice(2)\n  }\n  return str\n}\n\nmodule.exports = {\n  zeros,\n  setLength,\n  setLengthRight,\n  isHexString,\n  stripHexPrefix,\n  toBuffer,\n  bufferToHex,\n  keccak\n}\n"]},"metadata":{},"sourceType":"script"}