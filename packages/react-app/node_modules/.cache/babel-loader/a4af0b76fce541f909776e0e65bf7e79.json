{"ast":null,"code":"/**\n * class Ruler\n *\n * Helper class, used by [[MarkdownIt#core]], [[MarkdownIt#block]] and\n * [[MarkdownIt#inline]] to manage sequences of functions (rules):\n *\n * - keep rules in defined order\n * - assign the name to each rule\n * - enable/disable rules\n * - add/replace rules\n * - allow assign rules to additional named chains (in the same)\n * - cacheing lists of active rules\n *\n * You will not need use this class directly until write plugins. For simple\n * rules control use [[MarkdownIt.disable]], [[MarkdownIt.enable]] and\n * [[MarkdownIt.use]].\n **/\n'use strict';\n/**\n * new Ruler()\n **/\n\nfunction Ruler() {\n  // List of added rules. Each element is:\n  //\n  // {\n  //   name: XXX,\n  //   enabled: Boolean,\n  //   fn: Function(),\n  //   alt: [ name2, name3 ]\n  // }\n  //\n  this.__rules__ = []; // Cached rule chains.\n  //\n  // First level - chain name, '' for default.\n  // Second level - diginal anchor for fast filtering by charcodes.\n  //\n\n  this.__cache__ = null;\n} ////////////////////////////////////////////////////////////////////////////////\n// Helper methods, should not be used directly\n// Find rule index by name\n//\n\n\nRuler.prototype.__find__ = function (name) {\n  for (var i = 0; i < this.__rules__.length; i++) {\n    if (this.__rules__[i].name === name) {\n      return i;\n    }\n  }\n\n  return -1;\n}; // Build rules lookup cache\n//\n\n\nRuler.prototype.__compile__ = function () {\n  var self = this;\n  var chains = ['']; // collect unique names\n\n  self.__rules__.forEach(function (rule) {\n    if (!rule.enabled) {\n      return;\n    }\n\n    rule.alt.forEach(function (altName) {\n      if (chains.indexOf(altName) < 0) {\n        chains.push(altName);\n      }\n    });\n  });\n\n  self.__cache__ = {};\n  chains.forEach(function (chain) {\n    self.__cache__[chain] = [];\n\n    self.__rules__.forEach(function (rule) {\n      if (!rule.enabled) {\n        return;\n      }\n\n      if (chain && rule.alt.indexOf(chain) < 0) {\n        return;\n      }\n\n      self.__cache__[chain].push(rule.fn);\n    });\n  });\n};\n/**\n * Ruler.at(name, fn [, options])\n * - name (String): rule name to replace.\n * - fn (Function): new rule function.\n * - options (Object): new rule options (not mandatory).\n *\n * Replace rule by name with new function & options. Throws error if name not\n * found.\n *\n * ##### Options:\n *\n * - __alt__ - array with names of \"alternate\" chains.\n *\n * ##### Example\n *\n * Replace existing typographer replacement rule with new one:\n *\n * ```javascript\n * var md = require('markdown-it')();\n *\n * md.core.ruler.at('replacements', function replace(state) {\n *   //...\n * });\n * ```\n **/\n\n\nRuler.prototype.at = function (name, fn, options) {\n  var index = this.__find__(name);\n\n  var opt = options || {};\n\n  if (index === -1) {\n    throw new Error('Parser rule not found: ' + name);\n  }\n\n  this.__rules__[index].fn = fn;\n  this.__rules__[index].alt = opt.alt || [];\n  this.__cache__ = null;\n};\n/**\n * Ruler.before(beforeName, ruleName, fn [, options])\n * - beforeName (String): new rule will be added before this one.\n * - ruleName (String): name of added rule.\n * - fn (Function): rule function.\n * - options (Object): rule options (not mandatory).\n *\n * Add new rule to chain before one with given name. See also\n * [[Ruler.after]], [[Ruler.push]].\n *\n * ##### Options:\n *\n * - __alt__ - array with names of \"alternate\" chains.\n *\n * ##### Example\n *\n * ```javascript\n * var md = require('markdown-it')();\n *\n * md.block.ruler.before('paragraph', 'my_rule', function replace(state) {\n *   //...\n * });\n * ```\n **/\n\n\nRuler.prototype.before = function (beforeName, ruleName, fn, options) {\n  var index = this.__find__(beforeName);\n\n  var opt = options || {};\n\n  if (index === -1) {\n    throw new Error('Parser rule not found: ' + beforeName);\n  }\n\n  this.__rules__.splice(index, 0, {\n    name: ruleName,\n    enabled: true,\n    fn: fn,\n    alt: opt.alt || []\n  });\n\n  this.__cache__ = null;\n};\n/**\n * Ruler.after(afterName, ruleName, fn [, options])\n * - afterName (String): new rule will be added after this one.\n * - ruleName (String): name of added rule.\n * - fn (Function): rule function.\n * - options (Object): rule options (not mandatory).\n *\n * Add new rule to chain after one with given name. See also\n * [[Ruler.before]], [[Ruler.push]].\n *\n * ##### Options:\n *\n * - __alt__ - array with names of \"alternate\" chains.\n *\n * ##### Example\n *\n * ```javascript\n * var md = require('markdown-it')();\n *\n * md.inline.ruler.after('text', 'my_rule', function replace(state) {\n *   //...\n * });\n * ```\n **/\n\n\nRuler.prototype.after = function (afterName, ruleName, fn, options) {\n  var index = this.__find__(afterName);\n\n  var opt = options || {};\n\n  if (index === -1) {\n    throw new Error('Parser rule not found: ' + afterName);\n  }\n\n  this.__rules__.splice(index + 1, 0, {\n    name: ruleName,\n    enabled: true,\n    fn: fn,\n    alt: opt.alt || []\n  });\n\n  this.__cache__ = null;\n};\n/**\n * Ruler.push(ruleName, fn [, options])\n * - ruleName (String): name of added rule.\n * - fn (Function): rule function.\n * - options (Object): rule options (not mandatory).\n *\n * Push new rule to the end of chain. See also\n * [[Ruler.before]], [[Ruler.after]].\n *\n * ##### Options:\n *\n * - __alt__ - array with names of \"alternate\" chains.\n *\n * ##### Example\n *\n * ```javascript\n * var md = require('markdown-it')();\n *\n * md.core.ruler.push('my_rule', function replace(state) {\n *   //...\n * });\n * ```\n **/\n\n\nRuler.prototype.push = function (ruleName, fn, options) {\n  var opt = options || {};\n\n  this.__rules__.push({\n    name: ruleName,\n    enabled: true,\n    fn: fn,\n    alt: opt.alt || []\n  });\n\n  this.__cache__ = null;\n};\n/**\n * Ruler.enable(list [, ignoreInvalid]) -> Array\n * - list (String|Array): list of rule names to enable.\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n *\n * Enable rules with given names. If any rule name not found - throw Error.\n * Errors can be disabled by second param.\n *\n * Returns list of found rule names (if no exception happened).\n *\n * See also [[Ruler.disable]], [[Ruler.enableOnly]].\n **/\n\n\nRuler.prototype.enable = function (list, ignoreInvalid) {\n  if (!Array.isArray(list)) {\n    list = [list];\n  }\n\n  var result = []; // Search by name and enable\n\n  list.forEach(function (name) {\n    var idx = this.__find__(name);\n\n    if (idx < 0) {\n      if (ignoreInvalid) {\n        return;\n      }\n\n      throw new Error('Rules manager: invalid rule name ' + name);\n    }\n\n    this.__rules__[idx].enabled = true;\n    result.push(name);\n  }, this);\n  this.__cache__ = null;\n  return result;\n};\n/**\n * Ruler.enableOnly(list [, ignoreInvalid])\n * - list (String|Array): list of rule names to enable (whitelist).\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n *\n * Enable rules with given names, and disable everything else. If any rule name\n * not found - throw Error. Errors can be disabled by second param.\n *\n * See also [[Ruler.disable]], [[Ruler.enable]].\n **/\n\n\nRuler.prototype.enableOnly = function (list, ignoreInvalid) {\n  if (!Array.isArray(list)) {\n    list = [list];\n  }\n\n  this.__rules__.forEach(function (rule) {\n    rule.enabled = false;\n  });\n\n  this.enable(list, ignoreInvalid);\n};\n/**\n * Ruler.disable(list [, ignoreInvalid]) -> Array\n * - list (String|Array): list of rule names to disable.\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n *\n * Disable rules with given names. If any rule name not found - throw Error.\n * Errors can be disabled by second param.\n *\n * Returns list of found rule names (if no exception happened).\n *\n * See also [[Ruler.enable]], [[Ruler.enableOnly]].\n **/\n\n\nRuler.prototype.disable = function (list, ignoreInvalid) {\n  if (!Array.isArray(list)) {\n    list = [list];\n  }\n\n  var result = []; // Search by name and disable\n\n  list.forEach(function (name) {\n    var idx = this.__find__(name);\n\n    if (idx < 0) {\n      if (ignoreInvalid) {\n        return;\n      }\n\n      throw new Error('Rules manager: invalid rule name ' + name);\n    }\n\n    this.__rules__[idx].enabled = false;\n    result.push(name);\n  }, this);\n  this.__cache__ = null;\n  return result;\n};\n/**\n * Ruler.getRules(chainName) -> Array\n *\n * Return array of active functions (rules) for given chain name. It analyzes\n * rules configuration, compiles caches if not exists and returns result.\n *\n * Default chain name is `''` (empty string). It can't be skipped. That's\n * done intentionally, to keep signature monomorphic for high speed.\n **/\n\n\nRuler.prototype.getRules = function (chainName) {\n  if (this.__cache__ === null) {\n    this.__compile__();\n  } // Chain can be empty, if rules disabled. But we still have to return Array.\n\n\n  return this.__cache__[chainName] || [];\n};\n\nmodule.exports = Ruler;","map":{"version":3,"sources":["/Users/sam/Desktop/kiwik/node_modules/markdown-it/lib/ruler.js"],"names":["Ruler","__rules__","__cache__","prototype","__find__","name","i","length","__compile__","self","chains","forEach","rule","enabled","alt","altName","indexOf","push","chain","fn","at","options","index","opt","Error","before","beforeName","ruleName","splice","after","afterName","enable","list","ignoreInvalid","Array","isArray","result","idx","enableOnly","disable","getRules","chainName","module","exports"],"mappings":"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","sourcesContent":["/**\n * class Ruler\n *\n * Helper class, used by [[MarkdownIt#core]], [[MarkdownIt#block]] and\n * [[MarkdownIt#inline]] to manage sequences of functions (rules):\n *\n * - keep rules in defined order\n * - assign the name to each rule\n * - enable/disable rules\n * - add/replace rules\n * - allow assign rules to additional named chains (in the same)\n * - cacheing lists of active rules\n *\n * You will not need use this class directly until write plugins. For simple\n * rules control use [[MarkdownIt.disable]], [[MarkdownIt.enable]] and\n * [[MarkdownIt.use]].\n **/\n'use strict';\n\n\n/**\n * new Ruler()\n **/\nfunction Ruler() {\n  // List of added rules. Each element is:\n  //\n  // {\n  //   name: XXX,\n  //   enabled: Boolean,\n  //   fn: Function(),\n  //   alt: [ name2, name3 ]\n  // }\n  //\n  this.__rules__ = [];\n\n  // Cached rule chains.\n  //\n  // First level - chain name, '' for default.\n  // Second level - diginal anchor for fast filtering by charcodes.\n  //\n  this.__cache__ = null;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Helper methods, should not be used directly\n\n\n// Find rule index by name\n//\nRuler.prototype.__find__ = function (name) {\n  for (var i = 0; i < this.__rules__.length; i++) {\n    if (this.__rules__[i].name === name) {\n      return i;\n    }\n  }\n  return -1;\n};\n\n\n// Build rules lookup cache\n//\nRuler.prototype.__compile__ = function () {\n  var self = this;\n  var chains = [ '' ];\n\n  // collect unique names\n  self.__rules__.forEach(function (rule) {\n    if (!rule.enabled) { return; }\n\n    rule.alt.forEach(function (altName) {\n      if (chains.indexOf(altName) < 0) {\n        chains.push(altName);\n      }\n    });\n  });\n\n  self.__cache__ = {};\n\n  chains.forEach(function (chain) {\n    self.__cache__[chain] = [];\n    self.__rules__.forEach(function (rule) {\n      if (!rule.enabled) { return; }\n\n      if (chain && rule.alt.indexOf(chain) < 0) { return; }\n\n      self.__cache__[chain].push(rule.fn);\n    });\n  });\n};\n\n\n/**\n * Ruler.at(name, fn [, options])\n * - name (String): rule name to replace.\n * - fn (Function): new rule function.\n * - options (Object): new rule options (not mandatory).\n *\n * Replace rule by name with new function & options. Throws error if name not\n * found.\n *\n * ##### Options:\n *\n * - __alt__ - array with names of \"alternate\" chains.\n *\n * ##### Example\n *\n * Replace existing typographer replacement rule with new one:\n *\n * ```javascript\n * var md = require('markdown-it')();\n *\n * md.core.ruler.at('replacements', function replace(state) {\n *   //...\n * });\n * ```\n **/\nRuler.prototype.at = function (name, fn, options) {\n  var index = this.__find__(name);\n  var opt = options || {};\n\n  if (index === -1) { throw new Error('Parser rule not found: ' + name); }\n\n  this.__rules__[index].fn = fn;\n  this.__rules__[index].alt = opt.alt || [];\n  this.__cache__ = null;\n};\n\n\n/**\n * Ruler.before(beforeName, ruleName, fn [, options])\n * - beforeName (String): new rule will be added before this one.\n * - ruleName (String): name of added rule.\n * - fn (Function): rule function.\n * - options (Object): rule options (not mandatory).\n *\n * Add new rule to chain before one with given name. See also\n * [[Ruler.after]], [[Ruler.push]].\n *\n * ##### Options:\n *\n * - __alt__ - array with names of \"alternate\" chains.\n *\n * ##### Example\n *\n * ```javascript\n * var md = require('markdown-it')();\n *\n * md.block.ruler.before('paragraph', 'my_rule', function replace(state) {\n *   //...\n * });\n * ```\n **/\nRuler.prototype.before = function (beforeName, ruleName, fn, options) {\n  var index = this.__find__(beforeName);\n  var opt = options || {};\n\n  if (index === -1) { throw new Error('Parser rule not found: ' + beforeName); }\n\n  this.__rules__.splice(index, 0, {\n    name: ruleName,\n    enabled: true,\n    fn: fn,\n    alt: opt.alt || []\n  });\n\n  this.__cache__ = null;\n};\n\n\n/**\n * Ruler.after(afterName, ruleName, fn [, options])\n * - afterName (String): new rule will be added after this one.\n * - ruleName (String): name of added rule.\n * - fn (Function): rule function.\n * - options (Object): rule options (not mandatory).\n *\n * Add new rule to chain after one with given name. See also\n * [[Ruler.before]], [[Ruler.push]].\n *\n * ##### Options:\n *\n * - __alt__ - array with names of \"alternate\" chains.\n *\n * ##### Example\n *\n * ```javascript\n * var md = require('markdown-it')();\n *\n * md.inline.ruler.after('text', 'my_rule', function replace(state) {\n *   //...\n * });\n * ```\n **/\nRuler.prototype.after = function (afterName, ruleName, fn, options) {\n  var index = this.__find__(afterName);\n  var opt = options || {};\n\n  if (index === -1) { throw new Error('Parser rule not found: ' + afterName); }\n\n  this.__rules__.splice(index + 1, 0, {\n    name: ruleName,\n    enabled: true,\n    fn: fn,\n    alt: opt.alt || []\n  });\n\n  this.__cache__ = null;\n};\n\n/**\n * Ruler.push(ruleName, fn [, options])\n * - ruleName (String): name of added rule.\n * - fn (Function): rule function.\n * - options (Object): rule options (not mandatory).\n *\n * Push new rule to the end of chain. See also\n * [[Ruler.before]], [[Ruler.after]].\n *\n * ##### Options:\n *\n * - __alt__ - array with names of \"alternate\" chains.\n *\n * ##### Example\n *\n * ```javascript\n * var md = require('markdown-it')();\n *\n * md.core.ruler.push('my_rule', function replace(state) {\n *   //...\n * });\n * ```\n **/\nRuler.prototype.push = function (ruleName, fn, options) {\n  var opt = options || {};\n\n  this.__rules__.push({\n    name: ruleName,\n    enabled: true,\n    fn: fn,\n    alt: opt.alt || []\n  });\n\n  this.__cache__ = null;\n};\n\n\n/**\n * Ruler.enable(list [, ignoreInvalid]) -> Array\n * - list (String|Array): list of rule names to enable.\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n *\n * Enable rules with given names. If any rule name not found - throw Error.\n * Errors can be disabled by second param.\n *\n * Returns list of found rule names (if no exception happened).\n *\n * See also [[Ruler.disable]], [[Ruler.enableOnly]].\n **/\nRuler.prototype.enable = function (list, ignoreInvalid) {\n  if (!Array.isArray(list)) { list = [ list ]; }\n\n  var result = [];\n\n  // Search by name and enable\n  list.forEach(function (name) {\n    var idx = this.__find__(name);\n\n    if (idx < 0) {\n      if (ignoreInvalid) { return; }\n      throw new Error('Rules manager: invalid rule name ' + name);\n    }\n    this.__rules__[idx].enabled = true;\n    result.push(name);\n  }, this);\n\n  this.__cache__ = null;\n  return result;\n};\n\n\n/**\n * Ruler.enableOnly(list [, ignoreInvalid])\n * - list (String|Array): list of rule names to enable (whitelist).\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n *\n * Enable rules with given names, and disable everything else. If any rule name\n * not found - throw Error. Errors can be disabled by second param.\n *\n * See also [[Ruler.disable]], [[Ruler.enable]].\n **/\nRuler.prototype.enableOnly = function (list, ignoreInvalid) {\n  if (!Array.isArray(list)) { list = [ list ]; }\n\n  this.__rules__.forEach(function (rule) { rule.enabled = false; });\n\n  this.enable(list, ignoreInvalid);\n};\n\n\n/**\n * Ruler.disable(list [, ignoreInvalid]) -> Array\n * - list (String|Array): list of rule names to disable.\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n *\n * Disable rules with given names. If any rule name not found - throw Error.\n * Errors can be disabled by second param.\n *\n * Returns list of found rule names (if no exception happened).\n *\n * See also [[Ruler.enable]], [[Ruler.enableOnly]].\n **/\nRuler.prototype.disable = function (list, ignoreInvalid) {\n  if (!Array.isArray(list)) { list = [ list ]; }\n\n  var result = [];\n\n  // Search by name and disable\n  list.forEach(function (name) {\n    var idx = this.__find__(name);\n\n    if (idx < 0) {\n      if (ignoreInvalid) { return; }\n      throw new Error('Rules manager: invalid rule name ' + name);\n    }\n    this.__rules__[idx].enabled = false;\n    result.push(name);\n  }, this);\n\n  this.__cache__ = null;\n  return result;\n};\n\n\n/**\n * Ruler.getRules(chainName) -> Array\n *\n * Return array of active functions (rules) for given chain name. It analyzes\n * rules configuration, compiles caches if not exists and returns result.\n *\n * Default chain name is `''` (empty string). It can't be skipped. That's\n * done intentionally, to keep signature monomorphic for high speed.\n **/\nRuler.prototype.getRules = function (chainName) {\n  if (this.__cache__ === null) {\n    this.__compile__();\n  }\n\n  // Chain can be empty, if rules disabled. But we still have to return Array.\n  return this.__cache__[chainName] || [];\n};\n\nmodule.exports = Ruler;\n"]},"metadata":{},"sourceType":"script"}