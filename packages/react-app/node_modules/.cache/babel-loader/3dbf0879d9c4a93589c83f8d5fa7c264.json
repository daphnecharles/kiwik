{"ast":null,"code":"import { keccak_256 } from \"js-sha3\";\nimport { removeHexPrefix, addHexPrefix } from \"@walletconnect/encoding\";\nimport { convertUtf8ToHex, convertNumberToHex, convertUtf8ToBuffer } from \"./encoding\";\nimport { sanitizeHex, removeHexLeadingZeros } from \"./misc\";\nimport { isEmptyArray, isHexString, isEmptyString } from \"./validators\";\nexport function toChecksumAddress(address) {\n  address = removeHexPrefix(address.toLowerCase());\n  var hash = removeHexPrefix(keccak_256(convertUtf8ToBuffer(address)));\n  var checksum = \"\";\n\n  for (var i = 0; i < address.length; i++) {\n    if (parseInt(hash[i], 16) > 7) {\n      checksum += address[i].toUpperCase();\n    } else {\n      checksum += address[i];\n    }\n  }\n\n  return addHexPrefix(checksum);\n}\nexport var isValidAddress = function isValidAddress(address) {\n  if (!address) {\n    return false;\n  } else if (address.toLowerCase().substring(0, 2) !== \"0x\") {\n    return false;\n  } else if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {\n    return false;\n  } else if (/^(0x)?[0-9a-f]{40}$/.test(address) || /^(0x)?[0-9A-F]{40}$/.test(address)) {\n    return true;\n  } else {\n    return address === toChecksumAddress(address);\n  }\n};\nexport function parsePersonalSign(params) {\n  if (!isEmptyArray(params) && !isHexString(params[0])) {\n    params[0] = convertUtf8ToHex(params[0]);\n  }\n\n  return params;\n}\nexport function parseTransactionData(txData) {\n  if (typeof txData.from === \"undefined\" || !isValidAddress(txData.from)) {\n    throw new Error(\"Transaction object must include a valid 'from' value.\");\n  }\n\n  function parseHexValues(value) {\n    var result = value;\n\n    if (typeof value === \"number\" || typeof value === \"string\" && !isEmptyString(value)) {\n      if (!isHexString(value)) {\n        result = convertNumberToHex(value);\n      } else if (typeof value === \"string\") {\n        result = sanitizeHex(value);\n      }\n    }\n\n    if (typeof result === \"string\") {\n      result = removeHexLeadingZeros(result);\n    }\n\n    return result;\n  }\n\n  var txDataRPC = {\n    from: sanitizeHex(txData.from),\n    to: typeof txData.to === \"undefined\" ? \"\" : sanitizeHex(txData.to),\n    gasPrice: typeof txData.gasPrice === \"undefined\" ? \"\" : parseHexValues(txData.gasPrice),\n    gas: typeof txData.gas === \"undefined\" ? typeof txData.gasLimit === \"undefined\" ? \"\" : parseHexValues(txData.gasLimit) : parseHexValues(txData.gas),\n    value: typeof txData.value === \"undefined\" ? \"\" : parseHexValues(txData.value),\n    nonce: typeof txData.nonce === \"undefined\" ? \"\" : parseHexValues(txData.nonce),\n    data: typeof txData.data === \"undefined\" ? \"\" : sanitizeHex(txData.data) || \"0x\"\n  };\n  var prunable = [\"gasPrice\", \"gas\", \"value\", \"nonce\"];\n  Object.keys(txDataRPC).forEach(function (key) {\n    if (!txDataRPC[key].trim().length && prunable.includes(key)) {\n      delete txDataRPC[key];\n    }\n  });\n  return txDataRPC;\n}","map":{"version":3,"sources":["../../src/ethereum.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { keccak_256 } from \"js-sha3\";\nimport { removeHexPrefix, addHexPrefix } from \"@walletconnect/encoding\";\nimport { convertUtf8ToHex, convertNumberToHex, convertUtf8ToBuffer } from \"./encoding\";\nimport { sanitizeHex, removeHexLeadingZeros } from \"./misc\";\nimport { isEmptyArray, isHexString, isEmptyString } from \"./validators\";\nexport function toChecksumAddress(address) {\n    address = removeHexPrefix(address.toLowerCase());\n    const hash = removeHexPrefix(keccak_256(convertUtf8ToBuffer(address)));\n    let checksum = \"\";\n    for (let i = 0; i < address.length; i++) {\n        if (parseInt(hash[i], 16) > 7) {\n            checksum += address[i].toUpperCase();\n        }\n        else {\n            checksum += address[i];\n        }\n    }\n    return addHexPrefix(checksum);\n}\nexport const isValidAddress = (address) => {\n    if (!address) {\n        return false;\n    }\n    else if (address.toLowerCase().substring(0, 2) !== \"0x\") {\n        return false;\n    }\n    else if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {\n        return false;\n    }\n    else if (/^(0x)?[0-9a-f]{40}$/.test(address) || /^(0x)?[0-9A-F]{40}$/.test(address)) {\n        return true;\n    }\n    else {\n        return address === toChecksumAddress(address);\n    }\n};\nexport function parsePersonalSign(params) {\n    if (!isEmptyArray(params) && !isHexString(params[0])) {\n        params[0] = convertUtf8ToHex(params[0]);\n    }\n    return params;\n}\nexport function parseTransactionData(txData) {\n    if (typeof txData.from === \"undefined\" || !isValidAddress(txData.from)) {\n        throw new Error(`Transaction object must include a valid 'from' value.`);\n    }\n    function parseHexValues(value) {\n        let result = value;\n        if (typeof value === \"number\" || (typeof value === \"string\" && !isEmptyString(value))) {\n            if (!isHexString(value)) {\n                result = convertNumberToHex(value);\n            }\n            else if (typeof value === \"string\") {\n                result = sanitizeHex(value);\n            }\n        }\n        if (typeof result === \"string\") {\n            result = removeHexLeadingZeros(result);\n        }\n        return result;\n    }\n    const txDataRPC = {\n        from: sanitizeHex(txData.from),\n        to: typeof txData.to === \"undefined\" ? \"\" : sanitizeHex(txData.to),\n        gasPrice: typeof txData.gasPrice === \"undefined\" ? \"\" : parseHexValues(txData.gasPrice),\n        gas: typeof txData.gas === \"undefined\"\n            ? typeof txData.gasLimit === \"undefined\"\n                ? \"\"\n                : parseHexValues(txData.gasLimit)\n            : parseHexValues(txData.gas),\n        value: typeof txData.value === \"undefined\" ? \"\" : parseHexValues(txData.value),\n        nonce: typeof txData.nonce === \"undefined\" ? \"\" : parseHexValues(txData.nonce),\n        data: typeof txData.data === \"undefined\" ? \"\" : sanitizeHex(txData.data) || \"0x\",\n    };\n    const prunable = [\"gasPrice\", \"gas\", \"value\", \"nonce\"];\n    Object.keys(txDataRPC).forEach((key) => {\n        if (!txDataRPC[key].trim().length && prunable.includes(key)) {\n            delete txDataRPC[key];\n        }\n    });\n    return txDataRPC;\n}\n//# sourceMappingURL=ethereum.js.map"]},"metadata":{},"sourceType":"module"}