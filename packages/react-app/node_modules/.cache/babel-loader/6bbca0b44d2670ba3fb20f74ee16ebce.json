{"ast":null,"code":"/** internal\n * class ParserBlock\n *\n * Block-level tokenizer.\n **/\n'use strict';\n\nvar Ruler = require('./ruler');\n\nvar _rules = [// First 2 params - rule name & source. Secondary array - list of rules,\n// which can be terminated by this one.\n['table', require('./rules_block/table'), ['paragraph', 'reference']], ['code', require('./rules_block/code')], ['fence', require('./rules_block/fence'), ['paragraph', 'reference', 'blockquote', 'list']], ['blockquote', require('./rules_block/blockquote'), ['paragraph', 'reference', 'blockquote', 'list']], ['hr', require('./rules_block/hr'), ['paragraph', 'reference', 'blockquote', 'list']], ['list', require('./rules_block/list'), ['paragraph', 'reference', 'blockquote']], ['reference', require('./rules_block/reference')], ['html_block', require('./rules_block/html_block'), ['paragraph', 'reference', 'blockquote']], ['heading', require('./rules_block/heading'), ['paragraph', 'reference', 'blockquote']], ['lheading', require('./rules_block/lheading')], ['paragraph', require('./rules_block/paragraph')]];\n/**\n * new ParserBlock()\n **/\n\nfunction ParserBlock() {\n  /**\n   * ParserBlock#ruler -> Ruler\n   *\n   * [[Ruler]] instance. Keep configuration of block rules.\n   **/\n  this.ruler = new Ruler();\n\n  for (var i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1], {\n      alt: (_rules[i][2] || []).slice()\n    });\n  }\n} // Generate tokens for input range\n//\n\n\nParserBlock.prototype.tokenize = function (state, startLine, endLine) {\n  var ok,\n      i,\n      rules = this.ruler.getRules(''),\n      len = rules.length,\n      line = startLine,\n      hasEmptyLines = false,\n      maxNesting = state.md.options.maxNesting;\n\n  while (line < endLine) {\n    state.line = line = state.skipEmptyLines(line);\n\n    if (line >= endLine) {\n      break;\n    } // Termination condition for nested calls.\n    // Nested calls currently used for blockquotes & lists\n\n\n    if (state.sCount[line] < state.blkIndent) {\n      break;\n    } // If nesting level exceeded - skip tail to the end. That's not ordinary\n    // situation and we should not care about content.\n\n\n    if (state.level >= maxNesting) {\n      state.line = endLine;\n      break;\n    } // Try all possible rules.\n    // On success, rule should:\n    //\n    // - update `state.line`\n    // - update `state.tokens`\n    // - return true\n\n\n    for (i = 0; i < len; i++) {\n      ok = rules[i](state, line, endLine, false);\n\n      if (ok) {\n        break;\n      }\n    } // set state.tight if we had an empty line before current tag\n    // i.e. latest empty line should not count\n\n\n    state.tight = !hasEmptyLines; // paragraph might \"eat\" one newline after it in nested lists\n\n    if (state.isEmpty(state.line - 1)) {\n      hasEmptyLines = true;\n    }\n\n    line = state.line;\n\n    if (line < endLine && state.isEmpty(line)) {\n      hasEmptyLines = true;\n      line++;\n      state.line = line;\n    }\n  }\n};\n/**\n * ParserBlock.parse(str, md, env, outTokens)\n *\n * Process input string and push block tokens into `outTokens`\n **/\n\n\nParserBlock.prototype.parse = function (src, md, env, outTokens) {\n  var state;\n\n  if (!src) {\n    return;\n  }\n\n  state = new this.State(src, md, env, outTokens);\n  this.tokenize(state, state.line, state.lineMax);\n};\n\nParserBlock.prototype.State = require('./rules_block/state_block');\nmodule.exports = ParserBlock;","map":{"version":3,"sources":["/Users/sam/Desktop/kiwik/node_modules/markdown-it/lib/parser_block.js"],"names":["Ruler","require","_rules","ParserBlock","ruler","i","length","push","alt","slice","prototype","tokenize","state","startLine","endLine","ok","rules","getRules","len","line","hasEmptyLines","maxNesting","md","options","skipEmptyLines","sCount","blkIndent","level","tight","isEmpty","parse","src","env","outTokens","State","lineMax","module","exports"],"mappings":"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","sourcesContent":["/** internal\n * class ParserBlock\n *\n * Block-level tokenizer.\n **/\n'use strict';\n\n\nvar Ruler           = require('./ruler');\n\n\nvar _rules = [\n  // First 2 params - rule name & source. Secondary array - list of rules,\n  // which can be terminated by this one.\n  [ 'table',      require('./rules_block/table'),      [ 'paragraph', 'reference' ] ],\n  [ 'code',       require('./rules_block/code') ],\n  [ 'fence',      require('./rules_block/fence'),      [ 'paragraph', 'reference', 'blockquote', 'list' ] ],\n  [ 'blockquote', require('./rules_block/blockquote'), [ 'paragraph', 'reference', 'blockquote', 'list' ] ],\n  [ 'hr',         require('./rules_block/hr'),         [ 'paragraph', 'reference', 'blockquote', 'list' ] ],\n  [ 'list',       require('./rules_block/list'),       [ 'paragraph', 'reference', 'blockquote' ] ],\n  [ 'reference',  require('./rules_block/reference') ],\n  [ 'html_block', require('./rules_block/html_block'), [ 'paragraph', 'reference', 'blockquote' ] ],\n  [ 'heading',    require('./rules_block/heading'),    [ 'paragraph', 'reference', 'blockquote' ] ],\n  [ 'lheading',   require('./rules_block/lheading') ],\n  [ 'paragraph',  require('./rules_block/paragraph') ]\n];\n\n\n/**\n * new ParserBlock()\n **/\nfunction ParserBlock() {\n  /**\n   * ParserBlock#ruler -> Ruler\n   *\n   * [[Ruler]] instance. Keep configuration of block rules.\n   **/\n  this.ruler = new Ruler();\n\n  for (var i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() });\n  }\n}\n\n\n// Generate tokens for input range\n//\nParserBlock.prototype.tokenize = function (state, startLine, endLine) {\n  var ok, i,\n      rules = this.ruler.getRules(''),\n      len = rules.length,\n      line = startLine,\n      hasEmptyLines = false,\n      maxNesting = state.md.options.maxNesting;\n\n  while (line < endLine) {\n    state.line = line = state.skipEmptyLines(line);\n    if (line >= endLine) { break; }\n\n    // Termination condition for nested calls.\n    // Nested calls currently used for blockquotes & lists\n    if (state.sCount[line] < state.blkIndent) { break; }\n\n    // If nesting level exceeded - skip tail to the end. That's not ordinary\n    // situation and we should not care about content.\n    if (state.level >= maxNesting) {\n      state.line = endLine;\n      break;\n    }\n\n    // Try all possible rules.\n    // On success, rule should:\n    //\n    // - update `state.line`\n    // - update `state.tokens`\n    // - return true\n\n    for (i = 0; i < len; i++) {\n      ok = rules[i](state, line, endLine, false);\n      if (ok) { break; }\n    }\n\n    // set state.tight if we had an empty line before current tag\n    // i.e. latest empty line should not count\n    state.tight = !hasEmptyLines;\n\n    // paragraph might \"eat\" one newline after it in nested lists\n    if (state.isEmpty(state.line - 1)) {\n      hasEmptyLines = true;\n    }\n\n    line = state.line;\n\n    if (line < endLine && state.isEmpty(line)) {\n      hasEmptyLines = true;\n      line++;\n      state.line = line;\n    }\n  }\n};\n\n\n/**\n * ParserBlock.parse(str, md, env, outTokens)\n *\n * Process input string and push block tokens into `outTokens`\n **/\nParserBlock.prototype.parse = function (src, md, env, outTokens) {\n  var state;\n\n  if (!src) { return; }\n\n  state = new this.State(src, md, env, outTokens);\n\n  this.tokenize(state, state.line, state.lineMax);\n};\n\n\nParserBlock.prototype.State = require('./rules_block/state_block');\n\n\nmodule.exports = ParserBlock;\n"]},"metadata":{},"sourceType":"script"}