{"ast":null,"code":"import _classCallCheck from \"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { deepCopy } from \"@ethersproject/properties\";\nimport { fetchJson } from \"@ethersproject/web\";\nimport { JsonRpcProvider } from \"./json-rpc-provider\"; // Experimental\n\nexport var JsonRpcBatchProvider = /*#__PURE__*/function (_JsonRpcProvider) {\n  _inherits(JsonRpcBatchProvider, _JsonRpcProvider);\n\n  var _super = _createSuper(JsonRpcBatchProvider);\n\n  function JsonRpcBatchProvider() {\n    _classCallCheck(this, JsonRpcBatchProvider);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(JsonRpcBatchProvider, [{\n    key: \"send\",\n    value: function send(method, params) {\n      var _this = this;\n\n      var request = {\n        method: method,\n        params: params,\n        id: this._nextId++,\n        jsonrpc: \"2.0\"\n      };\n\n      if (this._pendingBatch == null) {\n        this._pendingBatch = [];\n      }\n\n      var inflightRequest = {\n        request: request,\n        resolve: null,\n        reject: null\n      };\n      var promise = new Promise(function (resolve, reject) {\n        inflightRequest.resolve = resolve;\n        inflightRequest.reject = reject;\n      });\n\n      this._pendingBatch.push(inflightRequest);\n\n      if (!this._pendingBatchAggregator) {\n        // Schedule batch for next event loop + short duration\n        this._pendingBatchAggregator = setTimeout(function () {\n          // Get teh current batch and clear it, so new requests\n          // go into the next batch\n          var batch = _this._pendingBatch;\n          _this._pendingBatch = null;\n          _this._pendingBatchAggregator = null; // Get the request as an array of requests\n\n          var request = batch.map(function (inflight) {\n            return inflight.request;\n          });\n\n          _this.emit(\"debug\", {\n            action: \"requestBatch\",\n            request: deepCopy(request),\n            provider: _this\n          });\n\n          return fetchJson(_this.connection, JSON.stringify(request)).then(function (result) {\n            _this.emit(\"debug\", {\n              action: \"response\",\n              request: request,\n              response: result,\n              provider: _this\n            }); // For each result, feed it to the correct Promise, depending\n            // on whether it was a success or error\n\n\n            batch.forEach(function (inflightRequest, index) {\n              var payload = result[index];\n\n              if (payload.error) {\n                var error = new Error(payload.error.message);\n                error.code = payload.error.code;\n                error.data = payload.error.data;\n                inflightRequest.reject(error);\n              } else {\n                inflightRequest.resolve(payload.result);\n              }\n            });\n          }, function (error) {\n            _this.emit(\"debug\", {\n              action: \"response\",\n              error: error,\n              request: request,\n              provider: _this\n            });\n\n            batch.forEach(function (inflightRequest) {\n              inflightRequest.reject(error);\n            });\n          });\n        }, 10);\n      }\n\n      return promise;\n    }\n  }]);\n\n  return JsonRpcBatchProvider;\n}(JsonRpcProvider);","map":{"version":3,"sources":["../src.ts/json-rpc-batch-provider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { deepCopy } from \"@ethersproject/properties\";\nimport { fetchJson } from \"@ethersproject/web\";\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\n// Experimental\nexport class JsonRpcBatchProvider extends JsonRpcProvider {\n    send(method, params) {\n        const request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n        if (this._pendingBatch == null) {\n            this._pendingBatch = [];\n        }\n        const inflightRequest = { request, resolve: null, reject: null };\n        const promise = new Promise((resolve, reject) => {\n            inflightRequest.resolve = resolve;\n            inflightRequest.reject = reject;\n        });\n        this._pendingBatch.push(inflightRequest);\n        if (!this._pendingBatchAggregator) {\n            // Schedule batch for next event loop + short duration\n            this._pendingBatchAggregator = setTimeout(() => {\n                // Get teh current batch and clear it, so new requests\n                // go into the next batch\n                const batch = this._pendingBatch;\n                this._pendingBatch = null;\n                this._pendingBatchAggregator = null;\n                // Get the request as an array of requests\n                const request = batch.map((inflight) => inflight.request);\n                this.emit(\"debug\", {\n                    action: \"requestBatch\",\n                    request: deepCopy(request),\n                    provider: this\n                });\n                return fetchJson(this.connection, JSON.stringify(request)).then((result) => {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: request,\n                        response: result,\n                        provider: this\n                    });\n                    // For each result, feed it to the correct Promise, depending\n                    // on whether it was a success or error\n                    batch.forEach((inflightRequest, index) => {\n                        const payload = result[index];\n                        if (payload.error) {\n                            const error = new Error(payload.error.message);\n                            error.code = payload.error.code;\n                            error.data = payload.error.data;\n                            inflightRequest.reject(error);\n                        }\n                        else {\n                            inflightRequest.resolve(payload.result);\n                        }\n                    });\n                }, (error) => {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: request,\n                        provider: this\n                    });\n                    batch.forEach((inflightRequest) => {\n                        inflightRequest.reject(error);\n                    });\n                });\n            }, 10);\n        }\n        return promise;\n    }\n}\n//# sourceMappingURL=json-rpc-batch-provider.js.map"]},"metadata":{},"sourceType":"module"}