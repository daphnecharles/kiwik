{"ast":null,"code":"var _createForOfIteratorHelper = require(\"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar AbortController = globalThis.AbortController;\n/**\n * Takes an array of AbortSignals and returns a single signal.\n * If any signals are aborted, the returned signal will be aborted.\n * @param {Array<AbortSignal>} signals\n * @returns {AbortSignal}\n */\n\nfunction anySignal(signals) {\n  var controller = new AbortController();\n\n  function onAbort() {\n    controller.abort();\n\n    var _iterator = _createForOfIteratorHelper(signals),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var signal = _step.value;\n        if (!signal || !signal.removeEventListener) continue;\n        signal.removeEventListener('abort', onAbort);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  var _iterator2 = _createForOfIteratorHelper(signals),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var signal = _step2.value;\n      if (!signal || !signal.addEventListener) continue;\n\n      if (signal.aborted) {\n        onAbort();\n        break;\n      }\n\n      signal.addEventListener('abort', onAbort);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return controller.signal;\n}\n\nmodule.exports = anySignal;\nmodule.exports.anySignal = anySignal;","map":{"version":3,"sources":["/Users/sam/Desktop/kiwik/node_modules/ipfs-utils/node_modules/any-signal/index.js"],"names":["AbortController","globalThis","anySignal","signals","controller","onAbort","abort","signal","removeEventListener","addEventListener","aborted","module","exports"],"mappings":";;AAAA,IAAQA,eAAR,GAA4BC,UAA5B,CAAQD,eAAR;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASE,SAAT,CAAoBC,OAApB,EAA6B;AAC3B,MAAMC,UAAU,GAAG,IAAIJ,eAAJ,EAAnB;;AAEA,WAASK,OAAT,GAAoB;AAClBD,IAAAA,UAAU,CAACE,KAAX;;AADkB,+CAGGH,OAHH;AAAA;;AAAA;AAGlB,0DAA8B;AAAA,YAAnBI,MAAmB;AAC5B,YAAI,CAACA,MAAD,IAAW,CAACA,MAAM,CAACC,mBAAvB,EAA4C;AAC5CD,QAAAA,MAAM,CAACC,mBAAP,CAA2B,OAA3B,EAAoCH,OAApC;AACD;AANiB;AAAA;AAAA;AAAA;AAAA;AAOnB;;AAV0B,8CAYNF,OAZM;AAAA;;AAAA;AAY3B,2DAA8B;AAAA,UAAnBI,MAAmB;AAC5B,UAAI,CAACA,MAAD,IAAW,CAACA,MAAM,CAACE,gBAAvB,EAAyC;;AACzC,UAAIF,MAAM,CAACG,OAAX,EAAoB;AAClBL,QAAAA,OAAO;AACP;AACD;;AACDE,MAAAA,MAAM,CAACE,gBAAP,CAAwB,OAAxB,EAAiCJ,OAAjC;AACD;AAnB0B;AAAA;AAAA;AAAA;AAAA;;AAqB3B,SAAOD,UAAU,CAACG,MAAlB;AACD;;AAEDI,MAAM,CAACC,OAAP,GAAiBV,SAAjB;AACAS,MAAM,CAACC,OAAP,CAAeV,SAAf,GAA2BA,SAA3B","sourcesContent":["const { AbortController } = globalThis\n\n/**\n * Takes an array of AbortSignals and returns a single signal.\n * If any signals are aborted, the returned signal will be aborted.\n * @param {Array<AbortSignal>} signals\n * @returns {AbortSignal}\n */\nfunction anySignal (signals) {\n  const controller = new AbortController()\n\n  function onAbort () {\n    controller.abort()\n\n    for (const signal of signals) {\n      if (!signal || !signal.removeEventListener) continue\n      signal.removeEventListener('abort', onAbort)\n    }\n  }\n\n  for (const signal of signals) {\n    if (!signal || !signal.addEventListener) continue\n    if (signal.aborted) {\n      onAbort()\n      break\n    }\n    signal.addEventListener('abort', onAbort)\n  }\n\n  return controller.signal\n}\n\nmodule.exports = anySignal\nmodule.exports.anySignal = anySignal\n"]},"metadata":{},"sourceType":"script"}