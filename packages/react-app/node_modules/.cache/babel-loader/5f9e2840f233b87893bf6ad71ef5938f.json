{"ast":null,"code":"import _classCallCheck from \"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { Base, WordArray } from './core.js';\nimport { SHA1Algo } from './sha1.js';\nimport { HMAC } from './hmac.js';\n/**\n * Password-Based Key Derivation Function 2 algorithm.\n */\n\nexport var PBKDF2Algo = /*#__PURE__*/function (_Base) {\n  _inherits(PBKDF2Algo, _Base);\n\n  var _super = _createSuper(PBKDF2Algo);\n\n  /**\n   * Initializes a newly created key derivation function.\n   *\n   * @param {Object} cfg (Optional) The configuration options to use for the derivation.\n   *\n   * @example\n   *\n   *     const kdf = CryptoJS.algo.PBKDF2.create();\n   *     const kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });\n   *     const kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });\n   */\n  function PBKDF2Algo(cfg) {\n    var _this;\n\n    _classCallCheck(this, PBKDF2Algo);\n\n    _this = _super.call(this);\n    /**\n     * Configuration options.\n     *\n     * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)\n     * @property {Hasher} hasher The hasher to use. Default: SHA1\n     * @property {number} iterations The number of iterations to perform. Default: 1\n     */\n\n    _this.cfg = Object.assign(new Base(), {\n      keySize: 128 / 32,\n      hasher: SHA1Algo,\n      iterations: 1\n    }, cfg);\n    return _this;\n  }\n  /**\n   * Computes the Password-Based Key Derivation Function 2.\n   *\n   * @param {WordArray|string} password The password.\n   * @param {WordArray|string} salt A salt.\n   *\n   * @return {WordArray} The derived key.\n   *\n   * @example\n   *\n   *     const key = kdf.compute(password, salt);\n   */\n\n\n  _createClass(PBKDF2Algo, [{\n    key: \"compute\",\n    value: function compute(password, salt) {\n      // Shortcut\n      var cfg = this.cfg; // Init HMAC\n\n      var hmac = HMAC.create(cfg.hasher, password); // Initial values\n\n      var derivedKey = WordArray.create();\n      var blockIndex = WordArray.create([0x00000001]); // Shortcuts\n\n      var derivedKeyWords = derivedKey.words;\n      var blockIndexWords = blockIndex.words;\n      var keySize = cfg.keySize,\n          iterations = cfg.iterations; // Generate key\n\n      while (derivedKeyWords.length < keySize) {\n        var block = hmac.update(salt).finalize(blockIndex);\n        hmac.reset(); // Shortcuts\n\n        var blockWords = block.words;\n        var blockWordsLength = blockWords.length; // Iterations\n\n        var intermediate = block;\n\n        for (var i = 1; i < iterations; i += 1) {\n          intermediate = hmac.finalize(intermediate);\n          hmac.reset(); // Shortcut\n\n          var intermediateWords = intermediate.words; // XOR intermediate with block\n\n          for (var j = 0; j < blockWordsLength; j += 1) {\n            blockWords[j] ^= intermediateWords[j];\n          }\n        }\n\n        derivedKey.concat(block);\n        blockIndexWords[0] += 1;\n      }\n\n      derivedKey.sigBytes = keySize * 4;\n      return derivedKey;\n    }\n  }]);\n\n  return PBKDF2Algo;\n}(Base);\n/**\n * Computes the Password-Based Key Derivation Function 2.\n *\n * @param {WordArray|string} password The password.\n * @param {WordArray|string} salt A salt.\n * @param {Object} cfg (Optional) The configuration options to use for this computation.\n *\n * @return {WordArray} The derived key.\n *\n * @static\n *\n * @example\n *\n *     var key = CryptoJS.PBKDF2(password, salt);\n *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8 });\n *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8, iterations: 1000 });\n */\n\nexport var PBKDF2 = function PBKDF2(password, salt, cfg) {\n  return PBKDF2Algo.create(cfg).compute(password, salt);\n};","map":{"version":3,"sources":["/Users/sam/Desktop/kiwik/node_modules/crypto-es/lib/pbkdf2.js"],"names":["Base","WordArray","SHA1Algo","HMAC","PBKDF2Algo","cfg","Object","assign","keySize","hasher","iterations","password","salt","hmac","create","derivedKey","blockIndex","derivedKeyWords","words","blockIndexWords","length","block","update","finalize","reset","blockWords","blockWordsLength","intermediate","i","intermediateWords","j","concat","sigBytes","PBKDF2","compute"],"mappings":"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","sourcesContent":["import {\n  Base,\n  WordArray,\n} from './core.js';\nimport { SHA1Algo } from './sha1.js';\nimport { HMAC } from './hmac.js';\n\n/**\n * Password-Based Key Derivation Function 2 algorithm.\n */\nexport class PBKDF2Algo extends Base {\n  /**\n   * Initializes a newly created key derivation function.\n   *\n   * @param {Object} cfg (Optional) The configuration options to use for the derivation.\n   *\n   * @example\n   *\n   *     const kdf = CryptoJS.algo.PBKDF2.create();\n   *     const kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });\n   *     const kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });\n   */\n  constructor(cfg) {\n    super();\n\n    /**\n     * Configuration options.\n     *\n     * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)\n     * @property {Hasher} hasher The hasher to use. Default: SHA1\n     * @property {number} iterations The number of iterations to perform. Default: 1\n     */\n    this.cfg = Object.assign(\n      new Base(),\n      {\n        keySize: 128 / 32,\n        hasher: SHA1Algo,\n        iterations: 1,\n      },\n      cfg,\n    );\n  }\n\n  /**\n   * Computes the Password-Based Key Derivation Function 2.\n   *\n   * @param {WordArray|string} password The password.\n   * @param {WordArray|string} salt A salt.\n   *\n   * @return {WordArray} The derived key.\n   *\n   * @example\n   *\n   *     const key = kdf.compute(password, salt);\n   */\n  compute(password, salt) {\n    // Shortcut\n    const { cfg } = this;\n\n    // Init HMAC\n    const hmac = HMAC.create(cfg.hasher, password);\n\n    // Initial values\n    const derivedKey = WordArray.create();\n    const blockIndex = WordArray.create([0x00000001]);\n\n    // Shortcuts\n    const derivedKeyWords = derivedKey.words;\n    const blockIndexWords = blockIndex.words;\n    const { keySize, iterations } = cfg;\n\n    // Generate key\n    while (derivedKeyWords.length < keySize) {\n      const block = hmac.update(salt).finalize(blockIndex);\n      hmac.reset();\n\n      // Shortcuts\n      const blockWords = block.words;\n      const blockWordsLength = blockWords.length;\n\n      // Iterations\n      let intermediate = block;\n      for (let i = 1; i < iterations; i += 1) {\n        intermediate = hmac.finalize(intermediate);\n        hmac.reset();\n\n        // Shortcut\n        const intermediateWords = intermediate.words;\n\n        // XOR intermediate with block\n        for (let j = 0; j < blockWordsLength; j += 1) {\n          blockWords[j] ^= intermediateWords[j];\n        }\n      }\n\n      derivedKey.concat(block);\n      blockIndexWords[0] += 1;\n    }\n    derivedKey.sigBytes = keySize * 4;\n\n    return derivedKey;\n  }\n}\n\n/**\n * Computes the Password-Based Key Derivation Function 2.\n *\n * @param {WordArray|string} password The password.\n * @param {WordArray|string} salt A salt.\n * @param {Object} cfg (Optional) The configuration options to use for this computation.\n *\n * @return {WordArray} The derived key.\n *\n * @static\n *\n * @example\n *\n *     var key = CryptoJS.PBKDF2(password, salt);\n *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8 });\n *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8, iterations: 1000 });\n */\nexport const PBKDF2 = (password, salt, cfg) => PBKDF2Algo.create(cfg).compute(password, salt);\n"]},"metadata":{},"sourceType":"module"}