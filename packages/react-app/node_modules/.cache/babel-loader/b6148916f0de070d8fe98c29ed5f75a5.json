{"ast":null,"code":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.registerHelper(\"fold\", \"brace\", function (cm, start) {\n    var line = start.line,\n        lineText = cm.getLine(line);\n    var tokenType;\n\n    function findOpening(openCh) {\n      for (var at = start.ch, pass = 0;;) {\n        var found = at <= 0 ? -1 : lineText.lastIndexOf(openCh, at - 1);\n\n        if (found == -1) {\n          if (pass == 1) break;\n          pass = 1;\n          at = lineText.length;\n          continue;\n        }\n\n        if (pass == 1 && found < start.ch) break;\n        tokenType = cm.getTokenTypeAt(CodeMirror.Pos(line, found + 1));\n        if (!/^(comment|string)/.test(tokenType)) return found + 1;\n        at = found - 1;\n      }\n    }\n\n    var startBrace = findOpening(\"{\"),\n        startBracket = findOpening(\"[\");\n    var startToken, endToken, startCh;\n\n    if (startBrace != null && (startBracket == null || startBracket > startBrace)) {\n      startCh = startBrace;\n      startToken = \"{\";\n      endToken = \"}\";\n    } else if (startBracket != null) {\n      startCh = startBracket;\n      startToken = \"[\";\n      endToken = \"]\";\n    } else {\n      return;\n    }\n\n    var count = 1,\n        lastLine = cm.lastLine(),\n        end,\n        endCh;\n\n    outer: for (var i = line; i <= lastLine; ++i) {\n      var text = cm.getLine(i),\n          pos = i == line ? startCh : 0;\n\n      for (;;) {\n        var nextOpen = text.indexOf(startToken, pos),\n            nextClose = text.indexOf(endToken, pos);\n        if (nextOpen < 0) nextOpen = text.length;\n        if (nextClose < 0) nextClose = text.length;\n        pos = Math.min(nextOpen, nextClose);\n        if (pos == text.length) break;\n\n        if (cm.getTokenTypeAt(CodeMirror.Pos(i, pos + 1)) == tokenType) {\n          if (pos == nextOpen) ++count;else if (! --count) {\n            end = i;\n            endCh = pos;\n            break outer;\n          }\n        }\n\n        ++pos;\n      }\n    }\n\n    if (end == null || line == end) return;\n    return {\n      from: CodeMirror.Pos(line, startCh),\n      to: CodeMirror.Pos(end, endCh)\n    };\n  });\n  CodeMirror.registerHelper(\"fold\", \"import\", function (cm, start) {\n    function hasImport(line) {\n      if (line < cm.firstLine() || line > cm.lastLine()) return null;\n      var start = cm.getTokenAt(CodeMirror.Pos(line, 1));\n      if (!/\\S/.test(start.string)) start = cm.getTokenAt(CodeMirror.Pos(line, start.end + 1));\n      if (start.type != \"keyword\" || start.string != \"import\") return null; // Now find closing semicolon, return its position\n\n      for (var i = line, e = Math.min(cm.lastLine(), line + 10); i <= e; ++i) {\n        var text = cm.getLine(i),\n            semi = text.indexOf(\";\");\n        if (semi != -1) return {\n          startCh: start.end,\n          end: CodeMirror.Pos(i, semi)\n        };\n      }\n    }\n\n    var startLine = start.line,\n        has = hasImport(startLine),\n        prev;\n    if (!has || hasImport(startLine - 1) || (prev = hasImport(startLine - 2)) && prev.end.line == startLine - 1) return null;\n\n    for (var end = has.end;;) {\n      var next = hasImport(end.line + 1);\n      if (next == null) break;\n      end = next.end;\n    }\n\n    return {\n      from: cm.clipPos(CodeMirror.Pos(startLine, has.startCh + 1)),\n      to: end\n    };\n  });\n  CodeMirror.registerHelper(\"fold\", \"include\", function (cm, start) {\n    function hasInclude(line) {\n      if (line < cm.firstLine() || line > cm.lastLine()) return null;\n      var start = cm.getTokenAt(CodeMirror.Pos(line, 1));\n      if (!/\\S/.test(start.string)) start = cm.getTokenAt(CodeMirror.Pos(line, start.end + 1));\n      if (start.type == \"meta\" && start.string.slice(0, 8) == \"#include\") return start.start + 8;\n    }\n\n    var startLine = start.line,\n        has = hasInclude(startLine);\n    if (has == null || hasInclude(startLine - 1) != null) return null;\n\n    for (var end = startLine;;) {\n      var next = hasInclude(end + 1);\n      if (next == null) break;\n      ++end;\n    }\n\n    return {\n      from: CodeMirror.Pos(startLine, has + 1),\n      to: cm.clipPos(CodeMirror.Pos(end))\n    };\n  });\n});","map":{"version":3,"sources":["/Users/sam/Desktop/kiwik/node_modules/codemirror/addon/fold/brace-fold.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","registerHelper","cm","start","line","lineText","getLine","tokenType","findOpening","openCh","at","ch","pass","found","lastIndexOf","length","getTokenTypeAt","Pos","test","startBrace","startBracket","startToken","endToken","startCh","count","lastLine","end","endCh","outer","i","text","pos","nextOpen","indexOf","nextClose","Math","min","from","to","hasImport","firstLine","getTokenAt","string","type","e","semi","startLine","has","prev","next","clipPos","hasInclude","slice"],"mappings":"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","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.registerHelper(\"fold\", \"brace\", function(cm, start) {\n  var line = start.line, lineText = cm.getLine(line);\n  var tokenType;\n\n  function findOpening(openCh) {\n    for (var at = start.ch, pass = 0;;) {\n      var found = at <= 0 ? -1 : lineText.lastIndexOf(openCh, at - 1);\n      if (found == -1) {\n        if (pass == 1) break;\n        pass = 1;\n        at = lineText.length;\n        continue;\n      }\n      if (pass == 1 && found < start.ch) break;\n      tokenType = cm.getTokenTypeAt(CodeMirror.Pos(line, found + 1));\n      if (!/^(comment|string)/.test(tokenType)) return found + 1;\n      at = found - 1;\n    }\n  }\n\n  var startBrace = findOpening(\"{\"), startBracket = findOpening(\"[\")\n  var startToken, endToken, startCh\n  if (startBrace != null && (startBracket == null || startBracket > startBrace)) {\n    startCh = startBrace; startToken = \"{\"; endToken = \"}\"\n  } else if (startBracket != null) {\n    startCh = startBracket; startToken = \"[\"; endToken = \"]\"\n  } else {\n    return\n  }\n\n  var count = 1, lastLine = cm.lastLine(), end, endCh;\n  outer: for (var i = line; i <= lastLine; ++i) {\n    var text = cm.getLine(i), pos = i == line ? startCh : 0;\n    for (;;) {\n      var nextOpen = text.indexOf(startToken, pos), nextClose = text.indexOf(endToken, pos);\n      if (nextOpen < 0) nextOpen = text.length;\n      if (nextClose < 0) nextClose = text.length;\n      pos = Math.min(nextOpen, nextClose);\n      if (pos == text.length) break;\n      if (cm.getTokenTypeAt(CodeMirror.Pos(i, pos + 1)) == tokenType) {\n        if (pos == nextOpen) ++count;\n        else if (!--count) { end = i; endCh = pos; break outer; }\n      }\n      ++pos;\n    }\n  }\n  if (end == null || line == end) return;\n  return {from: CodeMirror.Pos(line, startCh),\n          to: CodeMirror.Pos(end, endCh)};\n});\n\nCodeMirror.registerHelper(\"fold\", \"import\", function(cm, start) {\n  function hasImport(line) {\n    if (line < cm.firstLine() || line > cm.lastLine()) return null;\n    var start = cm.getTokenAt(CodeMirror.Pos(line, 1));\n    if (!/\\S/.test(start.string)) start = cm.getTokenAt(CodeMirror.Pos(line, start.end + 1));\n    if (start.type != \"keyword\" || start.string != \"import\") return null;\n    // Now find closing semicolon, return its position\n    for (var i = line, e = Math.min(cm.lastLine(), line + 10); i <= e; ++i) {\n      var text = cm.getLine(i), semi = text.indexOf(\";\");\n      if (semi != -1) return {startCh: start.end, end: CodeMirror.Pos(i, semi)};\n    }\n  }\n\n  var startLine = start.line, has = hasImport(startLine), prev;\n  if (!has || hasImport(startLine - 1) || ((prev = hasImport(startLine - 2)) && prev.end.line == startLine - 1))\n    return null;\n  for (var end = has.end;;) {\n    var next = hasImport(end.line + 1);\n    if (next == null) break;\n    end = next.end;\n  }\n  return {from: cm.clipPos(CodeMirror.Pos(startLine, has.startCh + 1)), to: end};\n});\n\nCodeMirror.registerHelper(\"fold\", \"include\", function(cm, start) {\n  function hasInclude(line) {\n    if (line < cm.firstLine() || line > cm.lastLine()) return null;\n    var start = cm.getTokenAt(CodeMirror.Pos(line, 1));\n    if (!/\\S/.test(start.string)) start = cm.getTokenAt(CodeMirror.Pos(line, start.end + 1));\n    if (start.type == \"meta\" && start.string.slice(0, 8) == \"#include\") return start.start + 8;\n  }\n\n  var startLine = start.line, has = hasInclude(startLine);\n  if (has == null || hasInclude(startLine - 1) != null) return null;\n  for (var end = startLine;;) {\n    var next = hasInclude(end + 1);\n    if (next == null) break;\n    ++end;\n  }\n  return {from: CodeMirror.Pos(startLine, has + 1),\n          to: cm.clipPos(CodeMirror.Pos(end))};\n});\n\n});\n"]},"metadata":{},"sourceType":"script"}