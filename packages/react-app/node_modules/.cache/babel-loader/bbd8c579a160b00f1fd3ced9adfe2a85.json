{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _constants = require(\"./constants\");\n\nvar _errorCodes = require(\"./errorCodes\");\n\nvar _createDestructor2 = _interopRequireDefault(require(\"./createDestructor\"));\n\nvar _getOriginFromSrc = _interopRequireDefault(require(\"./getOriginFromSrc\"));\n\nvar _createLogger = _interopRequireDefault(require(\"./createLogger\"));\n\nvar _connectCallReceiver = _interopRequireDefault(require(\"./connectCallReceiver\"));\n\nvar _connectCallSender = _interopRequireDefault(require(\"./connectCallSender\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar CHECK_IFRAME_IN_DOC_INTERVAL = 60000;\n/**\n * @typedef {Object} Child\n * @property {Promise} promise A promise which will be resolved once a connection has\n * been established.\n * @property {Function} destroy A method that, when called, will disconnect any\n * messaging channels. You may call this even before a connection has been established.\n */\n\n/**\n * Creates an iframe, loads a webpage into the URL, and attempts to establish communication with\n * the iframe.\n * @param {Object} options\n * @param {HTMLIframeElement} options.iframe The iframe to connect to.\n * @param {Object} [options.methods={}] Methods that may be called by the iframe.\n * @param {String} [options.childOrigin] The child origin to use to secure communication. If\n * not provided, the child origin will be derived from the iframe's src or srcdoc value.\n * @param {Number} [options.timeout] The amount of time, in milliseconds, Penpal should wait\n * for the child to respond before rejecting the connection promise.\n * @return {Child}\n */\n\nvar _default = function _default(_ref) {\n  var iframe = _ref.iframe,\n      _ref$methods = _ref.methods,\n      methods = _ref$methods === void 0 ? {} : _ref$methods,\n      childOrigin = _ref.childOrigin,\n      timeout = _ref.timeout,\n      debug = _ref.debug;\n  var log = (0, _createLogger.default)(debug);\n  var parent = window;\n\n  var _createDestructor = (0, _createDestructor2.default)(),\n      destroy = _createDestructor.destroy,\n      onDestroy = _createDestructor.onDestroy;\n\n  if (!childOrigin) {\n    if (!iframe.src && !iframe.srcdoc) {\n      var error = new Error('Iframe must have src or srcdoc property defined.');\n      error.code = _errorCodes.ERR_NO_IFRAME_SRC;\n      throw error;\n    }\n\n    childOrigin = (0, _getOriginFromSrc.default)(iframe.src);\n  } // If event.origin is \"null\", the remote protocol is\n  // file:, data:, and we must post messages with \"*\" as targetOrigin\n  // when sending and allow\n  // [1] https://developer.mozilla.org/fr/docs/Web/API/Window/postMessage#Utiliser_window.postMessage_dans_les_extensions\n\n\n  var originForSending = childOrigin === 'null' ? '*' : childOrigin;\n  var promise = new Promise(function (resolveConnectionPromise, reject) {\n    var connectionTimeoutId;\n\n    if (timeout !== undefined) {\n      connectionTimeoutId = setTimeout(function () {\n        var error = new Error(\"Connection to child timed out after \".concat(timeout, \"ms\"));\n        error.code = _errorCodes.ERR_CONNECTION_TIMEOUT;\n        reject(error);\n        destroy();\n      }, timeout);\n    } // We resolve the promise with the call sender. If the child reconnects (for example, after\n    // refreshing or navigating to another page that uses Penpal, we'll update the call sender\n    // with methods that match the latest provided by the child.\n\n\n    var callSender = {};\n    var receiverMethodNames;\n    var destroyCallReceiver;\n\n    var handleMessage = function handleMessage(event) {\n      var child = iframe.contentWindow;\n\n      if (event.source !== child || event.data.penpal !== _constants.HANDSHAKE) {\n        return;\n      }\n\n      if (event.origin !== childOrigin) {\n        log(\"Parent received handshake from origin \".concat(event.origin, \" which did not match expected origin \").concat(childOrigin));\n        return;\n      }\n\n      log('Parent: Received handshake, sending reply');\n      event.source.postMessage({\n        penpal: _constants.HANDSHAKE_REPLY,\n        methodNames: Object.keys(methods)\n      }, originForSending);\n      var info = {\n        localName: 'Parent',\n        local: parent,\n        remote: child,\n        originForSending: originForSending,\n        originForReceiving: childOrigin\n      }; // If the child reconnected, we need to destroy the previous call receiver before setting\n      // up a new one.\n\n      if (destroyCallReceiver) {\n        destroyCallReceiver();\n      }\n\n      destroyCallReceiver = (0, _connectCallReceiver.default)(info, methods, log);\n      onDestroy(destroyCallReceiver); // If the child reconnected, we need to remove the methods from the previous call receiver\n      // off the sender.\n\n      if (receiverMethodNames) {\n        receiverMethodNames.forEach(function (receiverMethodName) {\n          delete callSender[receiverMethodName];\n        });\n      }\n\n      receiverMethodNames = event.data.methodNames;\n      var destroyCallSender = (0, _connectCallSender.default)(callSender, info, receiverMethodNames, destroy, log);\n      onDestroy(destroyCallSender);\n      clearTimeout(connectionTimeoutId);\n      resolveConnectionPromise(callSender);\n    };\n\n    parent.addEventListener(_constants.MESSAGE, handleMessage);\n    log('Parent: Awaiting handshake'); // This is to prevent memory leaks when the iframe is removed\n    // from the document and the consumer hasn't called destroy().\n    // Without this, event listeners attached to the window would\n    // stick around and since the event handlers have a reference\n    // to the iframe in their closures, the iframe would stick around\n    // too.\n\n    var checkIframeInDocIntervalId = setInterval(function () {\n      if (!document.contains(iframe)) {\n        clearInterval(checkIframeInDocIntervalId);\n        destroy();\n      }\n    }, CHECK_IFRAME_IN_DOC_INTERVAL);\n    onDestroy(function () {\n      parent.removeEventListener(_constants.MESSAGE, handleMessage);\n      clearInterval(checkIframeInDocIntervalId);\n      var error = new Error('Connection destroyed');\n      error.code = _errorCodes.ERR_CONNECTION_DESTROYED;\n      reject(error);\n    });\n  });\n  return {\n    promise: promise,\n    destroy: destroy\n  };\n};\n\nexports.default = _default;\nmodule.exports = exports.default;","map":{"version":3,"sources":["/Users/sam/Desktop/kiwik/node_modules/authereum/node_modules/penpal/lib/connectToChild.js"],"names":["Object","defineProperty","exports","value","default","_constants","require","_errorCodes","_createDestructor2","_interopRequireDefault","_getOriginFromSrc","_createLogger","_connectCallReceiver","_connectCallSender","obj","__esModule","CHECK_IFRAME_IN_DOC_INTERVAL","_default","_ref","iframe","_ref$methods","methods","childOrigin","timeout","debug","log","parent","window","_createDestructor","destroy","onDestroy","src","srcdoc","error","Error","code","ERR_NO_IFRAME_SRC","originForSending","promise","Promise","resolveConnectionPromise","reject","connectionTimeoutId","undefined","setTimeout","ERR_CONNECTION_TIMEOUT","callSender","receiverMethodNames","destroyCallReceiver","handleMessage","event","child","contentWindow","source","data","penpal","HANDSHAKE","origin","postMessage","HANDSHAKE_REPLY","methodNames","keys","info","localName","local","remote","originForReceiving","forEach","receiverMethodName","destroyCallSender","clearTimeout","addEventListener","MESSAGE","checkIframeInDocIntervalId","setInterval","document","contains","clearInterval","removeEventListener","ERR_CONNECTION_DESTROYED","module"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _constants = require(\"./constants\");\n\nvar _errorCodes = require(\"./errorCodes\");\n\nvar _createDestructor2 = _interopRequireDefault(require(\"./createDestructor\"));\n\nvar _getOriginFromSrc = _interopRequireDefault(require(\"./getOriginFromSrc\"));\n\nvar _createLogger = _interopRequireDefault(require(\"./createLogger\"));\n\nvar _connectCallReceiver = _interopRequireDefault(require(\"./connectCallReceiver\"));\n\nvar _connectCallSender = _interopRequireDefault(require(\"./connectCallSender\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst CHECK_IFRAME_IN_DOC_INTERVAL = 60000;\n/**\n * @typedef {Object} Child\n * @property {Promise} promise A promise which will be resolved once a connection has\n * been established.\n * @property {Function} destroy A method that, when called, will disconnect any\n * messaging channels. You may call this even before a connection has been established.\n */\n\n/**\n * Creates an iframe, loads a webpage into the URL, and attempts to establish communication with\n * the iframe.\n * @param {Object} options\n * @param {HTMLIframeElement} options.iframe The iframe to connect to.\n * @param {Object} [options.methods={}] Methods that may be called by the iframe.\n * @param {String} [options.childOrigin] The child origin to use to secure communication. If\n * not provided, the child origin will be derived from the iframe's src or srcdoc value.\n * @param {Number} [options.timeout] The amount of time, in milliseconds, Penpal should wait\n * for the child to respond before rejecting the connection promise.\n * @return {Child}\n */\n\nvar _default = (_ref) => {\n  let iframe = _ref.iframe,\n      _ref$methods = _ref.methods,\n      methods = _ref$methods === void 0 ? {} : _ref$methods,\n      childOrigin = _ref.childOrigin,\n      timeout = _ref.timeout,\n      debug = _ref.debug;\n  const log = (0, _createLogger.default)(debug);\n  const parent = window;\n\n  const _createDestructor = (0, _createDestructor2.default)(),\n        destroy = _createDestructor.destroy,\n        onDestroy = _createDestructor.onDestroy;\n\n  if (!childOrigin) {\n    if (!iframe.src && !iframe.srcdoc) {\n      const error = new Error('Iframe must have src or srcdoc property defined.');\n      error.code = _errorCodes.ERR_NO_IFRAME_SRC;\n      throw error;\n    }\n\n    childOrigin = (0, _getOriginFromSrc.default)(iframe.src);\n  } // If event.origin is \"null\", the remote protocol is\n  // file:, data:, and we must post messages with \"*\" as targetOrigin\n  // when sending and allow\n  // [1] https://developer.mozilla.org/fr/docs/Web/API/Window/postMessage#Utiliser_window.postMessage_dans_les_extensions\n\n\n  const originForSending = childOrigin === 'null' ? '*' : childOrigin;\n  const promise = new Promise((resolveConnectionPromise, reject) => {\n    let connectionTimeoutId;\n\n    if (timeout !== undefined) {\n      connectionTimeoutId = setTimeout(() => {\n        const error = new Error(`Connection to child timed out after ${timeout}ms`);\n        error.code = _errorCodes.ERR_CONNECTION_TIMEOUT;\n        reject(error);\n        destroy();\n      }, timeout);\n    } // We resolve the promise with the call sender. If the child reconnects (for example, after\n    // refreshing or navigating to another page that uses Penpal, we'll update the call sender\n    // with methods that match the latest provided by the child.\n\n\n    const callSender = {};\n    let receiverMethodNames;\n    let destroyCallReceiver;\n\n    const handleMessage = event => {\n      const child = iframe.contentWindow;\n\n      if (event.source !== child || event.data.penpal !== _constants.HANDSHAKE) {\n        return;\n      }\n\n      if (event.origin !== childOrigin) {\n        log(`Parent received handshake from origin ${event.origin} which did not match expected origin ${childOrigin}`);\n        return;\n      }\n\n      log('Parent: Received handshake, sending reply');\n      event.source.postMessage({\n        penpal: _constants.HANDSHAKE_REPLY,\n        methodNames: Object.keys(methods)\n      }, originForSending);\n      const info = {\n        localName: 'Parent',\n        local: parent,\n        remote: child,\n        originForSending: originForSending,\n        originForReceiving: childOrigin\n      }; // If the child reconnected, we need to destroy the previous call receiver before setting\n      // up a new one.\n\n      if (destroyCallReceiver) {\n        destroyCallReceiver();\n      }\n\n      destroyCallReceiver = (0, _connectCallReceiver.default)(info, methods, log);\n      onDestroy(destroyCallReceiver); // If the child reconnected, we need to remove the methods from the previous call receiver\n      // off the sender.\n\n      if (receiverMethodNames) {\n        receiverMethodNames.forEach(receiverMethodName => {\n          delete callSender[receiverMethodName];\n        });\n      }\n\n      receiverMethodNames = event.data.methodNames;\n      const destroyCallSender = (0, _connectCallSender.default)(callSender, info, receiverMethodNames, destroy, log);\n      onDestroy(destroyCallSender);\n      clearTimeout(connectionTimeoutId);\n      resolveConnectionPromise(callSender);\n    };\n\n    parent.addEventListener(_constants.MESSAGE, handleMessage);\n    log('Parent: Awaiting handshake'); // This is to prevent memory leaks when the iframe is removed\n    // from the document and the consumer hasn't called destroy().\n    // Without this, event listeners attached to the window would\n    // stick around and since the event handlers have a reference\n    // to the iframe in their closures, the iframe would stick around\n    // too.\n\n    var checkIframeInDocIntervalId = setInterval(() => {\n      if (!document.contains(iframe)) {\n        clearInterval(checkIframeInDocIntervalId);\n        destroy();\n      }\n    }, CHECK_IFRAME_IN_DOC_INTERVAL);\n    onDestroy(() => {\n      parent.removeEventListener(_constants.MESSAGE, handleMessage);\n      clearInterval(checkIframeInDocIntervalId);\n      const error = new Error('Connection destroyed');\n      error.code = _errorCodes.ERR_CONNECTION_DESTROYED;\n      reject(error);\n    });\n  });\n  return {\n    promise,\n    destroy\n  };\n};\n\nexports.default = _default;\nmodule.exports = exports.default;"]},"metadata":{},"sourceType":"script"}