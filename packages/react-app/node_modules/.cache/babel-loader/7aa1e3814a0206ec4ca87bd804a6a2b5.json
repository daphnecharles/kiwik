{"ast":null,"code":"/**\n * class Renderer\n *\n * Generates HTML from parsed token stream. Each instance has independent\n * copy of rules. Those can be rewritten with ease. Also, you can add new\n * rules if you create plugin and adds new token types.\n **/\n'use strict';\n\nvar assign = require('./common/utils').assign;\n\nvar unescapeAll = require('./common/utils').unescapeAll;\n\nvar escapeHtml = require('./common/utils').escapeHtml; ////////////////////////////////////////////////////////////////////////////////\n\n\nvar default_rules = {};\n\ndefault_rules.code_inline = function (tokens, idx, options, env, slf) {\n  var token = tokens[idx];\n  return '<code' + slf.renderAttrs(token) + '>' + escapeHtml(tokens[idx].content) + '</code>';\n};\n\ndefault_rules.code_block = function (tokens, idx, options, env, slf) {\n  var token = tokens[idx];\n  return '<pre' + slf.renderAttrs(token) + '><code>' + escapeHtml(tokens[idx].content) + '</code></pre>\\n';\n};\n\ndefault_rules.fence = function (tokens, idx, options, env, slf) {\n  var token = tokens[idx],\n      info = token.info ? unescapeAll(token.info).trim() : '',\n      langName = '',\n      langAttrs = '',\n      highlighted,\n      i,\n      arr,\n      tmpAttrs,\n      tmpToken;\n\n  if (info) {\n    arr = info.split(/(\\s+)/g);\n    langName = arr[0];\n    langAttrs = arr.slice(2).join('');\n  }\n\n  if (options.highlight) {\n    highlighted = options.highlight(token.content, langName, langAttrs) || escapeHtml(token.content);\n  } else {\n    highlighted = escapeHtml(token.content);\n  }\n\n  if (highlighted.indexOf('<pre') === 0) {\n    return highlighted + '\\n';\n  } // If language exists, inject class gently, without modifying original token.\n  // May be, one day we will add .deepClone() for token and simplify this part, but\n  // now we prefer to keep things local.\n\n\n  if (info) {\n    i = token.attrIndex('class');\n    tmpAttrs = token.attrs ? token.attrs.slice() : [];\n\n    if (i < 0) {\n      tmpAttrs.push(['class', options.langPrefix + langName]);\n    } else {\n      tmpAttrs[i] = tmpAttrs[i].slice();\n      tmpAttrs[i][1] += ' ' + options.langPrefix + langName;\n    } // Fake token just to render attributes\n\n\n    tmpToken = {\n      attrs: tmpAttrs\n    };\n    return '<pre><code' + slf.renderAttrs(tmpToken) + '>' + highlighted + '</code></pre>\\n';\n  }\n\n  return '<pre><code' + slf.renderAttrs(token) + '>' + highlighted + '</code></pre>\\n';\n};\n\ndefault_rules.image = function (tokens, idx, options, env, slf) {\n  var token = tokens[idx]; // \"alt\" attr MUST be set, even if empty. Because it's mandatory and\n  // should be placed on proper position for tests.\n  //\n  // Replace content with actual value\n\n  token.attrs[token.attrIndex('alt')][1] = slf.renderInlineAsText(token.children, options, env);\n  return slf.renderToken(tokens, idx, options);\n};\n\ndefault_rules.hardbreak = function (tokens, idx, options\n/*, env */\n) {\n  return options.xhtmlOut ? '<br />\\n' : '<br>\\n';\n};\n\ndefault_rules.softbreak = function (tokens, idx, options\n/*, env */\n) {\n  return options.breaks ? options.xhtmlOut ? '<br />\\n' : '<br>\\n' : '\\n';\n};\n\ndefault_rules.text = function (tokens, idx\n/*, options, env */\n) {\n  return escapeHtml(tokens[idx].content);\n};\n\ndefault_rules.html_block = function (tokens, idx\n/*, options, env */\n) {\n  return tokens[idx].content;\n};\n\ndefault_rules.html_inline = function (tokens, idx\n/*, options, env */\n) {\n  return tokens[idx].content;\n};\n/**\n * new Renderer()\n *\n * Creates new [[Renderer]] instance and fill [[Renderer#rules]] with defaults.\n **/\n\n\nfunction Renderer() {\n  /**\n   * Renderer#rules -> Object\n   *\n   * Contains render rules for tokens. Can be updated and extended.\n   *\n   * ##### Example\n   *\n   * ```javascript\n   * var md = require('markdown-it')();\n   *\n   * md.renderer.rules.strong_open  = function () { return '<b>'; };\n   * md.renderer.rules.strong_close = function () { return '</b>'; };\n   *\n   * var result = md.renderInline(...);\n   * ```\n   *\n   * Each rule is called as independent static function with fixed signature:\n   *\n   * ```javascript\n   * function my_token_render(tokens, idx, options, env, renderer) {\n   *   // ...\n   *   return renderedHTML;\n   * }\n   * ```\n   *\n   * See [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js)\n   * for more details and examples.\n   **/\n  this.rules = assign({}, default_rules);\n}\n/**\n * Renderer.renderAttrs(token) -> String\n *\n * Render token attributes to string.\n **/\n\n\nRenderer.prototype.renderAttrs = function renderAttrs(token) {\n  var i, l, result;\n\n  if (!token.attrs) {\n    return '';\n  }\n\n  result = '';\n\n  for (i = 0, l = token.attrs.length; i < l; i++) {\n    result += ' ' + escapeHtml(token.attrs[i][0]) + '=\"' + escapeHtml(token.attrs[i][1]) + '\"';\n  }\n\n  return result;\n};\n/**\n * Renderer.renderToken(tokens, idx, options) -> String\n * - tokens (Array): list of tokens\n * - idx (Numbed): token index to render\n * - options (Object): params of parser instance\n *\n * Default token renderer. Can be overriden by custom function\n * in [[Renderer#rules]].\n **/\n\n\nRenderer.prototype.renderToken = function renderToken(tokens, idx, options) {\n  var nextToken,\n      result = '',\n      needLf = false,\n      token = tokens[idx]; // Tight list paragraphs\n\n  if (token.hidden) {\n    return '';\n  } // Insert a newline between hidden paragraph and subsequent opening\n  // block-level tag.\n  //\n  // For example, here we should insert a newline before blockquote:\n  //  - a\n  //    >\n  //\n\n\n  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {\n    result += '\\n';\n  } // Add token name, e.g. `<img`\n\n\n  result += (token.nesting === -1 ? '</' : '<') + token.tag; // Encode attributes, e.g. `<img src=\"foo\"`\n\n  result += this.renderAttrs(token); // Add a slash for self-closing tags, e.g. `<img src=\"foo\" /`\n\n  if (token.nesting === 0 && options.xhtmlOut) {\n    result += ' /';\n  } // Check if we need to add a newline after this tag\n\n\n  if (token.block) {\n    needLf = true;\n\n    if (token.nesting === 1) {\n      if (idx + 1 < tokens.length) {\n        nextToken = tokens[idx + 1];\n\n        if (nextToken.type === 'inline' || nextToken.hidden) {\n          // Block-level tag containing an inline tag.\n          //\n          needLf = false;\n        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {\n          // Opening tag + closing tag of the same type. E.g. `<li></li>`.\n          //\n          needLf = false;\n        }\n      }\n    }\n  }\n\n  result += needLf ? '>\\n' : '>';\n  return result;\n};\n/**\n * Renderer.renderInline(tokens, options, env) -> String\n * - tokens (Array): list on block tokens to renter\n * - options (Object): params of parser instance\n * - env (Object): additional data from parsed input (references, for example)\n *\n * The same as [[Renderer.render]], but for single token of `inline` type.\n **/\n\n\nRenderer.prototype.renderInline = function (tokens, options, env) {\n  var type,\n      result = '',\n      rules = this.rules;\n\n  for (var i = 0, len = tokens.length; i < len; i++) {\n    type = tokens[i].type;\n\n    if (typeof rules[type] !== 'undefined') {\n      result += rules[type](tokens, i, options, env, this);\n    } else {\n      result += this.renderToken(tokens, i, options);\n    }\n  }\n\n  return result;\n};\n/** internal\n * Renderer.renderInlineAsText(tokens, options, env) -> String\n * - tokens (Array): list on block tokens to renter\n * - options (Object): params of parser instance\n * - env (Object): additional data from parsed input (references, for example)\n *\n * Special kludge for image `alt` attributes to conform CommonMark spec.\n * Don't try to use it! Spec requires to show `alt` content with stripped markup,\n * instead of simple escaping.\n **/\n\n\nRenderer.prototype.renderInlineAsText = function (tokens, options, env) {\n  var result = '';\n\n  for (var i = 0, len = tokens.length; i < len; i++) {\n    if (tokens[i].type === 'text') {\n      result += tokens[i].content;\n    } else if (tokens[i].type === 'image') {\n      result += this.renderInlineAsText(tokens[i].children, options, env);\n    } else if (tokens[i].type === 'softbreak') {\n      result += '\\n';\n    }\n  }\n\n  return result;\n};\n/**\n * Renderer.render(tokens, options, env) -> String\n * - tokens (Array): list on block tokens to renter\n * - options (Object): params of parser instance\n * - env (Object): additional data from parsed input (references, for example)\n *\n * Takes token stream and generates HTML. Probably, you will never need to call\n * this method directly.\n **/\n\n\nRenderer.prototype.render = function (tokens, options, env) {\n  var i,\n      len,\n      type,\n      result = '',\n      rules = this.rules;\n\n  for (i = 0, len = tokens.length; i < len; i++) {\n    type = tokens[i].type;\n\n    if (type === 'inline') {\n      result += this.renderInline(tokens[i].children, options, env);\n    } else if (typeof rules[type] !== 'undefined') {\n      result += rules[tokens[i].type](tokens, i, options, env, this);\n    } else {\n      result += this.renderToken(tokens, i, options, env);\n    }\n  }\n\n  return result;\n};\n\nmodule.exports = Renderer;","map":{"version":3,"sources":["/Users/sam/Desktop/kiwik/node_modules/markdown-it/lib/renderer.js"],"names":["assign","require","unescapeAll","escapeHtml","default_rules","code_inline","tokens","idx","options","env","slf","token","renderAttrs","content","code_block","fence","info","trim","langName","langAttrs","highlighted","i","arr","tmpAttrs","tmpToken","split","slice","join","highlight","indexOf","attrIndex","attrs","push","langPrefix","image","renderInlineAsText","children","renderToken","hardbreak","xhtmlOut","softbreak","breaks","text","html_block","html_inline","Renderer","rules","prototype","l","result","length","nextToken","needLf","hidden","block","nesting","tag","type","renderInline","len","render","module","exports"],"mappings":"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","sourcesContent":["/**\n * class Renderer\n *\n * Generates HTML from parsed token stream. Each instance has independent\n * copy of rules. Those can be rewritten with ease. Also, you can add new\n * rules if you create plugin and adds new token types.\n **/\n'use strict';\n\n\nvar assign          = require('./common/utils').assign;\nvar unescapeAll     = require('./common/utils').unescapeAll;\nvar escapeHtml      = require('./common/utils').escapeHtml;\n\n\n////////////////////////////////////////////////////////////////////////////////\n\nvar default_rules = {};\n\n\ndefault_rules.code_inline = function (tokens, idx, options, env, slf) {\n  var token = tokens[idx];\n\n  return  '<code' + slf.renderAttrs(token) + '>' +\n          escapeHtml(tokens[idx].content) +\n          '</code>';\n};\n\n\ndefault_rules.code_block = function (tokens, idx, options, env, slf) {\n  var token = tokens[idx];\n\n  return  '<pre' + slf.renderAttrs(token) + '><code>' +\n          escapeHtml(tokens[idx].content) +\n          '</code></pre>\\n';\n};\n\n\ndefault_rules.fence = function (tokens, idx, options, env, slf) {\n  var token = tokens[idx],\n      info = token.info ? unescapeAll(token.info).trim() : '',\n      langName = '',\n      langAttrs = '',\n      highlighted, i, arr, tmpAttrs, tmpToken;\n\n  if (info) {\n    arr = info.split(/(\\s+)/g);\n    langName = arr[0];\n    langAttrs = arr.slice(2).join('');\n  }\n\n  if (options.highlight) {\n    highlighted = options.highlight(token.content, langName, langAttrs) || escapeHtml(token.content);\n  } else {\n    highlighted = escapeHtml(token.content);\n  }\n\n  if (highlighted.indexOf('<pre') === 0) {\n    return highlighted + '\\n';\n  }\n\n  // If language exists, inject class gently, without modifying original token.\n  // May be, one day we will add .deepClone() for token and simplify this part, but\n  // now we prefer to keep things local.\n  if (info) {\n    i        = token.attrIndex('class');\n    tmpAttrs = token.attrs ? token.attrs.slice() : [];\n\n    if (i < 0) {\n      tmpAttrs.push([ 'class', options.langPrefix + langName ]);\n    } else {\n      tmpAttrs[i] = tmpAttrs[i].slice();\n      tmpAttrs[i][1] += ' ' + options.langPrefix + langName;\n    }\n\n    // Fake token just to render attributes\n    tmpToken = {\n      attrs: tmpAttrs\n    };\n\n    return  '<pre><code' + slf.renderAttrs(tmpToken) + '>'\n          + highlighted\n          + '</code></pre>\\n';\n  }\n\n\n  return  '<pre><code' + slf.renderAttrs(token) + '>'\n        + highlighted\n        + '</code></pre>\\n';\n};\n\n\ndefault_rules.image = function (tokens, idx, options, env, slf) {\n  var token = tokens[idx];\n\n  // \"alt\" attr MUST be set, even if empty. Because it's mandatory and\n  // should be placed on proper position for tests.\n  //\n  // Replace content with actual value\n\n  token.attrs[token.attrIndex('alt')][1] =\n    slf.renderInlineAsText(token.children, options, env);\n\n  return slf.renderToken(tokens, idx, options);\n};\n\n\ndefault_rules.hardbreak = function (tokens, idx, options /*, env */) {\n  return options.xhtmlOut ? '<br />\\n' : '<br>\\n';\n};\ndefault_rules.softbreak = function (tokens, idx, options /*, env */) {\n  return options.breaks ? (options.xhtmlOut ? '<br />\\n' : '<br>\\n') : '\\n';\n};\n\n\ndefault_rules.text = function (tokens, idx /*, options, env */) {\n  return escapeHtml(tokens[idx].content);\n};\n\n\ndefault_rules.html_block = function (tokens, idx /*, options, env */) {\n  return tokens[idx].content;\n};\ndefault_rules.html_inline = function (tokens, idx /*, options, env */) {\n  return tokens[idx].content;\n};\n\n\n/**\n * new Renderer()\n *\n * Creates new [[Renderer]] instance and fill [[Renderer#rules]] with defaults.\n **/\nfunction Renderer() {\n\n  /**\n   * Renderer#rules -> Object\n   *\n   * Contains render rules for tokens. Can be updated and extended.\n   *\n   * ##### Example\n   *\n   * ```javascript\n   * var md = require('markdown-it')();\n   *\n   * md.renderer.rules.strong_open  = function () { return '<b>'; };\n   * md.renderer.rules.strong_close = function () { return '</b>'; };\n   *\n   * var result = md.renderInline(...);\n   * ```\n   *\n   * Each rule is called as independent static function with fixed signature:\n   *\n   * ```javascript\n   * function my_token_render(tokens, idx, options, env, renderer) {\n   *   // ...\n   *   return renderedHTML;\n   * }\n   * ```\n   *\n   * See [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js)\n   * for more details and examples.\n   **/\n  this.rules = assign({}, default_rules);\n}\n\n\n/**\n * Renderer.renderAttrs(token) -> String\n *\n * Render token attributes to string.\n **/\nRenderer.prototype.renderAttrs = function renderAttrs(token) {\n  var i, l, result;\n\n  if (!token.attrs) { return ''; }\n\n  result = '';\n\n  for (i = 0, l = token.attrs.length; i < l; i++) {\n    result += ' ' + escapeHtml(token.attrs[i][0]) + '=\"' + escapeHtml(token.attrs[i][1]) + '\"';\n  }\n\n  return result;\n};\n\n\n/**\n * Renderer.renderToken(tokens, idx, options) -> String\n * - tokens (Array): list of tokens\n * - idx (Numbed): token index to render\n * - options (Object): params of parser instance\n *\n * Default token renderer. Can be overriden by custom function\n * in [[Renderer#rules]].\n **/\nRenderer.prototype.renderToken = function renderToken(tokens, idx, options) {\n  var nextToken,\n      result = '',\n      needLf = false,\n      token = tokens[idx];\n\n  // Tight list paragraphs\n  if (token.hidden) {\n    return '';\n  }\n\n  // Insert a newline between hidden paragraph and subsequent opening\n  // block-level tag.\n  //\n  // For example, here we should insert a newline before blockquote:\n  //  - a\n  //    >\n  //\n  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {\n    result += '\\n';\n  }\n\n  // Add token name, e.g. `<img`\n  result += (token.nesting === -1 ? '</' : '<') + token.tag;\n\n  // Encode attributes, e.g. `<img src=\"foo\"`\n  result += this.renderAttrs(token);\n\n  // Add a slash for self-closing tags, e.g. `<img src=\"foo\" /`\n  if (token.nesting === 0 && options.xhtmlOut) {\n    result += ' /';\n  }\n\n  // Check if we need to add a newline after this tag\n  if (token.block) {\n    needLf = true;\n\n    if (token.nesting === 1) {\n      if (idx + 1 < tokens.length) {\n        nextToken = tokens[idx + 1];\n\n        if (nextToken.type === 'inline' || nextToken.hidden) {\n          // Block-level tag containing an inline tag.\n          //\n          needLf = false;\n\n        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {\n          // Opening tag + closing tag of the same type. E.g. `<li></li>`.\n          //\n          needLf = false;\n        }\n      }\n    }\n  }\n\n  result += needLf ? '>\\n' : '>';\n\n  return result;\n};\n\n\n/**\n * Renderer.renderInline(tokens, options, env) -> String\n * - tokens (Array): list on block tokens to renter\n * - options (Object): params of parser instance\n * - env (Object): additional data from parsed input (references, for example)\n *\n * The same as [[Renderer.render]], but for single token of `inline` type.\n **/\nRenderer.prototype.renderInline = function (tokens, options, env) {\n  var type,\n      result = '',\n      rules = this.rules;\n\n  for (var i = 0, len = tokens.length; i < len; i++) {\n    type = tokens[i].type;\n\n    if (typeof rules[type] !== 'undefined') {\n      result += rules[type](tokens, i, options, env, this);\n    } else {\n      result += this.renderToken(tokens, i, options);\n    }\n  }\n\n  return result;\n};\n\n\n/** internal\n * Renderer.renderInlineAsText(tokens, options, env) -> String\n * - tokens (Array): list on block tokens to renter\n * - options (Object): params of parser instance\n * - env (Object): additional data from parsed input (references, for example)\n *\n * Special kludge for image `alt` attributes to conform CommonMark spec.\n * Don't try to use it! Spec requires to show `alt` content with stripped markup,\n * instead of simple escaping.\n **/\nRenderer.prototype.renderInlineAsText = function (tokens, options, env) {\n  var result = '';\n\n  for (var i = 0, len = tokens.length; i < len; i++) {\n    if (tokens[i].type === 'text') {\n      result += tokens[i].content;\n    } else if (tokens[i].type === 'image') {\n      result += this.renderInlineAsText(tokens[i].children, options, env);\n    } else if (tokens[i].type === 'softbreak') {\n      result += '\\n';\n    }\n  }\n\n  return result;\n};\n\n\n/**\n * Renderer.render(tokens, options, env) -> String\n * - tokens (Array): list on block tokens to renter\n * - options (Object): params of parser instance\n * - env (Object): additional data from parsed input (references, for example)\n *\n * Takes token stream and generates HTML. Probably, you will never need to call\n * this method directly.\n **/\nRenderer.prototype.render = function (tokens, options, env) {\n  var i, len, type,\n      result = '',\n      rules = this.rules;\n\n  for (i = 0, len = tokens.length; i < len; i++) {\n    type = tokens[i].type;\n\n    if (type === 'inline') {\n      result += this.renderInline(tokens[i].children, options, env);\n    } else if (typeof rules[type] !== 'undefined') {\n      result += rules[tokens[i].type](tokens, i, options, env, this);\n    } else {\n      result += this.renderToken(tokens, i, options, env);\n    }\n  }\n\n  return result;\n};\n\nmodule.exports = Renderer;\n"]},"metadata":{},"sourceType":"script"}