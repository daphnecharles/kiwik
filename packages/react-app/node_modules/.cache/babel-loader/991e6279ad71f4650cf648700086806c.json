{"ast":null,"code":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  var noOptions = {};\n  var nonWS = /[^\\s\\u00a0]/;\n  var Pos = CodeMirror.Pos,\n      cmp = CodeMirror.cmpPos;\n\n  function firstNonWS(str) {\n    var found = str.search(nonWS);\n    return found == -1 ? 0 : found;\n  }\n\n  CodeMirror.commands.toggleComment = function (cm) {\n    cm.toggleComment();\n  };\n\n  CodeMirror.defineExtension(\"toggleComment\", function (options) {\n    if (!options) options = noOptions;\n    var cm = this;\n    var minLine = Infinity,\n        ranges = this.listSelections(),\n        mode = null;\n\n    for (var i = ranges.length - 1; i >= 0; i--) {\n      var from = ranges[i].from(),\n          to = ranges[i].to();\n      if (from.line >= minLine) continue;\n      if (to.line >= minLine) to = Pos(minLine, 0);\n      minLine = from.line;\n\n      if (mode == null) {\n        if (cm.uncomment(from, to, options)) mode = \"un\";else {\n          cm.lineComment(from, to, options);\n          mode = \"line\";\n        }\n      } else if (mode == \"un\") {\n        cm.uncomment(from, to, options);\n      } else {\n        cm.lineComment(from, to, options);\n      }\n    }\n  }); // Rough heuristic to try and detect lines that are part of multi-line string\n\n  function probablyInsideString(cm, pos, line) {\n    return /\\bstring\\b/.test(cm.getTokenTypeAt(Pos(pos.line, 0))) && !/^[\\'\\\"\\`]/.test(line);\n  }\n\n  function getMode(cm, pos) {\n    var mode = cm.getMode();\n    return mode.useInnerComments === false || !mode.innerMode ? mode : cm.getModeAt(pos);\n  }\n\n  CodeMirror.defineExtension(\"lineComment\", function (from, to, options) {\n    if (!options) options = noOptions;\n    var self = this,\n        mode = getMode(self, from);\n    var firstLine = self.getLine(from.line);\n    if (firstLine == null || probablyInsideString(self, from, firstLine)) return;\n    var commentString = options.lineComment || mode.lineComment;\n\n    if (!commentString) {\n      if (options.blockCommentStart || mode.blockCommentStart) {\n        options.fullLines = true;\n        self.blockComment(from, to, options);\n      }\n\n      return;\n    }\n\n    var end = Math.min(to.ch != 0 || to.line == from.line ? to.line + 1 : to.line, self.lastLine() + 1);\n    var pad = options.padding == null ? \" \" : options.padding;\n    var blankLines = options.commentBlankLines || from.line == to.line;\n    self.operation(function () {\n      if (options.indent) {\n        var baseString = null;\n\n        for (var i = from.line; i < end; ++i) {\n          var line = self.getLine(i);\n          var whitespace = line.slice(0, firstNonWS(line));\n\n          if (baseString == null || baseString.length > whitespace.length) {\n            baseString = whitespace;\n          }\n        }\n\n        for (var i = from.line; i < end; ++i) {\n          var line = self.getLine(i),\n              cut = baseString.length;\n          if (!blankLines && !nonWS.test(line)) continue;\n          if (line.slice(0, cut) != baseString) cut = firstNonWS(line);\n          self.replaceRange(baseString + commentString + pad, Pos(i, 0), Pos(i, cut));\n        }\n      } else {\n        for (var i = from.line; i < end; ++i) {\n          if (blankLines || nonWS.test(self.getLine(i))) self.replaceRange(commentString + pad, Pos(i, 0));\n        }\n      }\n    });\n  });\n  CodeMirror.defineExtension(\"blockComment\", function (from, to, options) {\n    if (!options) options = noOptions;\n    var self = this,\n        mode = getMode(self, from);\n    var startString = options.blockCommentStart || mode.blockCommentStart;\n    var endString = options.blockCommentEnd || mode.blockCommentEnd;\n\n    if (!startString || !endString) {\n      if ((options.lineComment || mode.lineComment) && options.fullLines != false) self.lineComment(from, to, options);\n      return;\n    }\n\n    if (/\\bcomment\\b/.test(self.getTokenTypeAt(Pos(from.line, 0)))) return;\n    var end = Math.min(to.line, self.lastLine());\n    if (end != from.line && to.ch == 0 && nonWS.test(self.getLine(end))) --end;\n    var pad = options.padding == null ? \" \" : options.padding;\n    if (from.line > end) return;\n    self.operation(function () {\n      if (options.fullLines != false) {\n        var lastLineHasText = nonWS.test(self.getLine(end));\n        self.replaceRange(pad + endString, Pos(end));\n        self.replaceRange(startString + pad, Pos(from.line, 0));\n        var lead = options.blockCommentLead || mode.blockCommentLead;\n        if (lead != null) for (var i = from.line + 1; i <= end; ++i) {\n          if (i != end || lastLineHasText) self.replaceRange(lead + pad, Pos(i, 0));\n        }\n      } else {\n        var atCursor = cmp(self.getCursor(\"to\"), to) == 0,\n            empty = !self.somethingSelected();\n        self.replaceRange(endString, to);\n        if (atCursor) self.setSelection(empty ? to : self.getCursor(\"from\"), to);\n        self.replaceRange(startString, from);\n      }\n    });\n  });\n  CodeMirror.defineExtension(\"uncomment\", function (from, to, options) {\n    if (!options) options = noOptions;\n    var self = this,\n        mode = getMode(self, from);\n    var end = Math.min(to.ch != 0 || to.line == from.line ? to.line : to.line - 1, self.lastLine()),\n        start = Math.min(from.line, end); // Try finding line comments\n\n    var lineString = options.lineComment || mode.lineComment,\n        lines = [];\n    var pad = options.padding == null ? \" \" : options.padding,\n        didSomething;\n\n    lineComment: {\n      if (!lineString) break lineComment;\n\n      for (var i = start; i <= end; ++i) {\n        var line = self.getLine(i);\n        var found = line.indexOf(lineString);\n        if (found > -1 && !/comment/.test(self.getTokenTypeAt(Pos(i, found + 1)))) found = -1;\n        if (found == -1 && nonWS.test(line)) break lineComment;\n        if (found > -1 && nonWS.test(line.slice(0, found))) break lineComment;\n        lines.push(line);\n      }\n\n      self.operation(function () {\n        for (var i = start; i <= end; ++i) {\n          var line = lines[i - start];\n          var pos = line.indexOf(lineString),\n              endPos = pos + lineString.length;\n          if (pos < 0) continue;\n          if (line.slice(endPos, endPos + pad.length) == pad) endPos += pad.length;\n          didSomething = true;\n          self.replaceRange(\"\", Pos(i, pos), Pos(i, endPos));\n        }\n      });\n      if (didSomething) return true;\n    } // Try block comments\n\n\n    var startString = options.blockCommentStart || mode.blockCommentStart;\n    var endString = options.blockCommentEnd || mode.blockCommentEnd;\n    if (!startString || !endString) return false;\n    var lead = options.blockCommentLead || mode.blockCommentLead;\n    var startLine = self.getLine(start),\n        open = startLine.indexOf(startString);\n    if (open == -1) return false;\n    var endLine = end == start ? startLine : self.getLine(end);\n    var close = endLine.indexOf(endString, end == start ? open + startString.length : 0);\n    var insideStart = Pos(start, open + 1),\n        insideEnd = Pos(end, close + 1);\n    if (close == -1 || !/comment/.test(self.getTokenTypeAt(insideStart)) || !/comment/.test(self.getTokenTypeAt(insideEnd)) || self.getRange(insideStart, insideEnd, \"\\n\").indexOf(endString) > -1) return false; // Avoid killing block comments completely outside the selection.\n    // Positions of the last startString before the start of the selection, and the first endString after it.\n\n    var lastStart = startLine.lastIndexOf(startString, from.ch);\n    var firstEnd = lastStart == -1 ? -1 : startLine.slice(0, from.ch).indexOf(endString, lastStart + startString.length);\n    if (lastStart != -1 && firstEnd != -1 && firstEnd + endString.length != from.ch) return false; // Positions of the first endString after the end of the selection, and the last startString before it.\n\n    firstEnd = endLine.indexOf(endString, to.ch);\n    var almostLastStart = endLine.slice(to.ch).lastIndexOf(startString, firstEnd - to.ch);\n    lastStart = firstEnd == -1 || almostLastStart == -1 ? -1 : to.ch + almostLastStart;\n    if (firstEnd != -1 && lastStart != -1 && lastStart != to.ch) return false;\n    self.operation(function () {\n      self.replaceRange(\"\", Pos(end, close - (pad && endLine.slice(close - pad.length, close) == pad ? pad.length : 0)), Pos(end, close + endString.length));\n      var openEnd = open + startString.length;\n      if (pad && startLine.slice(openEnd, openEnd + pad.length) == pad) openEnd += pad.length;\n      self.replaceRange(\"\", Pos(start, open), Pos(start, openEnd));\n      if (lead) for (var i = start + 1; i <= end; ++i) {\n        var line = self.getLine(i),\n            found = line.indexOf(lead);\n        if (found == -1 || nonWS.test(line.slice(0, found))) continue;\n        var foundEnd = found + lead.length;\n        if (pad && line.slice(foundEnd, foundEnd + pad.length) == pad) foundEnd += pad.length;\n        self.replaceRange(\"\", Pos(i, found), Pos(i, foundEnd));\n      }\n    });\n    return true;\n  });\n});","map":{"version":3,"sources":["/Users/sam/Desktop/kiwik/node_modules/codemirror/addon/comment/comment.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","noOptions","nonWS","Pos","cmp","cmpPos","firstNonWS","str","found","search","commands","toggleComment","cm","defineExtension","options","minLine","Infinity","ranges","listSelections","mode","i","length","from","to","line","uncomment","lineComment","probablyInsideString","pos","test","getTokenTypeAt","getMode","useInnerComments","innerMode","getModeAt","self","firstLine","getLine","commentString","blockCommentStart","fullLines","blockComment","end","Math","min","ch","lastLine","pad","padding","blankLines","commentBlankLines","operation","indent","baseString","whitespace","slice","cut","replaceRange","startString","endString","blockCommentEnd","lastLineHasText","lead","blockCommentLead","atCursor","getCursor","empty","somethingSelected","setSelection","start","lineString","lines","didSomething","indexOf","push","endPos","startLine","open","endLine","close","insideStart","insideEnd","getRange","lastStart","lastIndexOf","firstEnd","almostLastStart","openEnd","foundEnd"],"mappings":"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","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var noOptions = {};\n  var nonWS = /[^\\s\\u00a0]/;\n  var Pos = CodeMirror.Pos, cmp = CodeMirror.cmpPos;\n\n  function firstNonWS(str) {\n    var found = str.search(nonWS);\n    return found == -1 ? 0 : found;\n  }\n\n  CodeMirror.commands.toggleComment = function(cm) {\n    cm.toggleComment();\n  };\n\n  CodeMirror.defineExtension(\"toggleComment\", function(options) {\n    if (!options) options = noOptions;\n    var cm = this;\n    var minLine = Infinity, ranges = this.listSelections(), mode = null;\n    for (var i = ranges.length - 1; i >= 0; i--) {\n      var from = ranges[i].from(), to = ranges[i].to();\n      if (from.line >= minLine) continue;\n      if (to.line >= minLine) to = Pos(minLine, 0);\n      minLine = from.line;\n      if (mode == null) {\n        if (cm.uncomment(from, to, options)) mode = \"un\";\n        else { cm.lineComment(from, to, options); mode = \"line\"; }\n      } else if (mode == \"un\") {\n        cm.uncomment(from, to, options);\n      } else {\n        cm.lineComment(from, to, options);\n      }\n    }\n  });\n\n  // Rough heuristic to try and detect lines that are part of multi-line string\n  function probablyInsideString(cm, pos, line) {\n    return /\\bstring\\b/.test(cm.getTokenTypeAt(Pos(pos.line, 0))) && !/^[\\'\\\"\\`]/.test(line)\n  }\n\n  function getMode(cm, pos) {\n    var mode = cm.getMode()\n    return mode.useInnerComments === false || !mode.innerMode ? mode : cm.getModeAt(pos)\n  }\n\n  CodeMirror.defineExtension(\"lineComment\", function(from, to, options) {\n    if (!options) options = noOptions;\n    var self = this, mode = getMode(self, from);\n    var firstLine = self.getLine(from.line);\n    if (firstLine == null || probablyInsideString(self, from, firstLine)) return;\n\n    var commentString = options.lineComment || mode.lineComment;\n    if (!commentString) {\n      if (options.blockCommentStart || mode.blockCommentStart) {\n        options.fullLines = true;\n        self.blockComment(from, to, options);\n      }\n      return;\n    }\n\n    var end = Math.min(to.ch != 0 || to.line == from.line ? to.line + 1 : to.line, self.lastLine() + 1);\n    var pad = options.padding == null ? \" \" : options.padding;\n    var blankLines = options.commentBlankLines || from.line == to.line;\n\n    self.operation(function() {\n      if (options.indent) {\n        var baseString = null;\n        for (var i = from.line; i < end; ++i) {\n          var line = self.getLine(i);\n          var whitespace = line.slice(0, firstNonWS(line));\n          if (baseString == null || baseString.length > whitespace.length) {\n            baseString = whitespace;\n          }\n        }\n        for (var i = from.line; i < end; ++i) {\n          var line = self.getLine(i), cut = baseString.length;\n          if (!blankLines && !nonWS.test(line)) continue;\n          if (line.slice(0, cut) != baseString) cut = firstNonWS(line);\n          self.replaceRange(baseString + commentString + pad, Pos(i, 0), Pos(i, cut));\n        }\n      } else {\n        for (var i = from.line; i < end; ++i) {\n          if (blankLines || nonWS.test(self.getLine(i)))\n            self.replaceRange(commentString + pad, Pos(i, 0));\n        }\n      }\n    });\n  });\n\n  CodeMirror.defineExtension(\"blockComment\", function(from, to, options) {\n    if (!options) options = noOptions;\n    var self = this, mode = getMode(self, from);\n    var startString = options.blockCommentStart || mode.blockCommentStart;\n    var endString = options.blockCommentEnd || mode.blockCommentEnd;\n    if (!startString || !endString) {\n      if ((options.lineComment || mode.lineComment) && options.fullLines != false)\n        self.lineComment(from, to, options);\n      return;\n    }\n    if (/\\bcomment\\b/.test(self.getTokenTypeAt(Pos(from.line, 0)))) return\n\n    var end = Math.min(to.line, self.lastLine());\n    if (end != from.line && to.ch == 0 && nonWS.test(self.getLine(end))) --end;\n\n    var pad = options.padding == null ? \" \" : options.padding;\n    if (from.line > end) return;\n\n    self.operation(function() {\n      if (options.fullLines != false) {\n        var lastLineHasText = nonWS.test(self.getLine(end));\n        self.replaceRange(pad + endString, Pos(end));\n        self.replaceRange(startString + pad, Pos(from.line, 0));\n        var lead = options.blockCommentLead || mode.blockCommentLead;\n        if (lead != null) for (var i = from.line + 1; i <= end; ++i)\n          if (i != end || lastLineHasText)\n            self.replaceRange(lead + pad, Pos(i, 0));\n      } else {\n        var atCursor = cmp(self.getCursor(\"to\"), to) == 0, empty = !self.somethingSelected()\n        self.replaceRange(endString, to);\n        if (atCursor) self.setSelection(empty ? to : self.getCursor(\"from\"), to)\n        self.replaceRange(startString, from);\n      }\n    });\n  });\n\n  CodeMirror.defineExtension(\"uncomment\", function(from, to, options) {\n    if (!options) options = noOptions;\n    var self = this, mode = getMode(self, from);\n    var end = Math.min(to.ch != 0 || to.line == from.line ? to.line : to.line - 1, self.lastLine()), start = Math.min(from.line, end);\n\n    // Try finding line comments\n    var lineString = options.lineComment || mode.lineComment, lines = [];\n    var pad = options.padding == null ? \" \" : options.padding, didSomething;\n    lineComment: {\n      if (!lineString) break lineComment;\n      for (var i = start; i <= end; ++i) {\n        var line = self.getLine(i);\n        var found = line.indexOf(lineString);\n        if (found > -1 && !/comment/.test(self.getTokenTypeAt(Pos(i, found + 1)))) found = -1;\n        if (found == -1 && nonWS.test(line)) break lineComment;\n        if (found > -1 && nonWS.test(line.slice(0, found))) break lineComment;\n        lines.push(line);\n      }\n      self.operation(function() {\n        for (var i = start; i <= end; ++i) {\n          var line = lines[i - start];\n          var pos = line.indexOf(lineString), endPos = pos + lineString.length;\n          if (pos < 0) continue;\n          if (line.slice(endPos, endPos + pad.length) == pad) endPos += pad.length;\n          didSomething = true;\n          self.replaceRange(\"\", Pos(i, pos), Pos(i, endPos));\n        }\n      });\n      if (didSomething) return true;\n    }\n\n    // Try block comments\n    var startString = options.blockCommentStart || mode.blockCommentStart;\n    var endString = options.blockCommentEnd || mode.blockCommentEnd;\n    if (!startString || !endString) return false;\n    var lead = options.blockCommentLead || mode.blockCommentLead;\n    var startLine = self.getLine(start), open = startLine.indexOf(startString)\n    if (open == -1) return false\n    var endLine = end == start ? startLine : self.getLine(end)\n    var close = endLine.indexOf(endString, end == start ? open + startString.length : 0);\n    var insideStart = Pos(start, open + 1), insideEnd = Pos(end, close + 1)\n    if (close == -1 ||\n        !/comment/.test(self.getTokenTypeAt(insideStart)) ||\n        !/comment/.test(self.getTokenTypeAt(insideEnd)) ||\n        self.getRange(insideStart, insideEnd, \"\\n\").indexOf(endString) > -1)\n      return false;\n\n    // Avoid killing block comments completely outside the selection.\n    // Positions of the last startString before the start of the selection, and the first endString after it.\n    var lastStart = startLine.lastIndexOf(startString, from.ch);\n    var firstEnd = lastStart == -1 ? -1 : startLine.slice(0, from.ch).indexOf(endString, lastStart + startString.length);\n    if (lastStart != -1 && firstEnd != -1 && firstEnd + endString.length != from.ch) return false;\n    // Positions of the first endString after the end of the selection, and the last startString before it.\n    firstEnd = endLine.indexOf(endString, to.ch);\n    var almostLastStart = endLine.slice(to.ch).lastIndexOf(startString, firstEnd - to.ch);\n    lastStart = (firstEnd == -1 || almostLastStart == -1) ? -1 : to.ch + almostLastStart;\n    if (firstEnd != -1 && lastStart != -1 && lastStart != to.ch) return false;\n\n    self.operation(function() {\n      self.replaceRange(\"\", Pos(end, close - (pad && endLine.slice(close - pad.length, close) == pad ? pad.length : 0)),\n                        Pos(end, close + endString.length));\n      var openEnd = open + startString.length;\n      if (pad && startLine.slice(openEnd, openEnd + pad.length) == pad) openEnd += pad.length;\n      self.replaceRange(\"\", Pos(start, open), Pos(start, openEnd));\n      if (lead) for (var i = start + 1; i <= end; ++i) {\n        var line = self.getLine(i), found = line.indexOf(lead);\n        if (found == -1 || nonWS.test(line.slice(0, found))) continue;\n        var foundEnd = found + lead.length;\n        if (pad && line.slice(foundEnd, foundEnd + pad.length) == pad) foundEnd += pad.length;\n        self.replaceRange(\"\", Pos(i, found), Pos(i, foundEnd));\n      }\n    });\n    return true;\n  });\n});\n"]},"metadata":{},"sourceType":"script"}