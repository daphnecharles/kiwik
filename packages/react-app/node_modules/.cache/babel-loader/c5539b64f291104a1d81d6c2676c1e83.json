{"ast":null,"code":"// Process ![image](<src> \"title\")\n'use strict';\n\nvar normalizeReference = require('../common/utils').normalizeReference;\n\nvar isSpace = require('../common/utils').isSpace;\n\nmodule.exports = function image(state, silent) {\n  var attrs,\n      code,\n      content,\n      label,\n      labelEnd,\n      labelStart,\n      pos,\n      ref,\n      res,\n      title,\n      token,\n      tokens,\n      start,\n      href = '',\n      oldPos = state.pos,\n      max = state.posMax;\n\n  if (state.src.charCodeAt(state.pos) !== 0x21\n  /* ! */\n  ) {\n    return false;\n  }\n\n  if (state.src.charCodeAt(state.pos + 1) !== 0x5B\n  /* [ */\n  ) {\n    return false;\n  }\n\n  labelStart = state.pos + 2;\n  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false); // parser failed to find ']', so it's not a valid link\n\n  if (labelEnd < 0) {\n    return false;\n  }\n\n  pos = labelEnd + 1;\n\n  if (pos < max && state.src.charCodeAt(pos) === 0x28\n  /* ( */\n  ) {\n    //\n    // Inline link\n    //\n    // [link](  <href>  \"title\"  )\n    //        ^^ skipping these spaces\n    pos++;\n\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n\n      if (!isSpace(code) && code !== 0x0A) {\n        break;\n      }\n    }\n\n    if (pos >= max) {\n      return false;\n    } // [link](  <href>  \"title\"  )\n    //          ^^^^^^ parsing link destination\n\n\n    start = pos;\n    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);\n\n    if (res.ok) {\n      href = state.md.normalizeLink(res.str);\n\n      if (state.md.validateLink(href)) {\n        pos = res.pos;\n      } else {\n        href = '';\n      }\n    } // [link](  <href>  \"title\"  )\n    //                ^^ skipping these spaces\n\n\n    start = pos;\n\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n\n      if (!isSpace(code) && code !== 0x0A) {\n        break;\n      }\n    } // [link](  <href>  \"title\"  )\n    //                  ^^^^^^^ parsing link title\n\n\n    res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);\n\n    if (pos < max && start !== pos && res.ok) {\n      title = res.str;\n      pos = res.pos; // [link](  <href>  \"title\"  )\n      //                         ^^ skipping these spaces\n\n      for (; pos < max; pos++) {\n        code = state.src.charCodeAt(pos);\n\n        if (!isSpace(code) && code !== 0x0A) {\n          break;\n        }\n      }\n    } else {\n      title = '';\n    }\n\n    if (pos >= max || state.src.charCodeAt(pos) !== 0x29\n    /* ) */\n    ) {\n      state.pos = oldPos;\n      return false;\n    }\n\n    pos++;\n  } else {\n    //\n    // Link reference\n    //\n    if (typeof state.env.references === 'undefined') {\n      return false;\n    }\n\n    if (pos < max && state.src.charCodeAt(pos) === 0x5B\n    /* [ */\n    ) {\n      start = pos + 1;\n      pos = state.md.helpers.parseLinkLabel(state, pos);\n\n      if (pos >= 0) {\n        label = state.src.slice(start, pos++);\n      } else {\n        pos = labelEnd + 1;\n      }\n    } else {\n      pos = labelEnd + 1;\n    } // covers label === '' and label === undefined\n    // (collapsed reference link and shortcut reference link respectively)\n\n\n    if (!label) {\n      label = state.src.slice(labelStart, labelEnd);\n    }\n\n    ref = state.env.references[normalizeReference(label)];\n\n    if (!ref) {\n      state.pos = oldPos;\n      return false;\n    }\n\n    href = ref.href;\n    title = ref.title;\n  } //\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n\n\n  if (!silent) {\n    content = state.src.slice(labelStart, labelEnd);\n    state.md.inline.parse(content, state.md, state.env, tokens = []);\n    token = state.push('image', 'img', 0);\n    token.attrs = attrs = [['src', href], ['alt', '']];\n    token.children = tokens;\n    token.content = content;\n\n    if (title) {\n      attrs.push(['title', title]);\n    }\n  }\n\n  state.pos = pos;\n  state.posMax = max;\n  return true;\n};","map":{"version":3,"sources":["/Users/sam/Desktop/kiwik/node_modules/markdown-it/lib/rules_inline/image.js"],"names":["normalizeReference","require","isSpace","module","exports","image","state","silent","attrs","code","content","label","labelEnd","labelStart","pos","ref","res","title","token","tokens","start","href","oldPos","max","posMax","src","charCodeAt","md","helpers","parseLinkLabel","parseLinkDestination","ok","normalizeLink","str","validateLink","parseLinkTitle","env","references","slice","inline","parse","push","children"],"mappings":"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","sourcesContent":["// Process ![image](<src> \"title\")\n\n'use strict';\n\nvar normalizeReference   = require('../common/utils').normalizeReference;\nvar isSpace              = require('../common/utils').isSpace;\n\n\nmodule.exports = function image(state, silent) {\n  var attrs,\n      code,\n      content,\n      label,\n      labelEnd,\n      labelStart,\n      pos,\n      ref,\n      res,\n      title,\n      token,\n      tokens,\n      start,\n      href = '',\n      oldPos = state.pos,\n      max = state.posMax;\n\n  if (state.src.charCodeAt(state.pos) !== 0x21/* ! */) { return false; }\n  if (state.src.charCodeAt(state.pos + 1) !== 0x5B/* [ */) { return false; }\n\n  labelStart = state.pos + 2;\n  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);\n\n  // parser failed to find ']', so it's not a valid link\n  if (labelEnd < 0) { return false; }\n\n  pos = labelEnd + 1;\n  if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {\n    //\n    // Inline link\n    //\n\n    // [link](  <href>  \"title\"  )\n    //        ^^ skipping these spaces\n    pos++;\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n      if (!isSpace(code) && code !== 0x0A) { break; }\n    }\n    if (pos >= max) { return false; }\n\n    // [link](  <href>  \"title\"  )\n    //          ^^^^^^ parsing link destination\n    start = pos;\n    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);\n    if (res.ok) {\n      href = state.md.normalizeLink(res.str);\n      if (state.md.validateLink(href)) {\n        pos = res.pos;\n      } else {\n        href = '';\n      }\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                ^^ skipping these spaces\n    start = pos;\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n      if (!isSpace(code) && code !== 0x0A) { break; }\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                  ^^^^^^^ parsing link title\n    res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);\n    if (pos < max && start !== pos && res.ok) {\n      title = res.str;\n      pos = res.pos;\n\n      // [link](  <href>  \"title\"  )\n      //                         ^^ skipping these spaces\n      for (; pos < max; pos++) {\n        code = state.src.charCodeAt(pos);\n        if (!isSpace(code) && code !== 0x0A) { break; }\n      }\n    } else {\n      title = '';\n    }\n\n    if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {\n      state.pos = oldPos;\n      return false;\n    }\n    pos++;\n  } else {\n    //\n    // Link reference\n    //\n    if (typeof state.env.references === 'undefined') { return false; }\n\n    if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {\n      start = pos + 1;\n      pos = state.md.helpers.parseLinkLabel(state, pos);\n      if (pos >= 0) {\n        label = state.src.slice(start, pos++);\n      } else {\n        pos = labelEnd + 1;\n      }\n    } else {\n      pos = labelEnd + 1;\n    }\n\n    // covers label === '' and label === undefined\n    // (collapsed reference link and shortcut reference link respectively)\n    if (!label) { label = state.src.slice(labelStart, labelEnd); }\n\n    ref = state.env.references[normalizeReference(label)];\n    if (!ref) {\n      state.pos = oldPos;\n      return false;\n    }\n    href = ref.href;\n    title = ref.title;\n  }\n\n  //\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n  if (!silent) {\n    content = state.src.slice(labelStart, labelEnd);\n\n    state.md.inline.parse(\n      content,\n      state.md,\n      state.env,\n      tokens = []\n    );\n\n    token          = state.push('image', 'img', 0);\n    token.attrs    = attrs = [ [ 'src', href ], [ 'alt', '' ] ];\n    token.children = tokens;\n    token.content  = content;\n\n    if (title) {\n      attrs.push([ 'title', title ]);\n    }\n  }\n\n  state.pos = pos;\n  state.posMax = max;\n  return true;\n};\n"]},"metadata":{},"sourceType":"script"}