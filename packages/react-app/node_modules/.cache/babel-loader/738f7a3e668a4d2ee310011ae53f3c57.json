{"ast":null,"code":"var _regeneratorRuntime = require(\"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar pify = require('pify');\n\nvar BaseBlockTracker = require('./base');\n\nvar sec = 1000;\n\nvar PollingBlockTracker = /*#__PURE__*/function (_BaseBlockTracker) {\n  \"use strict\";\n\n  _inherits(PollingBlockTracker, _BaseBlockTracker);\n\n  var _super = _createSuper(PollingBlockTracker);\n\n  function PollingBlockTracker() {\n    var _this;\n\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, PollingBlockTracker);\n\n    // parse + validate args\n    if (!opts.provider) throw new Error('PollingBlockTracker - no provider specified.');\n    var pollingInterval = opts.pollingInterval || 20 * sec;\n    var retryTimeout = opts.retryTimeout || pollingInterval / 10;\n    var keepEventLoopActive = opts.keepEventLoopActive !== undefined ? opts.keepEventLoopActive : true;\n    var setSkipCacheFlag = opts.setSkipCacheFlag || false; // BaseBlockTracker constructor\n\n    _this = _super.call(this, Object.assign({\n      blockResetDuration: pollingInterval\n    }, opts)); // config\n\n    _this._provider = opts.provider;\n    _this._pollingInterval = pollingInterval;\n    _this._retryTimeout = retryTimeout;\n    _this._keepEventLoopActive = keepEventLoopActive;\n    _this._setSkipCacheFlag = setSkipCacheFlag;\n    return _this;\n  } //\n  // public\n  //\n  // trigger block polling\n\n\n  _createClass(PollingBlockTracker, [{\n    key: \"checkForLatestBlock\",\n    value: function () {\n      var _checkForLatestBlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this._updateLatestBlock();\n\n              case 2:\n                _context.next = 4;\n                return this.getLatestBlock();\n\n              case 4:\n                return _context.abrupt(\"return\", _context.sent);\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function checkForLatestBlock() {\n        return _checkForLatestBlock.apply(this, arguments);\n      }\n\n      return checkForLatestBlock;\n    }() //\n    // private\n    //\n\n  }, {\n    key: \"_start\",\n    value: function _start() {\n      var _this2 = this;\n\n      this._performSync().catch(function (err) {\n        return _this2.emit('error', err);\n      });\n    }\n  }, {\n    key: \"_performSync\",\n    value: function () {\n      var _performSync2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var newErr;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!this._isRunning) {\n                  _context2.next = 16;\n                  break;\n                }\n\n                _context2.prev = 1;\n                _context2.next = 4;\n                return this._updateLatestBlock();\n\n              case 4:\n                _context2.next = 6;\n                return timeout(this._pollingInterval, !this._keepEventLoopActive);\n\n              case 6:\n                _context2.next = 14;\n                break;\n\n              case 8:\n                _context2.prev = 8;\n                _context2.t0 = _context2[\"catch\"](1);\n                newErr = new Error(\"PollingBlockTracker - encountered an error while attempting to update latest block:\\n\".concat(_context2.t0.stack));\n\n                try {\n                  this.emit('error', newErr);\n                } catch (emitErr) {\n                  console.error(newErr);\n                }\n\n                _context2.next = 14;\n                return timeout(this._retryTimeout, !this._keepEventLoopActive);\n\n              case 14:\n                _context2.next = 0;\n                break;\n\n              case 16:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[1, 8]]);\n      }));\n\n      function _performSync() {\n        return _performSync2.apply(this, arguments);\n      }\n\n      return _performSync;\n    }()\n  }, {\n    key: \"_updateLatestBlock\",\n    value: function () {\n      var _updateLatestBlock2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var latestBlock;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this._fetchLatestBlock();\n\n              case 2:\n                latestBlock = _context3.sent;\n\n                this._newPotentialLatest(latestBlock);\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function _updateLatestBlock() {\n        return _updateLatestBlock2.apply(this, arguments);\n      }\n\n      return _updateLatestBlock;\n    }()\n  }, {\n    key: \"_fetchLatestBlock\",\n    value: function () {\n      var _fetchLatestBlock2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var _this3 = this;\n\n        var req, res;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                req = {\n                  jsonrpc: \"2.0\",\n                  id: 1,\n                  method: 'eth_blockNumber',\n                  params: []\n                };\n                if (this._setSkipCacheFlag) req.skipCache = true;\n                _context4.next = 4;\n                return pify(function (cb) {\n                  return _this3._provider.sendAsync(req, cb);\n                })();\n\n              case 4:\n                res = _context4.sent;\n\n                if (!res.error) {\n                  _context4.next = 7;\n                  break;\n                }\n\n                throw new Error(\"PollingBlockTracker - encountered error fetching block:\\n\".concat(res.error));\n\n              case 7:\n                return _context4.abrupt(\"return\", res.result);\n\n              case 8:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function _fetchLatestBlock() {\n        return _fetchLatestBlock2.apply(this, arguments);\n      }\n\n      return _fetchLatestBlock;\n    }()\n  }]);\n\n  return PollingBlockTracker;\n}(BaseBlockTracker);\n\nmodule.exports = PollingBlockTracker;\n\nfunction timeout(duration, unref) {\n  return new Promise(function (resolve) {\n    var timoutRef = setTimeout(resolve, duration); // don't keep process open\n\n    if (timoutRef.unref && unref) {\n      timoutRef.unref();\n    }\n  });\n}","map":{"version":3,"sources":["/Users/sam/Desktop/kiwik/node_modules/eth-block-tracker/src/polling.js"],"names":["pify","require","BaseBlockTracker","sec","PollingBlockTracker","opts","provider","Error","pollingInterval","retryTimeout","keepEventLoopActive","undefined","setSkipCacheFlag","Object","assign","blockResetDuration","_provider","_pollingInterval","_retryTimeout","_keepEventLoopActive","_setSkipCacheFlag","_updateLatestBlock","getLatestBlock","_performSync","catch","err","emit","_isRunning","timeout","newErr","stack","emitErr","console","error","_fetchLatestBlock","latestBlock","_newPotentialLatest","req","jsonrpc","id","method","params","skipCache","cb","sendAsync","res","result","module","exports","duration","unref","Promise","resolve","timoutRef","setTimeout"],"mappings":"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","sourcesContent":["const pify = require('pify')\nconst BaseBlockTracker = require('./base')\n\nconst sec = 1000\n\nclass PollingBlockTracker extends BaseBlockTracker {\n\n  constructor (opts = {}) {\n    // parse + validate args\n    if (!opts.provider) throw new Error('PollingBlockTracker - no provider specified.')\n    const pollingInterval = opts.pollingInterval || 20 * sec\n    const retryTimeout = opts.retryTimeout || pollingInterval / 10\n    const keepEventLoopActive = opts.keepEventLoopActive !== undefined ? opts.keepEventLoopActive : true\n    const setSkipCacheFlag = opts.setSkipCacheFlag || false\n    // BaseBlockTracker constructor\n    super(Object.assign({\n      blockResetDuration: pollingInterval,\n    }, opts))\n    // config\n    this._provider = opts.provider\n    this._pollingInterval = pollingInterval\n    this._retryTimeout = retryTimeout\n    this._keepEventLoopActive = keepEventLoopActive\n    this._setSkipCacheFlag = setSkipCacheFlag\n  }\n\n  //\n  // public\n  //\n\n  // trigger block polling\n  async checkForLatestBlock () {\n    await this._updateLatestBlock()\n    return await this.getLatestBlock()\n  }\n\n  //\n  // private\n  //\n\n  _start () {\n    this._performSync().catch(err => this.emit('error', err))\n  }\n\n  async _performSync () {\n    while (this._isRunning) {\n      try {\n        await this._updateLatestBlock()\n        await timeout(this._pollingInterval, !this._keepEventLoopActive)\n      } catch (err) {\n        const newErr = new Error(`PollingBlockTracker - encountered an error while attempting to update latest block:\\n${err.stack}`)\n        try {\n          this.emit('error', newErr)\n        } catch (emitErr) {\n          console.error(newErr)\n        }\n        await timeout(this._retryTimeout, !this._keepEventLoopActive)\n      }\n    }\n  }\n\n  async _updateLatestBlock () {\n    // fetch + set latest block\n    const latestBlock = await this._fetchLatestBlock()\n    this._newPotentialLatest(latestBlock)\n  }\n\n  async _fetchLatestBlock () {\n    const req = { jsonrpc: \"2.0\", id: 1, method: 'eth_blockNumber', params: [] }\n    if (this._setSkipCacheFlag) req.skipCache = true\n    const res = await pify((cb) => this._provider.sendAsync(req, cb))()\n    if (res.error) throw new Error(`PollingBlockTracker - encountered error fetching block:\\n${res.error}`)\n    return res.result\n  }\n\n}\n\nmodule.exports = PollingBlockTracker\n\nfunction timeout (duration, unref) {\n  return new Promise(resolve => {\n    const timoutRef = setTimeout(resolve, duration)\n    // don't keep process open\n    if (timoutRef.unref && unref) {\n      timoutRef.unref()\n    }\n  })\n}\n"]},"metadata":{},"sourceType":"script"}