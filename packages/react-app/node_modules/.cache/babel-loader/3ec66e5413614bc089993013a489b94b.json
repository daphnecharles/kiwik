{"ast":null,"code":"import _regeneratorRuntime from \"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _objectSpread from \"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _asyncToGenerator from \"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { notification } from \"antd\";\nimport Notify from \"bnc-notify\";\nimport { BLOCKNATIVE_DAPPID } from \"../constants\";\n\nvar _require = require(\"ethers\"),\n    ethers = _require.ethers; // this should probably just be renamed to \"notifier\"\n// it is basically just a wrapper around BlockNative's wonderful Notify.js\n// https://docs.blocknative.com/notify\n\n\nvar callbacks = {};\nvar DEBUG = true;\nexport default function Transactor(providerOrSigner, gasPrice, etherscan) {\n  if (typeof providerOrSigner !== \"undefined\") {\n    // eslint-disable-next-line consistent-return\n    return /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(tx, callback) {\n        var signer, network, provider, options, notify, etherscanNetwork, etherscanTxUrl, result, _notify$hash, emitter, txResult, listeningInterval, message, obj, errorObj;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(ethers.Signer.isSigner(providerOrSigner) === true)) {\n                  _context2.next = 11;\n                  break;\n                }\n\n                provider = providerOrSigner.provider;\n                signer = providerOrSigner;\n                _context2.t0 = providerOrSigner.provider;\n\n                if (!_context2.t0) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                _context2.next = 7;\n                return providerOrSigner.provider.getNetwork();\n\n              case 7:\n                _context2.t0 = _context2.sent;\n\n              case 8:\n                network = _context2.t0;\n                _context2.next = 17;\n                break;\n\n              case 11:\n                if (!providerOrSigner._isProvider) {\n                  _context2.next = 17;\n                  break;\n                }\n\n                provider = providerOrSigner;\n                signer = providerOrSigner.getSigner();\n                _context2.next = 16;\n                return providerOrSigner.getNetwork();\n\n              case 16:\n                network = _context2.sent;\n\n              case 17:\n                console.log(\"network\", network);\n                options = null;\n                notify = null;\n                options = {\n                  dappId: BLOCKNATIVE_DAPPID,\n                  // GET YOUR OWN KEY AT https://account.blocknative.com\n                  system: \"ethereum\",\n                  networkId: network.chainId,\n                  // darkMode: Boolean, // (default: false)\n                  transactionHandler: function transactionHandler(txInformation) {\n                    if (DEBUG) console.log(\"HANDLE TX\", txInformation);\n                    var possibleFunction = callbacks[txInformation.transaction.hash];\n\n                    if (typeof possibleFunction === \"function\") {\n                      possibleFunction(txInformation.transaction);\n                    }\n                  }\n                };\n                notify = Notify(options);\n                etherscanNetwork = \"\";\n\n                if (network.name && network.chainId > 1) {\n                  etherscanNetwork = network.name + \".\";\n                }\n\n                etherscanTxUrl = \"https://\" + etherscanNetwork + \"etherscan.io/tx/\";\n\n                if (network.chainId === 100) {\n                  etherscanTxUrl = \"https://blockscout.com/poa/xdai/tx/\";\n                }\n\n                _context2.prev = 26;\n\n                if (!(tx instanceof Promise)) {\n                  _context2.next = 34;\n                  break;\n                }\n\n                if (DEBUG) console.log(\"AWAITING TX\", tx);\n                _context2.next = 31;\n                return tx;\n\n              case 31:\n                result = _context2.sent;\n                _context2.next = 40;\n                break;\n\n              case 34:\n                if (!tx.gasPrice) {\n                  tx.gasPrice = gasPrice || ethers.utils.parseUnits(\"4.1\", \"gwei\");\n                }\n\n                if (!tx.gasLimit) {\n                  tx.gasLimit = ethers.utils.hexlify(120000);\n                }\n\n                if (DEBUG) console.log(\"RUNNING TX\", tx);\n                _context2.next = 39;\n                return signer.sendTransaction(tx);\n\n              case 39:\n                result = _context2.sent;\n\n              case 40:\n                if (DEBUG) console.log(\"RESULT:\", result); // console.log(\"Notify\", notify);\n\n                if (callback) {\n                  callbacks[result.hash] = callback;\n                } // if it is a valid Notify.js network, use that, if not, just send a default notification\n\n\n                if (!(notify && [1, 3, 4, 5, 42, 100].indexOf(network.chainId) >= 0)) {\n                  _context2.next = 47;\n                  break;\n                }\n\n                _notify$hash = notify.hash(result.hash), emitter = _notify$hash.emitter;\n                emitter.on(\"all\", function (transaction) {\n                  return {\n                    onclick: function onclick() {\n                      return window.open((etherscan || etherscanTxUrl) + transaction.hash);\n                    }\n                  };\n                });\n                _context2.next = 53;\n                break;\n\n              case 47:\n                notification.info({\n                  message: \"Local Transaction Sent\",\n                  description: result.hash,\n                  placement: \"bottomRight\"\n                }); // on most networks BlockNative will update a transaction handler,\n                // but locally we will set an interval to listen...\n\n                if (!callback) {\n                  _context2.next = 53;\n                  break;\n                }\n\n                _context2.next = 51;\n                return tx;\n\n              case 51:\n                txResult = _context2.sent;\n                listeningInterval = setInterval( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n                  var currentTransactionReceipt;\n                  return _regeneratorRuntime.wrap(function _callee$(_context) {\n                    while (1) {\n                      switch (_context.prev = _context.next) {\n                        case 0:\n                          console.log(\"CHECK IN ON THE TX\", txResult, provider);\n                          _context.next = 3;\n                          return provider.getTransactionReceipt(txResult.hash);\n\n                        case 3:\n                          currentTransactionReceipt = _context.sent;\n\n                          if (currentTransactionReceipt && currentTransactionReceipt.confirmations) {\n                            callback(_objectSpread(_objectSpread({}, txResult), currentTransactionReceipt));\n                            clearInterval(listeningInterval);\n                          }\n\n                        case 5:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }\n                  }, _callee);\n                })), 500);\n\n              case 53:\n                if (!(typeof result.wait === \"function\")) {\n                  _context2.next = 56;\n                  break;\n                }\n\n                _context2.next = 56;\n                return result.wait();\n\n              case 56:\n                return _context2.abrupt(\"return\", result);\n\n              case 59:\n                _context2.prev = 59;\n                _context2.t1 = _context2[\"catch\"](26);\n                if (DEBUG) console.log(_context2.t1); // Accounts for Metamask and default signer on all networks\n\n                message = _context2.t1.data && _context2.t1.data.message ? _context2.t1.data.message : _context2.t1.error && JSON.parse(JSON.stringify(_context2.t1.error)).body ? JSON.parse(JSON.parse(JSON.stringify(_context2.t1.error)).body).error.message : _context2.t1.data ? _context2.t1.data : JSON.stringify(_context2.t1);\n\n                if (!_context2.t1.error && _context2.t1.message) {\n                  message = _context2.t1.message;\n                }\n\n                console.log(\"Attempt to clean up:\", message);\n\n                try {\n                  obj = JSON.parse(message);\n\n                  if (obj && obj.body) {\n                    errorObj = JSON.parse(obj.body);\n\n                    if (errorObj && errorObj.error && errorObj.error.message) {\n                      message = errorObj.error.message;\n                    }\n                  }\n                } catch (e) {//ignore\n                }\n\n                notification.error({\n                  message: \"Transaction Error\",\n                  description: message\n                });\n\n                if (callback && typeof callback === \"function\") {\n                  callback(_context2.t1);\n                }\n\n              case 68:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, null, [[26, 59]]);\n      }));\n\n      return function (_x, _x2) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n  }\n}\n_c = Transactor;\n\nvar _c;\n\n$RefreshReg$(_c, \"Transactor\");","map":{"version":3,"sources":["/Users/sam/Desktop/kiwik/packages/react-app/src/helpers/Transactor.js"],"names":["notification","Notify","BLOCKNATIVE_DAPPID","require","ethers","callbacks","DEBUG","Transactor","providerOrSigner","gasPrice","etherscan","tx","callback","Signer","isSigner","provider","signer","getNetwork","network","_isProvider","getSigner","console","log","options","notify","dappId","system","networkId","chainId","transactionHandler","txInformation","possibleFunction","transaction","hash","etherscanNetwork","name","etherscanTxUrl","Promise","result","utils","parseUnits","gasLimit","hexlify","sendTransaction","indexOf","emitter","on","onclick","window","open","info","message","description","placement","txResult","listeningInterval","setInterval","getTransactionReceipt","currentTransactionReceipt","confirmations","clearInterval","wait","data","error","JSON","parse","stringify","body","obj","errorObj","e"],"mappings":"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","sourcesContent":["import { notification } from \"antd\";\nimport Notify from \"bnc-notify\";\nimport { BLOCKNATIVE_DAPPID } from \"../constants\";\n\nconst { ethers } = require(\"ethers\");\n\n// this should probably just be renamed to \"notifier\"\n// it is basically just a wrapper around BlockNative's wonderful Notify.js\n// https://docs.blocknative.com/notify\nconst callbacks = {};\n\nconst DEBUG = true;\n\nexport default function Transactor(providerOrSigner, gasPrice, etherscan) {\n  if (typeof providerOrSigner !== \"undefined\") {\n    // eslint-disable-next-line consistent-return\n    return async (tx, callback) => {\n      let signer;\n      let network;\n      let provider;\n      if (ethers.Signer.isSigner(providerOrSigner) === true) {\n        provider = providerOrSigner.provider;\n        signer = providerOrSigner;\n        network = providerOrSigner.provider && (await providerOrSigner.provider.getNetwork());\n      } else if (providerOrSigner._isProvider) {\n        provider = providerOrSigner;\n        signer = providerOrSigner.getSigner();\n        network = await providerOrSigner.getNetwork();\n      }\n\n      console.log(\"network\", network);\n      var options = null;\n      var notify = null;\n      options = {\n        dappId: BLOCKNATIVE_DAPPID, // GET YOUR OWN KEY AT https://account.blocknative.com\n        system: \"ethereum\",\n        networkId: network.chainId,\n        // darkMode: Boolean, // (default: false)\n        transactionHandler: txInformation => {\n          if (DEBUG) console.log(\"HANDLE TX\", txInformation);\n          const possibleFunction = callbacks[txInformation.transaction.hash];\n          if (typeof possibleFunction === \"function\") {\n            possibleFunction(txInformation.transaction);\n          }\n        },\n      };\n\n      notify = Notify(options);\n\n      let etherscanNetwork = \"\";\n      if (network.name && network.chainId > 1) {\n        etherscanNetwork = network.name + \".\";\n      }\n\n      let etherscanTxUrl = \"https://\" + etherscanNetwork + \"etherscan.io/tx/\";\n      if (network.chainId === 100) {\n        etherscanTxUrl = \"https://blockscout.com/poa/xdai/tx/\";\n      }\n\n      try {\n        let result;\n        if (tx instanceof Promise) {\n          if (DEBUG) console.log(\"AWAITING TX\", tx);\n          result = await tx;\n        } else {\n          if (!tx.gasPrice) {\n            tx.gasPrice = gasPrice || ethers.utils.parseUnits(\"4.1\", \"gwei\");\n          }\n          if (!tx.gasLimit) {\n            tx.gasLimit = ethers.utils.hexlify(120000);\n          }\n          if (DEBUG) console.log(\"RUNNING TX\", tx);\n          result = await signer.sendTransaction(tx);\n        }\n        if (DEBUG) console.log(\"RESULT:\", result);\n        // console.log(\"Notify\", notify);\n\n        if (callback) {\n          callbacks[result.hash] = callback;\n        }\n\n        // if it is a valid Notify.js network, use that, if not, just send a default notification\n        if (notify && [1, 3, 4, 5, 42, 100].indexOf(network.chainId) >= 0) {\n          const { emitter } = notify.hash(result.hash);\n          emitter.on(\"all\", transaction => {\n            return {\n              onclick: () => window.open((etherscan || etherscanTxUrl) + transaction.hash),\n            };\n          });\n        } else {\n          notification.info({\n            message: \"Local Transaction Sent\",\n            description: result.hash,\n            placement: \"bottomRight\",\n          });\n          // on most networks BlockNative will update a transaction handler,\n          // but locally we will set an interval to listen...\n          if (callback) {\n            const txResult = await tx;\n            const listeningInterval = setInterval(async () => {\n              console.log(\"CHECK IN ON THE TX\", txResult, provider);\n              const currentTransactionReceipt = await provider.getTransactionReceipt(txResult.hash);\n              if (currentTransactionReceipt && currentTransactionReceipt.confirmations) {\n                callback({ ...txResult, ...currentTransactionReceipt });\n                clearInterval(listeningInterval);\n              }\n            }, 500);\n          }\n        }\n\n        if (typeof result.wait === \"function\") {\n          await result.wait();\n        }\n\n        return result;\n      } catch (e) {\n        if (DEBUG) console.log(e);\n        // Accounts for Metamask and default signer on all networks\n        let message =\n          e.data && e.data.message\n            ? e.data.message\n            : e.error && JSON.parse(JSON.stringify(e.error)).body\n            ? JSON.parse(JSON.parse(JSON.stringify(e.error)).body).error.message\n            : e.data\n            ? e.data\n            : JSON.stringify(e);\n        if (!e.error && e.message) {\n          message = e.message;\n        }\n\n        console.log(\"Attempt to clean up:\", message);\n        try {\n          let obj = JSON.parse(message);\n          if (obj && obj.body) {\n            let errorObj = JSON.parse(obj.body);\n            if (errorObj && errorObj.error && errorObj.error.message) {\n              message = errorObj.error.message;\n            }\n          }\n        } catch (e) {\n          //ignore\n        }\n\n        notification.error({\n          message: \"Transaction Error\",\n          description: message,\n        });\n        if (callback && typeof callback === \"function\") {\n          callback(e);\n        }\n      }\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}