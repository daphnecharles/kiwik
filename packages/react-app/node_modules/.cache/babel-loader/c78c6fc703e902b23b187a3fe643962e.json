{"ast":null,"code":"import _classCallCheck from \"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/* eslint-disable no-use-before-define */\nimport { Base, WordArray, BufferedBlockAlgorithm } from './core.js';\nimport { Base64 } from './enc-base64.js';\nimport { EvpKDFAlgo } from './evpkdf.js';\n/**\n * Abstract base cipher template.\n *\n * @property {number} keySize This cipher's key size. Default: 4 (128 bits)\n * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)\n * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.\n * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.\n */\n\nexport var Cipher = /*#__PURE__*/function (_BufferedBlockAlgorit) {\n  _inherits(Cipher, _BufferedBlockAlgorit);\n\n  var _super = _createSuper(Cipher);\n\n  /**\n   * Initializes a newly created cipher.\n   *\n   * @param {number} xformMode Either the encryption or decryption transormation mode constant.\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @example\n   *\n   *     const cipher = CryptoJS.algo.AES.create(\n   *       CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray }\n   *     );\n   */\n  function Cipher(xformMode, key, cfg) {\n    var _this;\n\n    _classCallCheck(this, Cipher);\n\n    _this = _super.call(this);\n    /**\n     * Configuration options.\n     *\n     * @property {WordArray} iv The IV to use for this operation.\n     */\n\n    _this.cfg = Object.assign(new Base(), cfg); // Store transform mode and key\n\n    _this._xformMode = xformMode;\n    _this._key = key; // Set initial values\n\n    _this.reset();\n\n    return _this;\n  }\n  /**\n   * Creates this cipher in encryption mode.\n   *\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {Cipher} A cipher instance.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });\n   */\n\n\n  _createClass(Cipher, [{\n    key: \"reset\",\n    value:\n    /**\n     * Resets this cipher to its initial state.\n     *\n     * @example\n     *\n     *     cipher.reset();\n     */\n    function reset() {\n      // Reset data buffer\n      _get(_getPrototypeOf(Cipher.prototype), \"reset\", this).call(this); // Perform concrete-cipher logic\n\n\n      this._doReset();\n    }\n    /**\n     * Adds data to be encrypted or decrypted.\n     *\n     * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.\n     *\n     * @return {WordArray} The data after processing.\n     *\n     * @example\n     *\n     *     const encrypted = cipher.process('data');\n     *     const encrypted = cipher.process(wordArray);\n     */\n\n  }, {\n    key: \"process\",\n    value: function process(dataUpdate) {\n      // Append\n      this._append(dataUpdate); // Process available blocks\n\n\n      return this._process();\n    }\n    /**\n     * Finalizes the encryption or decryption process.\n     * Note that the finalize operation is effectively a destructive, read-once operation.\n     *\n     * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.\n     *\n     * @return {WordArray} The data after final processing.\n     *\n     * @example\n     *\n     *     const encrypted = cipher.finalize();\n     *     const encrypted = cipher.finalize('data');\n     *     const encrypted = cipher.finalize(wordArray);\n     */\n\n  }, {\n    key: \"finalize\",\n    value: function finalize(dataUpdate) {\n      // Final data update\n      if (dataUpdate) {\n        this._append(dataUpdate);\n      } // Perform concrete-cipher logic\n\n\n      var finalProcessedData = this._doFinalize();\n\n      return finalProcessedData;\n    }\n  }], [{\n    key: \"createEncryptor\",\n    value: function createEncryptor(key, cfg) {\n      return this.create(this._ENC_XFORM_MODE, key, cfg);\n    }\n    /**\n     * Creates this cipher in decryption mode.\n     *\n     * @param {WordArray} key The key.\n     * @param {Object} cfg (Optional) The configuration options to use for this operation.\n     *\n     * @return {Cipher} A cipher instance.\n     *\n     * @static\n     *\n     * @example\n     *\n     *     const cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });\n     */\n\n  }, {\n    key: \"createDecryptor\",\n    value: function createDecryptor(key, cfg) {\n      return this.create(this._DEC_XFORM_MODE, key, cfg);\n    }\n    /**\n     * Creates shortcut functions to a cipher's object interface.\n     *\n     * @param {Cipher} cipher The cipher to create a helper for.\n     *\n     * @return {Object} An object with encrypt and decrypt shortcut functions.\n     *\n     * @static\n     *\n     * @example\n     *\n     *     const AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);\n     */\n\n  }, {\n    key: \"_createHelper\",\n    value: function _createHelper(SubCipher) {\n      var selectCipherStrategy = function selectCipherStrategy(key) {\n        if (typeof key === 'string') {\n          return PasswordBasedCipher;\n        }\n\n        return SerializableCipher;\n      };\n\n      return {\n        encrypt: function encrypt(message, key, cfg) {\n          return selectCipherStrategy(key).encrypt(SubCipher, message, key, cfg);\n        },\n        decrypt: function decrypt(ciphertext, key, cfg) {\n          return selectCipherStrategy(key).decrypt(SubCipher, ciphertext, key, cfg);\n        }\n      };\n    }\n  }]);\n\n  return Cipher;\n}(BufferedBlockAlgorithm);\nCipher._ENC_XFORM_MODE = 1;\nCipher._DEC_XFORM_MODE = 2;\nCipher.keySize = 128 / 32;\nCipher.ivSize = 128 / 32;\n/**\n * Abstract base stream cipher template.\n *\n * @property {number} blockSize\n *\n *     The number of 32-bit words this cipher operates on. Default: 1 (32 bits)\n */\n\nexport var StreamCipher = /*#__PURE__*/function (_Cipher) {\n  _inherits(StreamCipher, _Cipher);\n\n  var _super2 = _createSuper(StreamCipher);\n\n  function StreamCipher() {\n    var _this2;\n\n    _classCallCheck(this, StreamCipher);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this2 = _super2.call.apply(_super2, [this].concat(args));\n    _this2.blockSize = 1;\n    return _this2;\n  }\n\n  _createClass(StreamCipher, [{\n    key: \"_doFinalize\",\n    value: function _doFinalize() {\n      // Process partial blocks\n      var finalProcessedBlocks = this._process(!!'flush');\n\n      return finalProcessedBlocks;\n    }\n  }]);\n\n  return StreamCipher;\n}(Cipher);\n/**\n * Abstract base block cipher mode template.\n */\n\nexport var BlockCipherMode = /*#__PURE__*/function (_Base) {\n  _inherits(BlockCipherMode, _Base);\n\n  var _super3 = _createSuper(BlockCipherMode);\n\n  /**\n   * Initializes a newly created mode.\n   *\n   * @param {Cipher} cipher A block cipher instance.\n   * @param {Array} iv The IV words.\n   *\n   * @example\n   *\n   *     const mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);\n   */\n  function BlockCipherMode(cipher, iv) {\n    var _this3;\n\n    _classCallCheck(this, BlockCipherMode);\n\n    _this3 = _super3.call(this);\n    _this3._cipher = cipher;\n    _this3._iv = iv;\n    return _this3;\n  }\n  /**\n   * Creates this mode for encryption.\n   *\n   * @param {Cipher} cipher A block cipher instance.\n   * @param {Array} iv The IV words.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);\n   */\n\n\n  _createClass(BlockCipherMode, null, [{\n    key: \"createEncryptor\",\n    value: function createEncryptor(cipher, iv) {\n      return this.Encryptor.create(cipher, iv);\n    }\n    /**\n     * Creates this mode for decryption.\n     *\n     * @param {Cipher} cipher A block cipher instance.\n     * @param {Array} iv The IV words.\n     *\n     * @static\n     *\n     * @example\n     *\n     *     const mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);\n     */\n\n  }, {\n    key: \"createDecryptor\",\n    value: function createDecryptor(cipher, iv) {\n      return this.Decryptor.create(cipher, iv);\n    }\n  }]);\n\n  return BlockCipherMode;\n}(Base);\n\nfunction xorBlock(words, offset, blockSize) {\n  var _words = words;\n  var block; // Shortcut\n\n  var iv = this._iv; // Choose mixing block\n\n  if (iv) {\n    block = iv; // Remove IV for subsequent blocks\n\n    this._iv = undefined;\n  } else {\n    block = this._prevBlock;\n  } // XOR blocks\n\n\n  for (var i = 0; i < blockSize; i += 1) {\n    _words[offset + i] ^= block[i];\n  }\n}\n/**\n * Cipher Block Chaining mode.\n */\n\n/**\n * Abstract base CBC mode.\n */\n\n\nexport var CBC = /*#__PURE__*/function (_BlockCipherMode) {\n  _inherits(CBC, _BlockCipherMode);\n\n  var _super4 = _createSuper(CBC);\n\n  function CBC() {\n    _classCallCheck(this, CBC);\n\n    return _super4.apply(this, arguments);\n  }\n\n  return CBC;\n}(BlockCipherMode);\n/**\n * CBC encryptor.\n */\n\nCBC.Encryptor = /*#__PURE__*/function (_CBC) {\n  _inherits(_class, _CBC);\n\n  var _super5 = _createSuper(_class);\n\n  function _class() {\n    _classCallCheck(this, _class);\n\n    return _super5.apply(this, arguments);\n  }\n\n  _createClass(_class, [{\n    key: \"processBlock\",\n    value:\n    /**\n     * Processes the data block at offset.\n     *\n     * @param {Array} words The data words to operate on.\n     * @param {number} offset The offset where the block starts.\n     *\n     * @example\n     *\n     *     mode.processBlock(data.words, offset);\n     */\n    function processBlock(words, offset) {\n      // Shortcuts\n      var cipher = this._cipher;\n      var blockSize = cipher.blockSize; // XOR and encrypt\n\n      xorBlock.call(this, words, offset, blockSize);\n      cipher.encryptBlock(words, offset); // Remember this block to use with next block\n\n      this._prevBlock = words.slice(offset, offset + blockSize);\n    }\n  }]);\n\n  return _class;\n}(CBC);\n/**\n * CBC decryptor.\n */\n\n\nCBC.Decryptor = /*#__PURE__*/function (_CBC2) {\n  _inherits(_class2, _CBC2);\n\n  var _super6 = _createSuper(_class2);\n\n  function _class2() {\n    _classCallCheck(this, _class2);\n\n    return _super6.apply(this, arguments);\n  }\n\n  _createClass(_class2, [{\n    key: \"processBlock\",\n    value:\n    /**\n     * Processes the data block at offset.\n     *\n     * @param {Array} words The data words to operate on.\n     * @param {number} offset The offset where the block starts.\n     *\n     * @example\n     *\n     *     mode.processBlock(data.words, offset);\n     */\n    function processBlock(words, offset) {\n      // Shortcuts\n      var cipher = this._cipher;\n      var blockSize = cipher.blockSize; // Remember this block to use with next block\n\n      var thisBlock = words.slice(offset, offset + blockSize); // Decrypt and XOR\n\n      cipher.decryptBlock(words, offset);\n      xorBlock.call(this, words, offset, blockSize); // This block becomes the previous block\n\n      this._prevBlock = thisBlock;\n    }\n  }]);\n\n  return _class2;\n}(CBC);\n/**\n * PKCS #5/7 padding strategy.\n */\n\n\nexport var Pkcs7 = {\n  /**\n   * Pads data using the algorithm defined in PKCS #5/7.\n   *\n   * @param {WordArray} data The data to pad.\n   * @param {number} blockSize The multiple that the data should be padded to.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);\n   */\n  pad: function pad(data, blockSize) {\n    // Shortcut\n    var blockSizeBytes = blockSize * 4; // Count padding bytes\n\n    var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes; // Create padding word\n\n    var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes; // Create padding\n\n    var paddingWords = [];\n\n    for (var i = 0; i < nPaddingBytes; i += 4) {\n      paddingWords.push(paddingWord);\n    }\n\n    var padding = WordArray.create(paddingWords, nPaddingBytes); // Add padding\n\n    data.concat(padding);\n  },\n\n  /**\n   * Unpads data that had been padded using the algorithm defined in PKCS #5/7.\n   *\n   * @param {WordArray} data The data to unpad.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     CryptoJS.pad.Pkcs7.unpad(wordArray);\n   */\n  unpad: function unpad(data) {\n    var _data = data; // Get number of padding bytes from last byte\n\n    var nPaddingBytes = _data.words[_data.sigBytes - 1 >>> 2] & 0xff; // Remove padding\n\n    _data.sigBytes -= nPaddingBytes;\n  }\n};\n/**\n * Abstract base block cipher template.\n *\n * @property {number} blockSize\n *\n *    The number of 32-bit words this cipher operates on. Default: 4 (128 bits)\n */\n\nexport var BlockCipher = /*#__PURE__*/function (_Cipher2) {\n  _inherits(BlockCipher, _Cipher2);\n\n  var _super7 = _createSuper(BlockCipher);\n\n  function BlockCipher(xformMode, key, cfg) {\n    var _this4;\n\n    _classCallCheck(this, BlockCipher);\n\n    /**\n     * Configuration options.\n     *\n     * @property {Mode} mode The block mode to use. Default: CBC\n     * @property {Padding} padding The padding strategy to use. Default: Pkcs7\n     */\n    _this4 = _super7.call(this, xformMode, key, Object.assign({\n      mode: CBC,\n      padding: Pkcs7\n    }, cfg));\n    _this4.blockSize = 128 / 32;\n    return _this4;\n  }\n\n  _createClass(BlockCipher, [{\n    key: \"reset\",\n    value: function reset() {\n      var modeCreator; // Reset cipher\n\n      _get(_getPrototypeOf(BlockCipher.prototype), \"reset\", this).call(this); // Shortcuts\n\n\n      var cfg = this.cfg;\n      var iv = cfg.iv,\n          mode = cfg.mode; // Reset block mode\n\n      if (this._xformMode === this.constructor._ENC_XFORM_MODE) {\n        modeCreator = mode.createEncryptor;\n      } else\n        /* if (this._xformMode == this._DEC_XFORM_MODE) */\n        {\n          modeCreator = mode.createDecryptor; // Keep at least one block in the buffer for unpadding\n\n          this._minBufferSize = 1;\n        }\n\n      this._mode = modeCreator.call(mode, this, iv && iv.words);\n      this._mode.__creator = modeCreator;\n    }\n  }, {\n    key: \"_doProcessBlock\",\n    value: function _doProcessBlock(words, offset) {\n      this._mode.processBlock(words, offset);\n    }\n  }, {\n    key: \"_doFinalize\",\n    value: function _doFinalize() {\n      var finalProcessedBlocks; // Shortcut\n\n      var padding = this.cfg.padding; // Finalize\n\n      if (this._xformMode === this.constructor._ENC_XFORM_MODE) {\n        // Pad data\n        padding.pad(this._data, this.blockSize); // Process final blocks\n\n        finalProcessedBlocks = this._process(!!'flush');\n      } else\n        /* if (this._xformMode == this._DEC_XFORM_MODE) */\n        {\n          // Process final blocks\n          finalProcessedBlocks = this._process(!!'flush'); // Unpad data\n\n          padding.unpad(finalProcessedBlocks);\n        }\n\n      return finalProcessedBlocks;\n    }\n  }]);\n\n  return BlockCipher;\n}(Cipher);\n/**\n * A collection of cipher parameters.\n *\n * @property {WordArray} ciphertext The raw ciphertext.\n * @property {WordArray} key The key to this ciphertext.\n * @property {WordArray} iv The IV used in the ciphering operation.\n * @property {WordArray} salt The salt used with a key derivation function.\n * @property {Cipher} algorithm The cipher algorithm.\n * @property {Mode} mode The block mode used in the ciphering operation.\n * @property {Padding} padding The padding scheme used in the ciphering operation.\n * @property {number} blockSize The block size of the cipher.\n * @property {Format} formatter\n *    The default formatting strategy to convert this cipher params object to a string.\n */\n\nexport var CipherParams = /*#__PURE__*/function (_Base2) {\n  _inherits(CipherParams, _Base2);\n\n  var _super8 = _createSuper(CipherParams);\n\n  /**\n   * Initializes a newly created cipher params object.\n   *\n   * @param {Object} cipherParams An object with any of the possible cipher parameters.\n   *\n   * @example\n   *\n   *     var cipherParams = CryptoJS.lib.CipherParams.create({\n   *         ciphertext: ciphertextWordArray,\n   *         key: keyWordArray,\n   *         iv: ivWordArray,\n   *         salt: saltWordArray,\n   *         algorithm: CryptoJS.algo.AES,\n   *         mode: CryptoJS.mode.CBC,\n   *         padding: CryptoJS.pad.PKCS7,\n   *         blockSize: 4,\n   *         formatter: CryptoJS.format.OpenSSL\n   *     });\n   */\n  function CipherParams(cipherParams) {\n    var _this5;\n\n    _classCallCheck(this, CipherParams);\n\n    _this5 = _super8.call(this);\n\n    _this5.mixIn(cipherParams);\n\n    return _this5;\n  }\n  /**\n   * Converts this cipher params object to a string.\n   *\n   * @param {Format} formatter (Optional) The formatting strategy to use.\n   *\n   * @return {string} The stringified cipher params.\n   *\n   * @throws Error If neither the formatter nor the default formatter is set.\n   *\n   * @example\n   *\n   *     var string = cipherParams + '';\n   *     var string = cipherParams.toString();\n   *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);\n   */\n\n\n  _createClass(CipherParams, [{\n    key: \"toString\",\n    value: function toString(formatter) {\n      return (formatter || this.formatter).stringify(this);\n    }\n  }]);\n\n  return CipherParams;\n}(Base);\n/**\n * OpenSSL formatting strategy.\n */\n\nexport var OpenSSLFormatter = {\n  /**\n   * Converts a cipher params object to an OpenSSL-compatible string.\n   *\n   * @param {CipherParams} cipherParams The cipher params object.\n   *\n   * @return {string} The OpenSSL-compatible string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);\n   */\n  stringify: function stringify(cipherParams) {\n    var wordArray; // Shortcuts\n\n    var ciphertext = cipherParams.ciphertext,\n        salt = cipherParams.salt; // Format\n\n    if (salt) {\n      wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);\n    } else {\n      wordArray = ciphertext;\n    }\n\n    return wordArray.toString(Base64);\n  },\n\n  /**\n   * Converts an OpenSSL-compatible string to a cipher params object.\n   *\n   * @param {string} openSSLStr The OpenSSL-compatible string.\n   *\n   * @return {CipherParams} The cipher params object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);\n   */\n  parse: function parse(openSSLStr) {\n    var salt; // Parse base64\n\n    var ciphertext = Base64.parse(openSSLStr); // Shortcut\n\n    var ciphertextWords = ciphertext.words; // Test for salt\n\n    if (ciphertextWords[0] === 0x53616c74 && ciphertextWords[1] === 0x65645f5f) {\n      // Extract salt\n      salt = WordArray.create(ciphertextWords.slice(2, 4)); // Remove salt from ciphertext\n\n      ciphertextWords.splice(0, 4);\n      ciphertext.sigBytes -= 16;\n    }\n\n    return CipherParams.create({\n      ciphertext: ciphertext,\n      salt: salt\n    });\n  }\n};\n/**\n * A cipher wrapper that returns ciphertext as a serializable cipher params object.\n */\n\nexport var SerializableCipher = /*#__PURE__*/function (_Base3) {\n  _inherits(SerializableCipher, _Base3);\n\n  var _super9 = _createSuper(SerializableCipher);\n\n  function SerializableCipher() {\n    _classCallCheck(this, SerializableCipher);\n\n    return _super9.apply(this, arguments);\n  }\n\n  _createClass(SerializableCipher, null, [{\n    key: \"encrypt\",\n    value:\n    /**\n     * Encrypts a message.\n     *\n     * @param {Cipher} cipher The cipher algorithm to use.\n     * @param {WordArray|string} message The message to encrypt.\n     * @param {WordArray} key The key.\n     * @param {Object} cfg (Optional) The configuration options to use for this operation.\n     *\n     * @return {CipherParams} A cipher params object.\n     *\n     * @static\n     *\n     * @example\n     *\n     *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n     *       .encrypt(CryptoJS.algo.AES, message, key);\n     *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n     *       .encrypt(CryptoJS.algo.AES, message, key, { iv: iv });\n     *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n     *       .encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });\n     */\n    function encrypt(cipher, message, key, cfg) {\n      // Apply config defaults\n      var _cfg = Object.assign(new Base(), this.cfg, cfg); // Encrypt\n\n\n      var encryptor = cipher.createEncryptor(key, _cfg);\n      var ciphertext = encryptor.finalize(message); // Shortcut\n\n      var cipherCfg = encryptor.cfg; // Create and return serializable cipher params\n\n      return CipherParams.create({\n        ciphertext: ciphertext,\n        key: key,\n        iv: cipherCfg.iv,\n        algorithm: cipher,\n        mode: cipherCfg.mode,\n        padding: cipherCfg.padding,\n        blockSize: encryptor.blockSize,\n        formatter: _cfg.format\n      });\n    }\n    /**\n     * Decrypts serialized ciphertext.\n     *\n     * @param {Cipher} cipher The cipher algorithm to use.\n     * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n     * @param {WordArray} key The key.\n     * @param {Object} cfg (Optional) The configuration options to use for this operation.\n     *\n     * @return {WordArray} The plaintext.\n     *\n     * @static\n     *\n     * @example\n     *\n     *     var plaintext = CryptoJS.lib.SerializableCipher\n     *       .decrypt(CryptoJS.algo.AES, formattedCiphertext, key,\n     *         { iv: iv, format: CryptoJS.format.OpenSSL });\n     *     var plaintext = CryptoJS.lib.SerializableCipher\n     *       .decrypt(CryptoJS.algo.AES, ciphertextParams, key,\n     *         { iv: iv, format: CryptoJS.format.OpenSSL });\n     */\n\n  }, {\n    key: \"decrypt\",\n    value: function decrypt(cipher, ciphertext, key, cfg) {\n      var _ciphertext = ciphertext; // Apply config defaults\n\n      var _cfg = Object.assign(new Base(), this.cfg, cfg); // Convert string to CipherParams\n\n\n      _ciphertext = this._parse(_ciphertext, _cfg.format); // Decrypt\n\n      var plaintext = cipher.createDecryptor(key, _cfg).finalize(_ciphertext.ciphertext);\n      return plaintext;\n    }\n    /**\n     * Converts serialized ciphertext to CipherParams,\n     * else assumed CipherParams already and returns ciphertext unchanged.\n     *\n     * @param {CipherParams|string} ciphertext The ciphertext.\n     * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.\n     *\n     * @return {CipherParams} The unserialized ciphertext.\n     *\n     * @static\n     *\n     * @example\n     *\n     *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n     *       ._parse(ciphertextStringOrParams, format);\n     */\n\n  }, {\n    key: \"_parse\",\n    value: function _parse(ciphertext, format) {\n      if (typeof ciphertext === 'string') {\n        return format.parse(ciphertext, this);\n      }\n\n      return ciphertext;\n    }\n  }]);\n\n  return SerializableCipher;\n}(Base);\n/**\n * Configuration options.\n *\n * @property {Formatter} format\n *\n *    The formatting strategy to convert cipher param objects to and from a string.\n *    Default: OpenSSL\n */\n\nSerializableCipher.cfg = Object.assign(new Base(), {\n  format: OpenSSLFormatter\n});\n/**\n * OpenSSL key derivation function.\n */\n\nexport var OpenSSLKdf = {\n  /**\n   * Derives a key and IV from a password.\n   *\n   * @param {string} password The password to derive from.\n   * @param {number} keySize The size in words of the key to generate.\n   * @param {number} ivSize The size in words of the IV to generate.\n   * @param {WordArray|string} salt\n   *     (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.\n   *\n   * @return {CipherParams} A cipher params object with the key, IV, and salt.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);\n   *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');\n   */\n  execute: function execute(password, keySize, ivSize, salt) {\n    var _salt = salt; // Generate random salt\n\n    if (!_salt) {\n      _salt = WordArray.random(64 / 8);\n    } // Derive key and IV\n\n\n    var key = EvpKDFAlgo.create({\n      keySize: keySize + ivSize\n    }).compute(password, _salt); // Separate key and IV\n\n    var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);\n    key.sigBytes = keySize * 4; // Return params\n\n    return CipherParams.create({\n      key: key,\n      iv: iv,\n      salt: _salt\n    });\n  }\n};\n/**\n * A serializable cipher wrapper that derives the key from a password,\n * and returns ciphertext as a serializable cipher params object.\n */\n\nexport var PasswordBasedCipher = /*#__PURE__*/function (_SerializableCipher) {\n  _inherits(PasswordBasedCipher, _SerializableCipher);\n\n  var _super10 = _createSuper(PasswordBasedCipher);\n\n  function PasswordBasedCipher() {\n    _classCallCheck(this, PasswordBasedCipher);\n\n    return _super10.apply(this, arguments);\n  }\n\n  _createClass(PasswordBasedCipher, null, [{\n    key: \"encrypt\",\n    value:\n    /**\n     * Encrypts a message using a password.\n     *\n     * @param {Cipher} cipher The cipher algorithm to use.\n     * @param {WordArray|string} message The message to encrypt.\n     * @param {string} password The password.\n     * @param {Object} cfg (Optional) The configuration options to use for this operation.\n     *\n     * @return {CipherParams} A cipher params object.\n     *\n     * @static\n     *\n     * @example\n     *\n     *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher\n     *       .encrypt(CryptoJS.algo.AES, message, 'password');\n     *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher\n     *       .encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });\n     */\n    function encrypt(cipher, message, password, cfg) {\n      // Apply config defaults\n      var _cfg = Object.assign(new Base(), this.cfg, cfg); // Derive key and other params\n\n\n      var derivedParams = _cfg.kdf.execute(password, cipher.keySize, cipher.ivSize); // Add IV to config\n\n\n      _cfg.iv = derivedParams.iv; // Encrypt\n\n      var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, _cfg); // Mix in derived params\n\n      ciphertext.mixIn(derivedParams);\n      return ciphertext;\n    }\n    /**\n     * Decrypts serialized ciphertext using a password.\n     *\n     * @param {Cipher} cipher The cipher algorithm to use.\n     * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n     * @param {string} password The password.\n     * @param {Object} cfg (Optional) The configuration options to use for this operation.\n     *\n     * @return {WordArray} The plaintext.\n     *\n     * @static\n     *\n     * @example\n     *\n     *     var plaintext = CryptoJS.lib.PasswordBasedCipher\n     *       .decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password',\n     *         { format: CryptoJS.format.OpenSSL });\n     *     var plaintext = CryptoJS.lib.PasswordBasedCipher\n     *       .decrypt(CryptoJS.algo.AES, ciphertextParams, 'password',\n     *         { format: CryptoJS.format.OpenSSL });\n     */\n\n  }, {\n    key: \"decrypt\",\n    value: function decrypt(cipher, ciphertext, password, cfg) {\n      var _ciphertext = ciphertext; // Apply config defaults\n\n      var _cfg = Object.assign(new Base(), this.cfg, cfg); // Convert string to CipherParams\n\n\n      _ciphertext = this._parse(_ciphertext, _cfg.format); // Derive key and other params\n\n      var derivedParams = _cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, _ciphertext.salt); // Add IV to config\n\n\n      _cfg.iv = derivedParams.iv; // Decrypt\n\n      var plaintext = SerializableCipher.decrypt.call(this, cipher, _ciphertext, derivedParams.key, _cfg);\n      return plaintext;\n    }\n  }]);\n\n  return PasswordBasedCipher;\n}(SerializableCipher);\n/**\n * Configuration options.\n *\n * @property {KDF} kdf\n *     The key derivation function to use to generate a key and IV from a password.\n *     Default: OpenSSL\n */\n\nPasswordBasedCipher.cfg = Object.assign(SerializableCipher.cfg, {\n  kdf: OpenSSLKdf\n});","map":{"version":3,"sources":["/Users/sam/Desktop/kiwik/node_modules/crypto-es/lib/cipher-core.js"],"names":["Base","WordArray","BufferedBlockAlgorithm","Base64","EvpKDFAlgo","Cipher","xformMode","key","cfg","Object","assign","_xformMode","_key","reset","call","_doReset","dataUpdate","_append","_process","finalProcessedData","_doFinalize","create","_ENC_XFORM_MODE","_DEC_XFORM_MODE","SubCipher","selectCipherStrategy","PasswordBasedCipher","SerializableCipher","encrypt","message","decrypt","ciphertext","keySize","ivSize","StreamCipher","args","blockSize","finalProcessedBlocks","BlockCipherMode","cipher","iv","_cipher","_iv","Encryptor","Decryptor","xorBlock","words","offset","_words","block","undefined","_prevBlock","i","CBC","encryptBlock","slice","thisBlock","decryptBlock","Pkcs7","pad","data","blockSizeBytes","nPaddingBytes","sigBytes","paddingWord","paddingWords","push","padding","concat","unpad","_data","BlockCipher","mode","modeCreator","constructor","createEncryptor","createDecryptor","_minBufferSize","_mode","__creator","processBlock","CipherParams","cipherParams","mixIn","formatter","stringify","OpenSSLFormatter","wordArray","salt","toString","parse","openSSLStr","ciphertextWords","splice","_cfg","encryptor","finalize","cipherCfg","algorithm","format","_ciphertext","_parse","plaintext","OpenSSLKdf","execute","password","_salt","random","compute","derivedParams","kdf"],"mappings":"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","sourcesContent":["/* eslint-disable no-use-before-define */\n\nimport {\n  Base,\n  WordArray,\n  BufferedBlockAlgorithm,\n} from './core.js';\nimport { Base64 } from './enc-base64.js';\nimport { EvpKDFAlgo } from './evpkdf.js';\n\n/**\n * Abstract base cipher template.\n *\n * @property {number} keySize This cipher's key size. Default: 4 (128 bits)\n * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)\n * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.\n * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.\n */\nexport class Cipher extends BufferedBlockAlgorithm {\n  /**\n   * Initializes a newly created cipher.\n   *\n   * @param {number} xformMode Either the encryption or decryption transormation mode constant.\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @example\n   *\n   *     const cipher = CryptoJS.algo.AES.create(\n   *       CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray }\n   *     );\n   */\n  constructor(xformMode, key, cfg) {\n    super();\n\n    /**\n     * Configuration options.\n     *\n     * @property {WordArray} iv The IV to use for this operation.\n     */\n    this.cfg = Object.assign(new Base(), cfg);\n\n    // Store transform mode and key\n    this._xformMode = xformMode;\n    this._key = key;\n\n    // Set initial values\n    this.reset();\n  }\n\n  /**\n   * Creates this cipher in encryption mode.\n   *\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {Cipher} A cipher instance.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });\n   */\n  static createEncryptor(key, cfg) {\n    return this.create(this._ENC_XFORM_MODE, key, cfg);\n  }\n\n  /**\n   * Creates this cipher in decryption mode.\n   *\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {Cipher} A cipher instance.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });\n   */\n  static createDecryptor(key, cfg) {\n    return this.create(this._DEC_XFORM_MODE, key, cfg);\n  }\n\n  /**\n   * Creates shortcut functions to a cipher's object interface.\n   *\n   * @param {Cipher} cipher The cipher to create a helper for.\n   *\n   * @return {Object} An object with encrypt and decrypt shortcut functions.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);\n   */\n  static _createHelper(SubCipher) {\n    const selectCipherStrategy = (key) => {\n      if (typeof key === 'string') {\n        return PasswordBasedCipher;\n      }\n      return SerializableCipher;\n    };\n\n    return {\n      encrypt(message, key, cfg) {\n        return selectCipherStrategy(key).encrypt(SubCipher, message, key, cfg);\n      },\n\n      decrypt(ciphertext, key, cfg) {\n        return selectCipherStrategy(key).decrypt(SubCipher, ciphertext, key, cfg);\n      },\n    };\n  }\n\n  /**\n   * Resets this cipher to its initial state.\n   *\n   * @example\n   *\n   *     cipher.reset();\n   */\n  reset() {\n    // Reset data buffer\n    super.reset.call(this);\n\n    // Perform concrete-cipher logic\n    this._doReset();\n  }\n\n  /**\n   * Adds data to be encrypted or decrypted.\n   *\n   * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.\n   *\n   * @return {WordArray} The data after processing.\n   *\n   * @example\n   *\n   *     const encrypted = cipher.process('data');\n   *     const encrypted = cipher.process(wordArray);\n   */\n  process(dataUpdate) {\n    // Append\n    this._append(dataUpdate);\n\n    // Process available blocks\n    return this._process();\n  }\n\n  /**\n   * Finalizes the encryption or decryption process.\n   * Note that the finalize operation is effectively a destructive, read-once operation.\n   *\n   * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.\n   *\n   * @return {WordArray} The data after final processing.\n   *\n   * @example\n   *\n   *     const encrypted = cipher.finalize();\n   *     const encrypted = cipher.finalize('data');\n   *     const encrypted = cipher.finalize(wordArray);\n   */\n  finalize(dataUpdate) {\n    // Final data update\n    if (dataUpdate) {\n      this._append(dataUpdate);\n    }\n\n    // Perform concrete-cipher logic\n    const finalProcessedData = this._doFinalize();\n\n    return finalProcessedData;\n  }\n}\nCipher._ENC_XFORM_MODE = 1;\nCipher._DEC_XFORM_MODE = 2;\nCipher.keySize = 128 / 32;\nCipher.ivSize = 128 / 32;\n\n/**\n * Abstract base stream cipher template.\n *\n * @property {number} blockSize\n *\n *     The number of 32-bit words this cipher operates on. Default: 1 (32 bits)\n */\nexport class StreamCipher extends Cipher {\n  constructor(...args) {\n    super(...args);\n\n    this.blockSize = 1;\n  }\n\n  _doFinalize() {\n    // Process partial blocks\n    const finalProcessedBlocks = this._process(!!'flush');\n\n    return finalProcessedBlocks;\n  }\n}\n\n/**\n * Abstract base block cipher mode template.\n */\nexport class BlockCipherMode extends Base {\n  /**\n   * Initializes a newly created mode.\n   *\n   * @param {Cipher} cipher A block cipher instance.\n   * @param {Array} iv The IV words.\n   *\n   * @example\n   *\n   *     const mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);\n   */\n  constructor(cipher, iv) {\n    super();\n\n    this._cipher = cipher;\n    this._iv = iv;\n  }\n\n  /**\n   * Creates this mode for encryption.\n   *\n   * @param {Cipher} cipher A block cipher instance.\n   * @param {Array} iv The IV words.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);\n   */\n  static createEncryptor(cipher, iv) {\n    return this.Encryptor.create(cipher, iv);\n  }\n\n  /**\n   * Creates this mode for decryption.\n   *\n   * @param {Cipher} cipher A block cipher instance.\n   * @param {Array} iv The IV words.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);\n   */\n  static createDecryptor(cipher, iv) {\n    return this.Decryptor.create(cipher, iv);\n  }\n}\n\nfunction xorBlock(words, offset, blockSize) {\n  const _words = words;\n  let block;\n\n  // Shortcut\n  const iv = this._iv;\n\n  // Choose mixing block\n  if (iv) {\n    block = iv;\n\n    // Remove IV for subsequent blocks\n    this._iv = undefined;\n  } else {\n    block = this._prevBlock;\n  }\n\n  // XOR blocks\n  for (let i = 0; i < blockSize; i += 1) {\n    _words[offset + i] ^= block[i];\n  }\n}\n\n/**\n * Cipher Block Chaining mode.\n */\n\n/**\n * Abstract base CBC mode.\n */\nexport class CBC extends BlockCipherMode {\n}\n/**\n * CBC encryptor.\n */\nCBC.Encryptor = class extends CBC {\n  /**\n   * Processes the data block at offset.\n   *\n   * @param {Array} words The data words to operate on.\n   * @param {number} offset The offset where the block starts.\n   *\n   * @example\n   *\n   *     mode.processBlock(data.words, offset);\n   */\n  processBlock(words, offset) {\n    // Shortcuts\n    const cipher = this._cipher;\n    const { blockSize } = cipher;\n\n    // XOR and encrypt\n    xorBlock.call(this, words, offset, blockSize);\n    cipher.encryptBlock(words, offset);\n\n    // Remember this block to use with next block\n    this._prevBlock = words.slice(offset, offset + blockSize);\n  }\n};\n/**\n * CBC decryptor.\n */\nCBC.Decryptor = class extends CBC {\n  /**\n   * Processes the data block at offset.\n   *\n   * @param {Array} words The data words to operate on.\n   * @param {number} offset The offset where the block starts.\n   *\n   * @example\n   *\n   *     mode.processBlock(data.words, offset);\n   */\n  processBlock(words, offset) {\n    // Shortcuts\n    const cipher = this._cipher;\n    const { blockSize } = cipher;\n\n    // Remember this block to use with next block\n    const thisBlock = words.slice(offset, offset + blockSize);\n\n    // Decrypt and XOR\n    cipher.decryptBlock(words, offset);\n    xorBlock.call(this, words, offset, blockSize);\n\n    // This block becomes the previous block\n    this._prevBlock = thisBlock;\n  }\n};\n\n/**\n * PKCS #5/7 padding strategy.\n */\nexport const Pkcs7 = {\n  /**\n   * Pads data using the algorithm defined in PKCS #5/7.\n   *\n   * @param {WordArray} data The data to pad.\n   * @param {number} blockSize The multiple that the data should be padded to.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);\n   */\n  pad(data, blockSize) {\n    // Shortcut\n    const blockSizeBytes = blockSize * 4;\n\n    // Count padding bytes\n    const nPaddingBytes = blockSizeBytes - (data.sigBytes % blockSizeBytes);\n\n    // Create padding word\n    const paddingWord = (nPaddingBytes << 24)\n      | (nPaddingBytes << 16)\n      | (nPaddingBytes << 8)\n      | nPaddingBytes;\n\n    // Create padding\n    const paddingWords = [];\n    for (let i = 0; i < nPaddingBytes; i += 4) {\n      paddingWords.push(paddingWord);\n    }\n    const padding = WordArray.create(paddingWords, nPaddingBytes);\n\n    // Add padding\n    data.concat(padding);\n  },\n\n  /**\n   * Unpads data that had been padded using the algorithm defined in PKCS #5/7.\n   *\n   * @param {WordArray} data The data to unpad.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     CryptoJS.pad.Pkcs7.unpad(wordArray);\n   */\n  unpad(data) {\n    const _data = data;\n\n    // Get number of padding bytes from last byte\n    const nPaddingBytes = _data.words[(_data.sigBytes - 1) >>> 2] & 0xff;\n\n    // Remove padding\n    _data.sigBytes -= nPaddingBytes;\n  },\n};\n\n/**\n * Abstract base block cipher template.\n *\n * @property {number} blockSize\n *\n *    The number of 32-bit words this cipher operates on. Default: 4 (128 bits)\n */\nexport class BlockCipher extends Cipher {\n  constructor(xformMode, key, cfg) {\n    /**\n     * Configuration options.\n     *\n     * @property {Mode} mode The block mode to use. Default: CBC\n     * @property {Padding} padding The padding strategy to use. Default: Pkcs7\n     */\n    super(xformMode, key, Object.assign(\n      {\n        mode: CBC,\n        padding: Pkcs7,\n      },\n      cfg,\n    ));\n\n    this.blockSize = 128 / 32;\n  }\n\n  reset() {\n    let modeCreator;\n\n    // Reset cipher\n    super.reset.call(this);\n\n    // Shortcuts\n    const { cfg } = this;\n    const { iv, mode } = cfg;\n\n    // Reset block mode\n    if (this._xformMode === this.constructor._ENC_XFORM_MODE) {\n      modeCreator = mode.createEncryptor;\n    } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\n      modeCreator = mode.createDecryptor;\n      // Keep at least one block in the buffer for unpadding\n      this._minBufferSize = 1;\n    }\n\n    this._mode = modeCreator.call(mode, this, iv && iv.words);\n    this._mode.__creator = modeCreator;\n  }\n\n  _doProcessBlock(words, offset) {\n    this._mode.processBlock(words, offset);\n  }\n\n  _doFinalize() {\n    let finalProcessedBlocks;\n\n    // Shortcut\n    const { padding } = this.cfg;\n\n    // Finalize\n    if (this._xformMode === this.constructor._ENC_XFORM_MODE) {\n      // Pad data\n      padding.pad(this._data, this.blockSize);\n\n      // Process final blocks\n      finalProcessedBlocks = this._process(!!'flush');\n    } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\n      // Process final blocks\n      finalProcessedBlocks = this._process(!!'flush');\n\n      // Unpad data\n      padding.unpad(finalProcessedBlocks);\n    }\n\n    return finalProcessedBlocks;\n  }\n}\n\n/**\n * A collection of cipher parameters.\n *\n * @property {WordArray} ciphertext The raw ciphertext.\n * @property {WordArray} key The key to this ciphertext.\n * @property {WordArray} iv The IV used in the ciphering operation.\n * @property {WordArray} salt The salt used with a key derivation function.\n * @property {Cipher} algorithm The cipher algorithm.\n * @property {Mode} mode The block mode used in the ciphering operation.\n * @property {Padding} padding The padding scheme used in the ciphering operation.\n * @property {number} blockSize The block size of the cipher.\n * @property {Format} formatter\n *    The default formatting strategy to convert this cipher params object to a string.\n */\nexport class CipherParams extends Base {\n  /**\n   * Initializes a newly created cipher params object.\n   *\n   * @param {Object} cipherParams An object with any of the possible cipher parameters.\n   *\n   * @example\n   *\n   *     var cipherParams = CryptoJS.lib.CipherParams.create({\n   *         ciphertext: ciphertextWordArray,\n   *         key: keyWordArray,\n   *         iv: ivWordArray,\n   *         salt: saltWordArray,\n   *         algorithm: CryptoJS.algo.AES,\n   *         mode: CryptoJS.mode.CBC,\n   *         padding: CryptoJS.pad.PKCS7,\n   *         blockSize: 4,\n   *         formatter: CryptoJS.format.OpenSSL\n   *     });\n   */\n  constructor(cipherParams) {\n    super();\n\n    this.mixIn(cipherParams);\n  }\n\n  /**\n   * Converts this cipher params object to a string.\n   *\n   * @param {Format} formatter (Optional) The formatting strategy to use.\n   *\n   * @return {string} The stringified cipher params.\n   *\n   * @throws Error If neither the formatter nor the default formatter is set.\n   *\n   * @example\n   *\n   *     var string = cipherParams + '';\n   *     var string = cipherParams.toString();\n   *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);\n   */\n  toString(formatter) {\n    return (formatter || this.formatter).stringify(this);\n  }\n}\n\n/**\n * OpenSSL formatting strategy.\n */\nexport const OpenSSLFormatter = {\n  /**\n   * Converts a cipher params object to an OpenSSL-compatible string.\n   *\n   * @param {CipherParams} cipherParams The cipher params object.\n   *\n   * @return {string} The OpenSSL-compatible string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);\n   */\n  stringify(cipherParams) {\n    let wordArray;\n\n    // Shortcuts\n    const { ciphertext, salt } = cipherParams;\n\n    // Format\n    if (salt) {\n      wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);\n    } else {\n      wordArray = ciphertext;\n    }\n\n    return wordArray.toString(Base64);\n  },\n\n  /**\n   * Converts an OpenSSL-compatible string to a cipher params object.\n   *\n   * @param {string} openSSLStr The OpenSSL-compatible string.\n   *\n   * @return {CipherParams} The cipher params object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);\n   */\n  parse(openSSLStr) {\n    let salt;\n\n    // Parse base64\n    const ciphertext = Base64.parse(openSSLStr);\n\n    // Shortcut\n    const ciphertextWords = ciphertext.words;\n\n    // Test for salt\n    if (ciphertextWords[0] === 0x53616c74 && ciphertextWords[1] === 0x65645f5f) {\n      // Extract salt\n      salt = WordArray.create(ciphertextWords.slice(2, 4));\n\n      // Remove salt from ciphertext\n      ciphertextWords.splice(0, 4);\n      ciphertext.sigBytes -= 16;\n    }\n\n    return CipherParams.create({ ciphertext, salt });\n  },\n};\n\n/**\n * A cipher wrapper that returns ciphertext as a serializable cipher params object.\n */\nexport class SerializableCipher extends Base {\n  /**\n   * Encrypts a message.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {WordArray|string} message The message to encrypt.\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {CipherParams} A cipher params object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       .encrypt(CryptoJS.algo.AES, message, key);\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       .encrypt(CryptoJS.algo.AES, message, key, { iv: iv });\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       .encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });\n   */\n  static encrypt(cipher, message, key, cfg) {\n    // Apply config defaults\n    const _cfg = Object.assign(new Base(), this.cfg, cfg);\n\n    // Encrypt\n    const encryptor = cipher.createEncryptor(key, _cfg);\n    const ciphertext = encryptor.finalize(message);\n\n    // Shortcut\n    const cipherCfg = encryptor.cfg;\n\n    // Create and return serializable cipher params\n    return CipherParams.create({\n      ciphertext,\n      key,\n      iv: cipherCfg.iv,\n      algorithm: cipher,\n      mode: cipherCfg.mode,\n      padding: cipherCfg.padding,\n      blockSize: encryptor.blockSize,\n      formatter: _cfg.format,\n    });\n  }\n\n  /**\n   * Decrypts serialized ciphertext.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {WordArray} The plaintext.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var plaintext = CryptoJS.lib.SerializableCipher\n   *       .decrypt(CryptoJS.algo.AES, formattedCiphertext, key,\n   *         { iv: iv, format: CryptoJS.format.OpenSSL });\n   *     var plaintext = CryptoJS.lib.SerializableCipher\n   *       .decrypt(CryptoJS.algo.AES, ciphertextParams, key,\n   *         { iv: iv, format: CryptoJS.format.OpenSSL });\n   */\n  static decrypt(cipher, ciphertext, key, cfg) {\n    let _ciphertext = ciphertext;\n\n    // Apply config defaults\n    const _cfg = Object.assign(new Base(), this.cfg, cfg);\n\n    // Convert string to CipherParams\n    _ciphertext = this._parse(_ciphertext, _cfg.format);\n\n    // Decrypt\n    const plaintext = cipher.createDecryptor(key, _cfg).finalize(_ciphertext.ciphertext);\n\n    return plaintext;\n  }\n\n  /**\n   * Converts serialized ciphertext to CipherParams,\n   * else assumed CipherParams already and returns ciphertext unchanged.\n   *\n   * @param {CipherParams|string} ciphertext The ciphertext.\n   * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.\n   *\n   * @return {CipherParams} The unserialized ciphertext.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       ._parse(ciphertextStringOrParams, format);\n   */\n  static _parse(ciphertext, format) {\n    if (typeof ciphertext === 'string') {\n      return format.parse(ciphertext, this);\n    }\n    return ciphertext;\n  }\n}\n/**\n * Configuration options.\n *\n * @property {Formatter} format\n *\n *    The formatting strategy to convert cipher param objects to and from a string.\n *    Default: OpenSSL\n */\nSerializableCipher.cfg = Object.assign(\n  new Base(),\n  { format: OpenSSLFormatter },\n);\n\n/**\n * OpenSSL key derivation function.\n */\nexport const OpenSSLKdf = {\n  /**\n   * Derives a key and IV from a password.\n   *\n   * @param {string} password The password to derive from.\n   * @param {number} keySize The size in words of the key to generate.\n   * @param {number} ivSize The size in words of the IV to generate.\n   * @param {WordArray|string} salt\n   *     (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.\n   *\n   * @return {CipherParams} A cipher params object with the key, IV, and salt.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);\n   *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');\n   */\n  execute(password, keySize, ivSize, salt) {\n    let _salt = salt;\n\n    // Generate random salt\n    if (!_salt) {\n      _salt = WordArray.random(64 / 8);\n    }\n\n    // Derive key and IV\n    const key = EvpKDFAlgo.create({ keySize: keySize + ivSize }).compute(password, _salt);\n\n    // Separate key and IV\n    const iv = WordArray.create(key.words.slice(keySize), ivSize * 4);\n    key.sigBytes = keySize * 4;\n\n    // Return params\n    return CipherParams.create({ key, iv, salt: _salt });\n  },\n};\n\n/**\n * A serializable cipher wrapper that derives the key from a password,\n * and returns ciphertext as a serializable cipher params object.\n */\nexport class PasswordBasedCipher extends SerializableCipher {\n  /**\n   * Encrypts a message using a password.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {WordArray|string} message The message to encrypt.\n   * @param {string} password The password.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {CipherParams} A cipher params object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher\n   *       .encrypt(CryptoJS.algo.AES, message, 'password');\n   *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher\n   *       .encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });\n   */\n  static encrypt(cipher, message, password, cfg) {\n    // Apply config defaults\n    const _cfg = Object.assign(new Base(), this.cfg, cfg);\n\n    // Derive key and other params\n    const derivedParams = _cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);\n\n    // Add IV to config\n    _cfg.iv = derivedParams.iv;\n\n    // Encrypt\n    const ciphertext = SerializableCipher.encrypt\n      .call(this, cipher, message, derivedParams.key, _cfg);\n\n    // Mix in derived params\n    ciphertext.mixIn(derivedParams);\n\n    return ciphertext;\n  }\n\n  /**\n   * Decrypts serialized ciphertext using a password.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n   * @param {string} password The password.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {WordArray} The plaintext.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var plaintext = CryptoJS.lib.PasswordBasedCipher\n   *       .decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password',\n   *         { format: CryptoJS.format.OpenSSL });\n   *     var plaintext = CryptoJS.lib.PasswordBasedCipher\n   *       .decrypt(CryptoJS.algo.AES, ciphertextParams, 'password',\n   *         { format: CryptoJS.format.OpenSSL });\n   */\n  static decrypt(cipher, ciphertext, password, cfg) {\n    let _ciphertext = ciphertext;\n\n    // Apply config defaults\n    const _cfg = Object.assign(new Base(), this.cfg, cfg);\n\n    // Convert string to CipherParams\n    _ciphertext = this._parse(_ciphertext, _cfg.format);\n\n    // Derive key and other params\n    const derivedParams = _cfg.kdf\n      .execute(password, cipher.keySize, cipher.ivSize, _ciphertext.salt);\n\n    // Add IV to config\n    _cfg.iv = derivedParams.iv;\n\n    // Decrypt\n    const plaintext = SerializableCipher.decrypt\n      .call(this, cipher, _ciphertext, derivedParams.key, _cfg);\n\n    return plaintext;\n  }\n}\n/**\n * Configuration options.\n *\n * @property {KDF} kdf\n *     The key derivation function to use to generate a key and IV from a password.\n *     Default: OpenSSL\n */\nPasswordBasedCipher.cfg = Object.assign(SerializableCipher.cfg, { kdf: OpenSSLKdf });\n"]},"metadata":{},"sourceType":"module"}