{"ast":null,"code":"import _createClass from \"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _inherits from \"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/sam/Desktop/kiwik/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { BlockCipherMode } from './cipher-core.js';\n\nfunction generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {\n  var _words = words;\n  var keystream; // Shortcut\n\n  var iv = this._iv; // Generate keystream\n\n  if (iv) {\n    keystream = iv.slice(0); // Remove IV for subsequent blocks\n\n    this._iv = undefined;\n  } else {\n    keystream = this._prevBlock;\n  }\n\n  cipher.encryptBlock(keystream, 0); // Encrypt\n\n  for (var i = 0; i < blockSize; i += 1) {\n    _words[offset + i] ^= keystream[i];\n  }\n}\n/**\n * Cipher Feedback block mode.\n */\n\n\nexport var CFB = /*#__PURE__*/function (_BlockCipherMode) {\n  _inherits(CFB, _BlockCipherMode);\n\n  var _super = _createSuper(CFB);\n\n  function CFB() {\n    _classCallCheck(this, CFB);\n\n    return _super.apply(this, arguments);\n  }\n\n  return CFB;\n}(BlockCipherMode);\n\nCFB.Encryptor = /*#__PURE__*/function (_CFB) {\n  _inherits(_class, _CFB);\n\n  var _super2 = _createSuper(_class);\n\n  function _class() {\n    _classCallCheck(this, _class);\n\n    return _super2.apply(this, arguments);\n  }\n\n  _createClass(_class, [{\n    key: \"processBlock\",\n    value: function processBlock(words, offset) {\n      // Shortcuts\n      var cipher = this._cipher;\n      var blockSize = cipher.blockSize;\n      generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher); // Remember this block to use with next block\n\n      this._prevBlock = words.slice(offset, offset + blockSize);\n    }\n  }]);\n\n  return _class;\n}(CFB);\n\nCFB.Decryptor = /*#__PURE__*/function (_CFB2) {\n  _inherits(_class2, _CFB2);\n\n  var _super3 = _createSuper(_class2);\n\n  function _class2() {\n    _classCallCheck(this, _class2);\n\n    return _super3.apply(this, arguments);\n  }\n\n  _createClass(_class2, [{\n    key: \"processBlock\",\n    value: function processBlock(words, offset) {\n      // Shortcuts\n      var cipher = this._cipher;\n      var blockSize = cipher.blockSize; // Remember this block to use with next block\n\n      var thisBlock = words.slice(offset, offset + blockSize);\n      generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher); // This block becomes the previous block\n\n      this._prevBlock = thisBlock;\n    }\n  }]);\n\n  return _class2;\n}(CFB);","map":{"version":3,"sources":["/Users/sam/Desktop/kiwik/node_modules/crypto-es/lib/mode-cfb.js"],"names":["BlockCipherMode","generateKeystreamAndEncrypt","words","offset","blockSize","cipher","_words","keystream","iv","_iv","slice","undefined","_prevBlock","encryptBlock","i","CFB","Encryptor","_cipher","call","Decryptor","thisBlock"],"mappings":";;;;AAAA,SACEA,eADF,QAEO,kBAFP;;AAIA,SAASC,2BAAT,CAAqCC,KAArC,EAA4CC,MAA5C,EAAoDC,SAApD,EAA+DC,MAA/D,EAAuE;AACrE,MAAMC,MAAM,GAAGJ,KAAf;AACA,MAAIK,SAAJ,CAFqE,CAIrE;;AACA,MAAMC,EAAE,GAAG,KAAKC,GAAhB,CALqE,CAOrE;;AACA,MAAID,EAAJ,EAAQ;AACND,IAAAA,SAAS,GAAGC,EAAE,CAACE,KAAH,CAAS,CAAT,CAAZ,CADM,CAGN;;AACA,SAAKD,GAAL,GAAWE,SAAX;AACD,GALD,MAKO;AACLJ,IAAAA,SAAS,GAAG,KAAKK,UAAjB;AACD;;AACDP,EAAAA,MAAM,CAACQ,YAAP,CAAoBN,SAApB,EAA+B,CAA/B,EAhBqE,CAkBrE;;AACA,OAAK,IAAIO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGV,SAApB,EAA+BU,CAAC,IAAI,CAApC,EAAuC;AACrCR,IAAAA,MAAM,CAACH,MAAM,GAAGW,CAAV,CAAN,IAAsBP,SAAS,CAACO,CAAD,CAA/B;AACD;AACF;AAED;AACA;AACA;;;AACA,WAAaC,GAAb;AAAA;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA,EAAyBf,eAAzB;;AAEAe,GAAG,CAACC,SAAJ;AAAA;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA,WACE,sBAAad,KAAb,EAAoBC,MAApB,EAA4B;AAC1B;AACA,UAAME,MAAM,GAAG,KAAKY,OAApB;AACA,UAAQb,SAAR,GAAsBC,MAAtB,CAAQD,SAAR;AAEAH,MAAAA,2BAA2B,CAACiB,IAA5B,CAAiC,IAAjC,EAAuChB,KAAvC,EAA8CC,MAA9C,EAAsDC,SAAtD,EAAiEC,MAAjE,EAL0B,CAO1B;;AACA,WAAKO,UAAL,GAAkBV,KAAK,CAACQ,KAAN,CAAYP,MAAZ,EAAoBA,MAAM,GAAGC,SAA7B,CAAlB;AACD;AAVH;;AAAA;AAAA,EAA8BW,GAA9B;;AAYAA,GAAG,CAACI,SAAJ;AAAA;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA,WACE,sBAAajB,KAAb,EAAoBC,MAApB,EAA4B;AAC1B;AACA,UAAME,MAAM,GAAG,KAAKY,OAApB;AACA,UAAQb,SAAR,GAAsBC,MAAtB,CAAQD,SAAR,CAH0B,CAK1B;;AACA,UAAMgB,SAAS,GAAGlB,KAAK,CAACQ,KAAN,CAAYP,MAAZ,EAAoBA,MAAM,GAAGC,SAA7B,CAAlB;AAEAH,MAAAA,2BAA2B,CAACiB,IAA5B,CAAiC,IAAjC,EAAuChB,KAAvC,EAA8CC,MAA9C,EAAsDC,SAAtD,EAAiEC,MAAjE,EAR0B,CAU1B;;AACA,WAAKO,UAAL,GAAkBQ,SAAlB;AACD;AAbH;;AAAA;AAAA,EAA8BL,GAA9B","sourcesContent":["import {\n  BlockCipherMode,\n} from './cipher-core.js';\n\nfunction generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {\n  const _words = words;\n  let keystream;\n\n  // Shortcut\n  const iv = this._iv;\n\n  // Generate keystream\n  if (iv) {\n    keystream = iv.slice(0);\n\n    // Remove IV for subsequent blocks\n    this._iv = undefined;\n  } else {\n    keystream = this._prevBlock;\n  }\n  cipher.encryptBlock(keystream, 0);\n\n  // Encrypt\n  for (let i = 0; i < blockSize; i += 1) {\n    _words[offset + i] ^= keystream[i];\n  }\n}\n\n/**\n * Cipher Feedback block mode.\n */\nexport class CFB extends BlockCipherMode {\n}\nCFB.Encryptor = class extends CFB {\n  processBlock(words, offset) {\n    // Shortcuts\n    const cipher = this._cipher;\n    const { blockSize } = cipher;\n\n    generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);\n\n    // Remember this block to use with next block\n    this._prevBlock = words.slice(offset, offset + blockSize);\n  }\n};\nCFB.Decryptor = class extends CFB {\n  processBlock(words, offset) {\n    // Shortcuts\n    const cipher = this._cipher;\n    const { blockSize } = cipher;\n\n    // Remember this block to use with next block\n    const thisBlock = words.slice(offset, offset + blockSize);\n\n    generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);\n\n    // This block becomes the previous block\n    this._prevBlock = thisBlock;\n  }\n};\n"]},"metadata":{},"sourceType":"module"}