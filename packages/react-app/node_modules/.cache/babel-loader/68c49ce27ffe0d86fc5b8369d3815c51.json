{"ast":null,"code":"// ~~strike through~~\n//\n'use strict'; // Insert each marker as a separate text token, and add it to delimiter list\n//\n\nmodule.exports.tokenize = function strikethrough(state, silent) {\n  var i,\n      scanned,\n      token,\n      len,\n      ch,\n      start = state.pos,\n      marker = state.src.charCodeAt(start);\n\n  if (silent) {\n    return false;\n  }\n\n  if (marker !== 0x7E\n  /* ~ */\n  ) {\n    return false;\n  }\n\n  scanned = state.scanDelims(state.pos, true);\n  len = scanned.length;\n  ch = String.fromCharCode(marker);\n\n  if (len < 2) {\n    return false;\n  }\n\n  if (len % 2) {\n    token = state.push('text', '', 0);\n    token.content = ch;\n    len--;\n  }\n\n  for (i = 0; i < len; i += 2) {\n    token = state.push('text', '', 0);\n    token.content = ch + ch;\n    state.delimiters.push({\n      marker: marker,\n      length: 0,\n      // disable \"rule of 3\" length checks meant for emphasis\n      jump: i / 2,\n      // for `~~` 1 marker = 2 characters\n      token: state.tokens.length - 1,\n      end: -1,\n      open: scanned.can_open,\n      close: scanned.can_close\n    });\n  }\n\n  state.pos += scanned.length;\n  return true;\n};\n\nfunction postProcess(state, delimiters) {\n  var i,\n      j,\n      startDelim,\n      endDelim,\n      token,\n      loneMarkers = [],\n      max = delimiters.length;\n\n  for (i = 0; i < max; i++) {\n    startDelim = delimiters[i];\n\n    if (startDelim.marker !== 0x7E\n    /* ~ */\n    ) {\n      continue;\n    }\n\n    if (startDelim.end === -1) {\n      continue;\n    }\n\n    endDelim = delimiters[startDelim.end];\n    token = state.tokens[startDelim.token];\n    token.type = 's_open';\n    token.tag = 's';\n    token.nesting = 1;\n    token.markup = '~~';\n    token.content = '';\n    token = state.tokens[endDelim.token];\n    token.type = 's_close';\n    token.tag = 's';\n    token.nesting = -1;\n    token.markup = '~~';\n    token.content = '';\n\n    if (state.tokens[endDelim.token - 1].type === 'text' && state.tokens[endDelim.token - 1].content === '~') {\n      loneMarkers.push(endDelim.token - 1);\n    }\n  } // If a marker sequence has an odd number of characters, it's splitted\n  // like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the\n  // start of the sequence.\n  //\n  // So, we have to move all those markers after subsequent s_close tags.\n  //\n\n\n  while (loneMarkers.length) {\n    i = loneMarkers.pop();\n    j = i + 1;\n\n    while (j < state.tokens.length && state.tokens[j].type === 's_close') {\n      j++;\n    }\n\n    j--;\n\n    if (i !== j) {\n      token = state.tokens[j];\n      state.tokens[j] = state.tokens[i];\n      state.tokens[i] = token;\n    }\n  }\n} // Walk through delimiter list and replace text tokens with tags\n//\n\n\nmodule.exports.postProcess = function strikethrough(state) {\n  var curr,\n      tokens_meta = state.tokens_meta,\n      max = state.tokens_meta.length;\n  postProcess(state, state.delimiters);\n\n  for (curr = 0; curr < max; curr++) {\n    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\n      postProcess(state, tokens_meta[curr].delimiters);\n    }\n  }\n};","map":{"version":3,"sources":["/Users/sam/Desktop/kiwik/node_modules/markdown-it/lib/rules_inline/strikethrough.js"],"names":["module","exports","tokenize","strikethrough","state","silent","i","scanned","token","len","ch","start","pos","marker","src","charCodeAt","scanDelims","length","String","fromCharCode","push","content","delimiters","jump","tokens","end","open","can_open","close","can_close","postProcess","j","startDelim","endDelim","loneMarkers","max","type","tag","nesting","markup","pop","curr","tokens_meta"],"mappings":"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","sourcesContent":["// ~~strike through~~\n//\n'use strict';\n\n\n// Insert each marker as a separate text token, and add it to delimiter list\n//\nmodule.exports.tokenize = function strikethrough(state, silent) {\n  var i, scanned, token, len, ch,\n      start = state.pos,\n      marker = state.src.charCodeAt(start);\n\n  if (silent) { return false; }\n\n  if (marker !== 0x7E/* ~ */) { return false; }\n\n  scanned = state.scanDelims(state.pos, true);\n  len = scanned.length;\n  ch = String.fromCharCode(marker);\n\n  if (len < 2) { return false; }\n\n  if (len % 2) {\n    token         = state.push('text', '', 0);\n    token.content = ch;\n    len--;\n  }\n\n  for (i = 0; i < len; i += 2) {\n    token         = state.push('text', '', 0);\n    token.content = ch + ch;\n\n    state.delimiters.push({\n      marker: marker,\n      length: 0,     // disable \"rule of 3\" length checks meant for emphasis\n      jump:   i / 2, // for `~~` 1 marker = 2 characters\n      token:  state.tokens.length - 1,\n      end:    -1,\n      open:   scanned.can_open,\n      close:  scanned.can_close\n    });\n  }\n\n  state.pos += scanned.length;\n\n  return true;\n};\n\n\nfunction postProcess(state, delimiters) {\n  var i, j,\n      startDelim,\n      endDelim,\n      token,\n      loneMarkers = [],\n      max = delimiters.length;\n\n  for (i = 0; i < max; i++) {\n    startDelim = delimiters[i];\n\n    if (startDelim.marker !== 0x7E/* ~ */) {\n      continue;\n    }\n\n    if (startDelim.end === -1) {\n      continue;\n    }\n\n    endDelim = delimiters[startDelim.end];\n\n    token         = state.tokens[startDelim.token];\n    token.type    = 's_open';\n    token.tag     = 's';\n    token.nesting = 1;\n    token.markup  = '~~';\n    token.content = '';\n\n    token         = state.tokens[endDelim.token];\n    token.type    = 's_close';\n    token.tag     = 's';\n    token.nesting = -1;\n    token.markup  = '~~';\n    token.content = '';\n\n    if (state.tokens[endDelim.token - 1].type === 'text' &&\n        state.tokens[endDelim.token - 1].content === '~') {\n\n      loneMarkers.push(endDelim.token - 1);\n    }\n  }\n\n  // If a marker sequence has an odd number of characters, it's splitted\n  // like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the\n  // start of the sequence.\n  //\n  // So, we have to move all those markers after subsequent s_close tags.\n  //\n  while (loneMarkers.length) {\n    i = loneMarkers.pop();\n    j = i + 1;\n\n    while (j < state.tokens.length && state.tokens[j].type === 's_close') {\n      j++;\n    }\n\n    j--;\n\n    if (i !== j) {\n      token = state.tokens[j];\n      state.tokens[j] = state.tokens[i];\n      state.tokens[i] = token;\n    }\n  }\n}\n\n\n// Walk through delimiter list and replace text tokens with tags\n//\nmodule.exports.postProcess = function strikethrough(state) {\n  var curr,\n      tokens_meta = state.tokens_meta,\n      max = state.tokens_meta.length;\n\n  postProcess(state, state.delimiters);\n\n  for (curr = 0; curr < max; curr++) {\n    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\n      postProcess(state, tokens_meta[curr].delimiters);\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"script"}