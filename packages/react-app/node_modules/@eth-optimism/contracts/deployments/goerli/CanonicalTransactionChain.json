{
  "address": "0x2ebA8c4EfDB39A8Cd8f9eD65c50ec079f7CEBD81",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_libAddressManager",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_maxTransactionGasLimit",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_l2GasDiscountDivisor",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_enqueueGasCost",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_startingQueueIndex",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_numQueueElements",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_totalElements",
          "type": "uint256"
        }
      ],
      "name": "QueueBatchAppended",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_startingQueueIndex",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_numQueueElements",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_totalElements",
          "type": "uint256"
        }
      ],
      "name": "SequencerBatchAppended",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "_batchIndex",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "_batchRoot",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_batchSize",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_prevTotalElements",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "_extraData",
          "type": "bytes"
        }
      ],
      "name": "TransactionBatchAppended",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "_l1TxOrigin",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "_target",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_gasLimit",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "_data",
          "type": "bytes"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "_queueIndex",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_timestamp",
          "type": "uint256"
        }
      ],
      "name": "TransactionEnqueued",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "ENQUEUE_GAS_COST",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ENQUEUE_L2_GAS_PREPAID",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "L2_GAS_DISCOUNT_DIVISOR",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MAX_ROLLUP_TX_SIZE",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MIN_ROLLUP_TX_GAS",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "appendSequencerBatch",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "batches",
      "outputs": [
        {
          "internalType": "contract IChainStorageContainer",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_target",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_gasLimit",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "_data",
          "type": "bytes"
        }
      ],
      "name": "enqueue",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getLastBlockNumber",
      "outputs": [
        {
          "internalType": "uint40",
          "name": "",
          "type": "uint40"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getLastTimestamp",
      "outputs": [
        {
          "internalType": "uint40",
          "name": "",
          "type": "uint40"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getNextQueueIndex",
      "outputs": [
        {
          "internalType": "uint40",
          "name": "",
          "type": "uint40"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getNumPendingQueueElements",
      "outputs": [
        {
          "internalType": "uint40",
          "name": "",
          "type": "uint40"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_index",
          "type": "uint256"
        }
      ],
      "name": "getQueueElement",
      "outputs": [
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "transactionHash",
              "type": "bytes32"
            },
            {
              "internalType": "uint40",
              "name": "timestamp",
              "type": "uint40"
            },
            {
              "internalType": "uint40",
              "name": "blockNumber",
              "type": "uint40"
            }
          ],
          "internalType": "struct Lib_OVMCodec.QueueElement",
          "name": "_element",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getQueueLength",
      "outputs": [
        {
          "internalType": "uint40",
          "name": "",
          "type": "uint40"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getTotalBatches",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "_totalBatches",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getTotalElements",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "_totalElements",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "libAddressManager",
      "outputs": [
        {
          "internalType": "contract Lib_AddressManager",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "maxTransactionGasLimit",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "queue",
      "outputs": [
        {
          "internalType": "contract IChainStorageContainer",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "_name",
          "type": "string"
        }
      ],
      "name": "resolve",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xff0f98acf7876e1f9b00bf629517a6609b7c3f3fb87e631e7df115129cb17032",
  "receipt": {
    "to": null,
    "from": "0x9C822C992b56A3bd35d16A089d99AEc870eF8d37",
    "contractAddress": "0x2ebA8c4EfDB39A8Cd8f9eD65c50ec079f7CEBD81",
    "transactionIndex": 14,
    "gasUsed": "1591163",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x27595d8bcaa846c6b0ac51511a0f4f95e455f977a4d0e213dc19fc7ac78a1dce",
    "transactionHash": "0xff0f98acf7876e1f9b00bf629517a6609b7c3f3fb87e631e7df115129cb17032",
    "logs": [],
    "blockNumber": 5619320,
    "cumulativeGasUsed": "2311906",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x2F7E3cAC91b5148d336BbffB224B4dC79F09f01D",
    15000000,
    32,
    60000
  ],
  "solcInputHash": "0688a9ac0c7cbca876232a3281bda510",
  "metadata": "{\"compiler\":{\"version\":\"0.8.9+commit.e5eed63a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_libAddressManager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxTransactionGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_l2GasDiscountDivisor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_enqueueGasCost\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_startingQueueIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_numQueueElements\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_totalElements\",\"type\":\"uint256\"}],\"name\":\"QueueBatchAppended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_startingQueueIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_numQueueElements\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_totalElements\",\"type\":\"uint256\"}],\"name\":\"SequencerBatchAppended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_batchIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_batchRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_batchSize\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_prevTotalElements\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"TransactionBatchAppended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_l1TxOrigin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_gasLimit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_queueIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"TransactionEnqueued\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ENQUEUE_GAS_COST\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ENQUEUE_L2_GAS_PREPAID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"L2_GAS_DISCOUNT_DIVISOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_ROLLUP_TX_SIZE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_ROLLUP_TX_GAS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"appendSequencerBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"batches\",\"outputs\":[{\"internalType\":\"contract IChainStorageContainer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"enqueue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastBlockNumber\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastTimestamp\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNextQueueIndex\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumPendingQueueElements\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getQueueElement\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"transactionHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint40\",\"name\":\"timestamp\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"blockNumber\",\"type\":\"uint40\"}],\"internalType\":\"struct Lib_OVMCodec.QueueElement\",\"name\":\"_element\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getQueueLength\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalBatches\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalBatches\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalElements\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalElements\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"libAddressManager\",\"outputs\":[{\"internalType\":\"contract Lib_AddressManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTransactionGasLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"queue\",\"outputs\":[{\"internalType\":\"contract IChainStorageContainer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"resolve\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"The Canonical Transaction Chain (CTC) contract is an append-only log of transactions which must be applied to the rollup state. It defines the ordering of rollup transactions by writing them to the 'CTC:batches' instance of the Chain Storage Container. The CTC also allows any account to 'enqueue' an L2 transaction, which will require that the Sequencer will eventually append it to the rollup state. Runtime target: EVM\",\"kind\":\"dev\",\"methods\":{\"appendSequencerBatch()\":{\"details\":\"This function uses a custom encoding scheme for efficiency reasons. .param _shouldStartAtElement Specific batch we expect to start appending to. .param _totalElementsToAppend Total number of batch elements we expect to append. .param _contexts Array of batch contexts. .param _transactionDataFields Array of raw transaction data.\"},\"batches()\":{\"returns\":{\"_0\":\"Reference to the batch storage container.\"}},\"enqueue(address,uint256,bytes)\":{\"params\":{\"_data\":\"Transaction data.\",\"_gasLimit\":\"Gas limit for the enqueued L2 transaction.\",\"_target\":\"Target L2 contract to send the transaction to.\"}},\"getLastBlockNumber()\":{\"returns\":{\"_0\":\"Blocknumber for the last transaction.\"}},\"getLastTimestamp()\":{\"returns\":{\"_0\":\"Timestamp for the last transaction.\"}},\"getNextQueueIndex()\":{\"returns\":{\"_0\":\"Index for the next queue element.\"}},\"getNumPendingQueueElements()\":{\"returns\":{\"_0\":\"Number of pending queue elements.\"}},\"getQueueElement(uint256)\":{\"params\":{\"_index\":\"Index of the queue element to access.\"},\"returns\":{\"_element\":\"Queue element at the given index.\"}},\"getQueueLength()\":{\"returns\":{\"_0\":\"Length of the queue.\"}},\"getTotalBatches()\":{\"returns\":{\"_totalBatches\":\"Total submitted batches.\"}},\"getTotalElements()\":{\"returns\":{\"_totalElements\":\"Total submitted elements.\"}},\"queue()\":{\"returns\":{\"_0\":\"Reference to the queue storage container.\"}},\"resolve(string)\":{\"params\":{\"_name\":\"Name to resolve an address for.\"},\"returns\":{\"_0\":\"Address associated with the given name.\"}}},\"title\":\"CanonicalTransactionChain\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"appendSequencerBatch()\":{\"notice\":\"Allows the sequencer to append a batch of transactions.\"},\"batches()\":{\"notice\":\"Accesses the batch storage container.\"},\"enqueue(address,uint256,bytes)\":{\"notice\":\"Adds a transaction to the queue.\"},\"getLastBlockNumber()\":{\"notice\":\"Returns the blocknumber of the last transaction.\"},\"getLastTimestamp()\":{\"notice\":\"Returns the timestamp of the last transaction.\"},\"getNextQueueIndex()\":{\"notice\":\"Returns the index of the next element to be enqueued.\"},\"getNumPendingQueueElements()\":{\"notice\":\"Get the number of queue elements which have not yet been included.\"},\"getQueueElement(uint256)\":{\"notice\":\"Gets the queue element at a particular index.\"},\"getQueueLength()\":{\"notice\":\"Retrieves the length of the queue, including both pending and canonical transactions.\"},\"getTotalBatches()\":{\"notice\":\"Retrieves the total number of batches submitted.\"},\"getTotalElements()\":{\"notice\":\"Retrieves the total number of elements submitted.\"},\"queue()\":{\"notice\":\"Accesses the queue storage container.\"},\"resolve(string)\":{\"notice\":\"Resolves the address associated with a given name.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/L1/rollup/CanonicalTransactionChain.sol\":\"CanonicalTransactionChain\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"none\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0x6bb804a310218875e89d12c053e94a13a4607cdf7cc2052f3e52bd32a0dc50a1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0x90565a39ae45c80f0468dc96c7b20d0afc3055f344c8203a0c9258239f350b9f\",\"license\":\"MIT\"},\"contracts/L1/rollup/CanonicalTransactionChain.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport { AddressAliasHelper } from \\\"../../standards/AddressAliasHelper.sol\\\";\\nimport { Lib_OVMCodec } from \\\"../../libraries/codec/Lib_OVMCodec.sol\\\";\\nimport { Lib_AddressResolver } from \\\"../../libraries/resolver/Lib_AddressResolver.sol\\\";\\n\\n/* Interface Imports */\\nimport { ICanonicalTransactionChain } from \\\"./ICanonicalTransactionChain.sol\\\";\\nimport { IChainStorageContainer } from \\\"./IChainStorageContainer.sol\\\";\\n\\n/**\\n * @title CanonicalTransactionChain\\n * @dev The Canonical Transaction Chain (CTC) contract is an append-only log of transactions\\n * which must be applied to the rollup state. It defines the ordering of rollup transactions by\\n * writing them to the 'CTC:batches' instance of the Chain Storage Container.\\n * The CTC also allows any account to 'enqueue' an L2 transaction, which will require that the\\n * Sequencer will eventually append it to the rollup state.\\n *\\n * Runtime target: EVM\\n */\\ncontract CanonicalTransactionChain is ICanonicalTransactionChain, Lib_AddressResolver {\\n\\n    /*************\\n     * Constants *\\n     *************/\\n\\n    // L2 tx gas-related\\n    uint256 constant public MIN_ROLLUP_TX_GAS = 100000;\\n    uint256 constant public MAX_ROLLUP_TX_SIZE = 50000;\\n    uint256 immutable public L2_GAS_DISCOUNT_DIVISOR;\\n    uint256 immutable public ENQUEUE_GAS_COST;\\n    uint256 immutable public ENQUEUE_L2_GAS_PREPAID;\\n\\n    // Encoding-related (all in bytes)\\n    uint256 constant internal BATCH_CONTEXT_SIZE = 16;\\n    uint256 constant internal BATCH_CONTEXT_LENGTH_POS = 12;\\n    uint256 constant internal BATCH_CONTEXT_START_POS = 15;\\n    uint256 constant internal TX_DATA_HEADER_SIZE = 3;\\n    uint256 constant internal BYTES_TILL_TX_DATA = 65;\\n\\n\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    uint256 public maxTransactionGasLimit;\\n\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    constructor(\\n        address _libAddressManager,\\n        uint256 _maxTransactionGasLimit,\\n        uint256 _l2GasDiscountDivisor,\\n        uint256 _enqueueGasCost\\n    )\\n        Lib_AddressResolver(_libAddressManager)\\n    {\\n        maxTransactionGasLimit = _maxTransactionGasLimit;\\n        L2_GAS_DISCOUNT_DIVISOR = _l2GasDiscountDivisor;\\n        ENQUEUE_GAS_COST  = _enqueueGasCost;\\n        ENQUEUE_L2_GAS_PREPAID = _l2GasDiscountDivisor * _enqueueGasCost;\\n    }\\n\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Accesses the batch storage container.\\n     * @return Reference to the batch storage container.\\n     */\\n    function batches()\\n        public\\n        view\\n        returns (\\n            IChainStorageContainer\\n        )\\n    {\\n        return IChainStorageContainer(\\n            resolve(\\\"ChainStorageContainer-CTC-batches\\\")\\n        );\\n    }\\n\\n    /**\\n     * Accesses the queue storage container.\\n     * @return Reference to the queue storage container.\\n     */\\n    function queue()\\n        public\\n        view\\n        returns (\\n            IChainStorageContainer\\n        )\\n    {\\n        return IChainStorageContainer(\\n            resolve(\\\"ChainStorageContainer-CTC-queue\\\")\\n        );\\n    }\\n\\n    /**\\n     * Retrieves the total number of elements submitted.\\n     * @return _totalElements Total submitted elements.\\n     */\\n    function getTotalElements()\\n        public\\n        view\\n        returns (\\n            uint256 _totalElements\\n        )\\n    {\\n        (uint40 totalElements,,,) = _getBatchExtraData();\\n        return uint256(totalElements);\\n    }\\n\\n    /**\\n     * Retrieves the total number of batches submitted.\\n     * @return _totalBatches Total submitted batches.\\n     */\\n    function getTotalBatches()\\n        public\\n        view\\n        returns (\\n            uint256 _totalBatches\\n        )\\n    {\\n        return batches().length();\\n    }\\n\\n    /**\\n     * Returns the index of the next element to be enqueued.\\n     * @return Index for the next queue element.\\n     */\\n    function getNextQueueIndex()\\n        public\\n        view\\n        returns (\\n            uint40\\n        )\\n    {\\n        (,uint40 nextQueueIndex,,) = _getBatchExtraData();\\n        return nextQueueIndex;\\n    }\\n\\n    /**\\n     * Returns the timestamp of the last transaction.\\n     * @return Timestamp for the last transaction.\\n     */\\n    function getLastTimestamp()\\n        public\\n        view\\n        returns (\\n            uint40\\n        )\\n    {\\n        (,,uint40 lastTimestamp,) = _getBatchExtraData();\\n        return lastTimestamp;\\n    }\\n\\n    /**\\n     * Returns the blocknumber of the last transaction.\\n     * @return Blocknumber for the last transaction.\\n     */\\n    function getLastBlockNumber()\\n        public\\n        view\\n        returns (\\n            uint40\\n        )\\n    {\\n        (,,,uint40 lastBlockNumber) = _getBatchExtraData();\\n        return lastBlockNumber;\\n    }\\n\\n    /**\\n     * Gets the queue element at a particular index.\\n     * @param _index Index of the queue element to access.\\n     * @return _element Queue element at the given index.\\n     */\\n    function getQueueElement(\\n        uint256 _index\\n    )\\n        public\\n        view\\n        returns (\\n            Lib_OVMCodec.QueueElement memory _element\\n        )\\n    {\\n        return _getQueueElement(\\n            _index,\\n            queue()\\n        );\\n    }\\n\\n    /**\\n     * Get the number of queue elements which have not yet been included.\\n     * @return Number of pending queue elements.\\n     */\\n    function getNumPendingQueueElements()\\n        public\\n        view\\n        returns (\\n            uint40\\n        )\\n    {\\n        return getQueueLength() - getNextQueueIndex();\\n    }\\n\\n   /**\\n     * Retrieves the length of the queue, including\\n     * both pending and canonical transactions.\\n     * @return Length of the queue.\\n     */\\n    function getQueueLength()\\n        public\\n        view\\n        returns (\\n            uint40\\n        )\\n    {\\n        return _getQueueLength(\\n            queue()\\n        );\\n    }\\n\\n    /**\\n     * Adds a transaction to the queue.\\n     * @param _target Target L2 contract to send the transaction to.\\n     * @param _gasLimit Gas limit for the enqueued L2 transaction.\\n     * @param _data Transaction data.\\n     */\\n    function enqueue(\\n        address _target,\\n        uint256 _gasLimit,\\n        bytes memory _data\\n    )\\n        external\\n    {\\n        require(\\n            _data.length <= MAX_ROLLUP_TX_SIZE,\\n            \\\"Transaction data size exceeds maximum for rollup transaction.\\\"\\n        );\\n\\n        require(\\n            _gasLimit <= maxTransactionGasLimit,\\n            \\\"Transaction gas limit exceeds maximum for rollup transaction.\\\"\\n        );\\n\\n        require(\\n            _gasLimit >= MIN_ROLLUP_TX_GAS,\\n            \\\"Transaction gas limit too low to enqueue.\\\"\\n        );\\n\\n        // Transactions submitted to the queue lack a method for paying gas fees to the Sequencer.\\n        // So we need to prevent spam attacks by ensuring that the cost of enqueueing a transaction\\n        // from L1 to L2 is not underpriced. Therefore, we define 'ENQUEUE_L2_GAS_PREPAID' as a\\n        // threshold. If the _gasLimit for the enqueued transaction is above this threshold, then we\\n        // 'charge' to user by burning additional L1 gas. Since gas is cheaper on L2 than L1, we\\n        // only need to burn a fraction of the provided L1 gas, which is determined by the\\n        // L2_GAS_DISCOUNT_DIVISOR.\\n        if(_gasLimit > ENQUEUE_L2_GAS_PREPAID) {\\n            uint256 gasToConsume = (_gasLimit - ENQUEUE_L2_GAS_PREPAID) / L2_GAS_DISCOUNT_DIVISOR;\\n            uint256 startingGas = gasleft();\\n\\n            // Although this check is not necessary (burn below will run out of gas if not true), it\\n            // gives the user an explicit reason as to why the enqueue attempt failed.\\n            require(\\n                startingGas > gasToConsume,\\n                \\\"Insufficient gas for L2 rate limiting burn.\\\"\\n            );\\n\\n            uint256 i;\\n            while(startingGas - gasleft() < gasToConsume) {\\n                i++;\\n            }\\n        }\\n\\n        // Apply an aliasing unless msg.sender == tx.origin. This prevents an attack in which a\\n        // contract on L1 has the same address as a contract on L2 but doesn't have the same code.\\n        // We can safely ignore this for EOAs because they're guaranteed to have the same \\\"code\\\"\\n        // (i.e. no code at all). This also makes it possible for users to interact with contracts\\n        // on L2 even when the Sequencer is down.\\n        address sender;\\n        if (msg.sender == tx.origin) {\\n            sender = msg.sender;\\n        } else {\\n            sender = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\\n        }\\n\\n        bytes32 transactionHash = keccak256(\\n            abi.encode(\\n                sender,\\n                _target,\\n                _gasLimit,\\n                _data\\n            )\\n        );\\n\\n        bytes32 timestampAndBlockNumber;\\n        assembly {\\n            timestampAndBlockNumber := timestamp()\\n            timestampAndBlockNumber := or(timestampAndBlockNumber, shl(40, number()))\\n        }\\n\\n        IChainStorageContainer queueRef = queue();\\n\\n        queueRef.push(transactionHash);\\n        queueRef.push(timestampAndBlockNumber);\\n\\n        // The underlying queue data structure stores 2 elements\\n        // per insertion, so to get the real queue length we need\\n        // to divide by 2 and subtract 1.\\n        uint256 queueIndex = queueRef.length() / 2 - 1;\\n        emit TransactionEnqueued(\\n            sender,\\n            _target,\\n            _gasLimit,\\n            _data,\\n            queueIndex,\\n            block.timestamp\\n        );\\n    }\\n\\n    /**\\n     * Allows the sequencer to append a batch of transactions.\\n     * @dev This function uses a custom encoding scheme for efficiency reasons.\\n     * .param _shouldStartAtElement Specific batch we expect to start appending to.\\n     * .param _totalElementsToAppend Total number of batch elements we expect to append.\\n     * .param _contexts Array of batch contexts.\\n     * .param _transactionDataFields Array of raw transaction data.\\n     */\\n    function appendSequencerBatch()\\n        external\\n    {\\n        uint40 shouldStartAtElement;\\n        uint24 totalElementsToAppend;\\n        uint24 numContexts;\\n        assembly {\\n            shouldStartAtElement  := shr(216, calldataload(4))\\n            totalElementsToAppend := shr(232, calldataload(9))\\n            numContexts           := shr(232, calldataload(12))\\n        }\\n\\n        require(\\n            shouldStartAtElement == getTotalElements(),\\n            \\\"Actual batch start index does not match expected start index.\\\"\\n        );\\n\\n        require(\\n            msg.sender == resolve(\\\"OVM_Sequencer\\\"),\\n            \\\"Function can only be called by the Sequencer.\\\"\\n        );\\n\\n        uint40 nextTransactionPtr = uint40(\\n            BATCH_CONTEXT_START_POS + BATCH_CONTEXT_SIZE * numContexts\\n        );\\n\\n        require(\\n            msg.data.length >= nextTransactionPtr,\\n            \\\"Not enough BatchContexts provided.\\\"\\n        );\\n\\n        // Take a reference to the queue and its length so we don't have to keep resolving it.\\n        // Length isn't going to change during the course of execution, so it's fine to simply\\n        // resolve this once at the start. Saves gas.\\n        IChainStorageContainer queueRef = queue();\\n        uint40 queueLength = _getQueueLength(queueRef);\\n\\n        // Counter for number of sequencer transactions appended so far.\\n        uint32 numSequencerTransactions = 0;\\n\\n        // We will sequentially append leaves which are pointers to the queue.\\n        // The initial queue index is what is currently in storage.\\n        uint40 nextQueueIndex = getNextQueueIndex();\\n\\n        BatchContext memory curContext;\\n        for (uint32 i = 0; i < numContexts; i++) {\\n            BatchContext memory nextContext = _getBatchContext(i);\\n\\n            // Now we can update our current context.\\n            curContext = nextContext;\\n\\n            // Process sequencer transactions first.\\n            numSequencerTransactions += uint32(curContext.numSequencedTransactions);\\n\\n            // Now process any subsequent queue transactions.\\n            nextQueueIndex += uint40(curContext.numSubsequentQueueTransactions);\\n\\n        }\\n        require(\\n            nextQueueIndex <= queueLength,\\n            \\\"Attempted to append more elements than are available in the queue.\\\"\\n        );\\n\\n        // Generate the required metadata that we need to append this batch\\n        uint40 numQueuedTransactions = totalElementsToAppend - numSequencerTransactions;\\n        uint40 blockTimestamp;\\n        uint40 blockNumber;\\n        if (curContext.numSubsequentQueueTransactions == 0) {\\n            // The last element is a sequencer tx, therefore pull timestamp and block number from\\n            // the last context.\\n            blockTimestamp = uint40(curContext.timestamp);\\n            blockNumber = uint40(curContext.blockNumber);\\n        } else {\\n            // The last element is a queue tx, therefore pull timestamp and block number from the\\n            // queue element.\\n            // curContext.numSubsequentQueueTransactions > 0 which means that we've processed at\\n            // least one queue element. We increment nextQueueIndex after processing each queue\\n            // element, so the index of the last element we processed is nextQueueIndex - 1.\\n            Lib_OVMCodec.QueueElement memory lastElement = _getQueueElement(\\n                nextQueueIndex - 1,\\n                queueRef\\n            );\\n\\n            blockTimestamp = lastElement.timestamp;\\n            blockNumber = lastElement.blockNumber;\\n        }\\n\\n        // Cache the previous blockhash to ensure all transaction data can be retrieved efficiently.\\n        _appendBatch(\\n            blockhash(block.number-1),\\n            totalElementsToAppend,\\n            numQueuedTransactions,\\n            blockTimestamp,\\n            blockNumber\\n        );\\n\\n        emit SequencerBatchAppended(\\n            nextQueueIndex - numQueuedTransactions,\\n            numQueuedTransactions,\\n            getTotalElements()\\n        );\\n    }\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Returns the BatchContext located at a particular index.\\n     * @param _index The index of the BatchContext\\n     * @return The BatchContext at the specified index.\\n     */\\n    function _getBatchContext(\\n        uint256 _index\\n    )\\n        internal\\n        pure\\n        returns (\\n            BatchContext memory\\n        )\\n    {\\n        uint256 contextPtr = 15 + _index * BATCH_CONTEXT_SIZE;\\n        uint256 numSequencedTransactions;\\n        uint256 numSubsequentQueueTransactions;\\n        uint256 ctxTimestamp;\\n        uint256 ctxBlockNumber;\\n\\n        assembly {\\n            numSequencedTransactions       := shr(232, calldataload(contextPtr))\\n            numSubsequentQueueTransactions := shr(232, calldataload(add(contextPtr, 3)))\\n            ctxTimestamp                   := shr(216, calldataload(add(contextPtr, 6)))\\n            ctxBlockNumber                 := shr(216, calldataload(add(contextPtr, 11)))\\n        }\\n\\n        return BatchContext({\\n            numSequencedTransactions: numSequencedTransactions,\\n            numSubsequentQueueTransactions: numSubsequentQueueTransactions,\\n            timestamp: ctxTimestamp,\\n            blockNumber: ctxBlockNumber\\n        });\\n    }\\n\\n    /**\\n     * Parses the batch context from the extra data.\\n     * @return Total number of elements submitted.\\n     * @return Index of the next queue element.\\n     */\\n    function _getBatchExtraData()\\n        internal\\n        view\\n        returns (\\n            uint40,\\n            uint40,\\n            uint40,\\n            uint40\\n        )\\n    {\\n        bytes27 extraData = batches().getGlobalMetadata();\\n\\n        uint40 totalElements;\\n        uint40 nextQueueIndex;\\n        uint40 lastTimestamp;\\n        uint40 lastBlockNumber;\\n\\n        // solhint-disable max-line-length\\n        assembly {\\n            extraData       :=  shr(40, extraData)\\n            totalElements   :=  and(extraData, 0x000000000000000000000000000000000000000000000000000000FFFFFFFFFF)\\n            nextQueueIndex  :=  shr(40, and(extraData, 0x00000000000000000000000000000000000000000000FFFFFFFFFF0000000000))\\n            lastTimestamp   :=  shr(80, and(extraData, 0x0000000000000000000000000000000000FFFFFFFFFF00000000000000000000))\\n            lastBlockNumber :=  shr(120, and(extraData, 0x000000000000000000000000FFFFFFFFFF000000000000000000000000000000))\\n        }\\n        // solhint-enable max-line-length\\n\\n        return (\\n            totalElements,\\n            nextQueueIndex,\\n            lastTimestamp,\\n            lastBlockNumber\\n        );\\n    }\\n\\n    /**\\n     * Encodes the batch context for the extra data.\\n     * @param _totalElements Total number of elements submitted.\\n     * @param _nextQueueIndex Index of the next queue element.\\n     * @param _timestamp Timestamp for the last batch.\\n     * @param _blockNumber Block number of the last batch.\\n     * @return Encoded batch context.\\n     */\\n    function _makeBatchExtraData(\\n        uint40 _totalElements,\\n        uint40 _nextQueueIndex,\\n        uint40 _timestamp,\\n        uint40 _blockNumber\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes27\\n        )\\n    {\\n        bytes27 extraData;\\n        assembly {\\n            extraData := _totalElements\\n            extraData := or(extraData, shl(40, _nextQueueIndex))\\n            extraData := or(extraData, shl(80, _timestamp))\\n            extraData := or(extraData, shl(120, _blockNumber))\\n            extraData := shl(40, extraData)\\n        }\\n\\n        return extraData;\\n    }\\n\\n    /**\\n     * Gets the queue element at a particular index.\\n     * @param _index Index of the queue element to access.\\n     * @return _element Queue element at the given index.\\n     */\\n    function _getQueueElement(\\n        uint256 _index,\\n        IChainStorageContainer _queueRef\\n    )\\n        internal\\n        view\\n        returns (\\n            Lib_OVMCodec.QueueElement memory _element\\n        )\\n    {\\n        // The underlying queue data structure stores 2 elements\\n        // per insertion, so to get the actual desired queue index\\n        // we need to multiply by 2.\\n        uint40 trueIndex = uint40(_index * 2);\\n        bytes32 transactionHash = _queueRef.get(trueIndex);\\n        bytes32 timestampAndBlockNumber = _queueRef.get(trueIndex + 1);\\n\\n        uint40 elementTimestamp;\\n        uint40 elementBlockNumber;\\n        // solhint-disable max-line-length\\n        assembly {\\n            elementTimestamp   :=         and(timestampAndBlockNumber, 0x000000000000000000000000000000000000000000000000000000FFFFFFFFFF)\\n            elementBlockNumber := shr(40, and(timestampAndBlockNumber, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000000000))\\n        }\\n        // solhint-enable max-line-length\\n\\n        return Lib_OVMCodec.QueueElement({\\n            transactionHash: transactionHash,\\n            timestamp: elementTimestamp,\\n            blockNumber: elementBlockNumber\\n        });\\n    }\\n\\n    /**\\n     * Retrieves the length of the queue.\\n     * @return Length of the queue.\\n     */\\n    function _getQueueLength(\\n        IChainStorageContainer _queueRef\\n    )\\n        internal\\n        view\\n        returns (\\n            uint40\\n        )\\n    {\\n        // The underlying queue data structure stores 2 elements\\n        // per insertion, so to get the real queue length we need\\n        // to divide by 2.\\n        return uint40(_queueRef.length() / 2);\\n    }\\n\\n    /**\\n     * Inserts a batch into the chain of batches.\\n     * @param _transactionRoot Root of the transaction tree for this batch.\\n     * @param _batchSize Number of elements in the batch.\\n     * @param _numQueuedTransactions Number of queue transactions in the batch.\\n     * @param _timestamp The latest batch timestamp.\\n     * @param _blockNumber The latest batch blockNumber.\\n     */\\n    function _appendBatch(\\n        bytes32 _transactionRoot,\\n        uint256 _batchSize,\\n        uint256 _numQueuedTransactions,\\n        uint40 _timestamp,\\n        uint40 _blockNumber\\n    )\\n        internal\\n    {\\n        IChainStorageContainer batchesRef = batches();\\n        (uint40 totalElements, uint40 nextQueueIndex,,) = _getBatchExtraData();\\n\\n        Lib_OVMCodec.ChainBatchHeader memory header = Lib_OVMCodec.ChainBatchHeader({\\n            batchIndex: batchesRef.length(),\\n            batchRoot: _transactionRoot,\\n            batchSize: _batchSize,\\n            prevTotalElements: totalElements,\\n            extraData: hex\\\"\\\"\\n        });\\n\\n        emit TransactionBatchAppended(\\n            header.batchIndex,\\n            header.batchRoot,\\n            header.batchSize,\\n            header.prevTotalElements,\\n            header.extraData\\n        );\\n\\n        bytes32 batchHeaderHash = Lib_OVMCodec.hashBatchHeader(header);\\n        bytes27 latestBatchContext = _makeBatchExtraData(\\n            totalElements + uint40(header.batchSize),\\n            nextQueueIndex + uint40(_numQueuedTransactions),\\n            _timestamp,\\n            _blockNumber\\n        );\\n\\n        batchesRef.push(batchHeaderHash, latestBatchContext);\\n    }\\n\\n\\n    /**\\n     * Hashes a transaction chain element.\\n     * @param _element Chain element to hash.\\n     * @return Hash of the chain element.\\n     */\\n    function _hashTransactionChainElement(\\n        Lib_OVMCodec.TransactionChainElement memory _element\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32\\n        )\\n    {\\n        return keccak256(\\n            abi.encode(\\n                _element.isSequenced,\\n                _element.queueIndex,\\n                _element.timestamp,\\n                _element.blockNumber,\\n                _element.txData\\n            )\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0xaa9103c34dfb1ef15cb3e6de60e51b1e4d4754dfb0c1672367abd926e9610c5f\",\"license\":\"MIT\"},\"contracts/L1/rollup/ICanonicalTransactionChain.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.9.0;\\n\\n/* Library Imports */\\nimport { Lib_OVMCodec } from \\\"../../libraries/codec/Lib_OVMCodec.sol\\\";\\n\\n/* Interface Imports */\\nimport { IChainStorageContainer } from \\\"./IChainStorageContainer.sol\\\";\\n\\n/**\\n * @title ICanonicalTransactionChain\\n */\\ninterface ICanonicalTransactionChain {\\n\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event TransactionEnqueued(\\n        address indexed _l1TxOrigin,\\n        address indexed _target,\\n        uint256 _gasLimit,\\n        bytes _data,\\n        uint256 indexed _queueIndex,\\n        uint256 _timestamp\\n    );\\n\\n    event QueueBatchAppended(\\n        uint256 _startingQueueIndex,\\n        uint256 _numQueueElements,\\n        uint256 _totalElements\\n    );\\n\\n    event SequencerBatchAppended(\\n        uint256 _startingQueueIndex,\\n        uint256 _numQueueElements,\\n        uint256 _totalElements\\n    );\\n\\n    event TransactionBatchAppended(\\n        uint256 indexed _batchIndex,\\n        bytes32 _batchRoot,\\n        uint256 _batchSize,\\n        uint256 _prevTotalElements,\\n        bytes _extraData\\n    );\\n\\n\\n    /***********\\n     * Structs *\\n     ***********/\\n\\n    struct BatchContext {\\n        uint256 numSequencedTransactions;\\n        uint256 numSubsequentQueueTransactions;\\n        uint256 timestamp;\\n        uint256 blockNumber;\\n    }\\n\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n\\n    /**\\n     * Accesses the batch storage container.\\n     * @return Reference to the batch storage container.\\n     */\\n    function batches()\\n        external\\n        view\\n        returns (\\n            IChainStorageContainer\\n        );\\n\\n    /**\\n     * Accesses the queue storage container.\\n     * @return Reference to the queue storage container.\\n     */\\n    function queue()\\n        external\\n        view\\n        returns (\\n            IChainStorageContainer\\n        );\\n\\n    /**\\n     * Retrieves the total number of elements submitted.\\n     * @return _totalElements Total submitted elements.\\n     */\\n    function getTotalElements()\\n        external\\n        view\\n        returns (\\n            uint256 _totalElements\\n        );\\n\\n    /**\\n     * Retrieves the total number of batches submitted.\\n     * @return _totalBatches Total submitted batches.\\n     */\\n    function getTotalBatches()\\n        external\\n        view\\n        returns (\\n            uint256 _totalBatches\\n        );\\n\\n    /**\\n     * Returns the index of the next element to be enqueued.\\n     * @return Index for the next queue element.\\n     */\\n    function getNextQueueIndex()\\n        external\\n        view\\n        returns (\\n            uint40\\n        );\\n\\n    /**\\n     * Gets the queue element at a particular index.\\n     * @param _index Index of the queue element to access.\\n     * @return _element Queue element at the given index.\\n     */\\n    function getQueueElement(\\n        uint256 _index\\n    )\\n        external\\n        view\\n        returns (\\n            Lib_OVMCodec.QueueElement memory _element\\n        );\\n\\n    /**\\n     * Returns the timestamp of the last transaction.\\n     * @return Timestamp for the last transaction.\\n     */\\n    function getLastTimestamp()\\n        external\\n        view\\n        returns (\\n            uint40\\n        );\\n\\n    /**\\n     * Returns the blocknumber of the last transaction.\\n     * @return Blocknumber for the last transaction.\\n     */\\n    function getLastBlockNumber()\\n        external\\n        view\\n        returns (\\n            uint40\\n        );\\n\\n    /**\\n     * Get the number of queue elements which have not yet been included.\\n     * @return Number of pending queue elements.\\n     */\\n    function getNumPendingQueueElements()\\n        external\\n        view\\n        returns (\\n            uint40\\n        );\\n\\n    /**\\n     * Retrieves the length of the queue, including\\n     * both pending and canonical transactions.\\n     * @return Length of the queue.\\n     */\\n    function getQueueLength()\\n        external\\n        view\\n        returns (\\n            uint40\\n        );\\n\\n\\n    /**\\n     * Adds a transaction to the queue.\\n     * @param _target Target contract to send the transaction to.\\n     * @param _gasLimit Gas limit for the given transaction.\\n     * @param _data Transaction data.\\n     */\\n    function enqueue(\\n        address _target,\\n        uint256 _gasLimit,\\n        bytes memory _data\\n    )\\n        external;\\n\\n    /**\\n     * Allows the sequencer to append a batch of transactions.\\n     * @dev This function uses a custom encoding scheme for efficiency reasons.\\n     * .param _shouldStartAtElement Specific batch we expect to start appending to.\\n     * .param _totalElementsToAppend Total number of batch elements we expect to append.\\n     * .param _contexts Array of batch contexts.\\n     * .param _transactionDataFields Array of raw transaction data.\\n     */\\n    function appendSequencerBatch(\\n        // uint40 _shouldStartAtElement,\\n        // uint24 _totalElementsToAppend,\\n        // BatchContext[] _contexts,\\n        // bytes[] _transactionDataFields\\n    )\\n        external;\\n}\\n\",\"keccak256\":\"0xb3375bb538efe660c1e0a4af0570442f22d1edfc488c3db08ac24d1c3495d0ef\",\"license\":\"MIT\"},\"contracts/L1/rollup/IChainStorageContainer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.9.0;\\n\\n/**\\n * @title IChainStorageContainer\\n */\\ninterface IChainStorageContainer {\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Sets the container's global metadata field. We're using `bytes27` here because we use five\\n     * bytes to maintain the length of the underlying data structure, meaning we have an extra\\n     * 27 bytes to store arbitrary data.\\n     * @param _globalMetadata New global metadata to set.\\n     */\\n    function setGlobalMetadata(\\n        bytes27 _globalMetadata\\n    )\\n        external;\\n\\n    /**\\n     * Retrieves the container's global metadata field.\\n     * @return Container global metadata field.\\n     */\\n    function getGlobalMetadata()\\n        external\\n        view\\n        returns (\\n            bytes27\\n        );\\n\\n    /**\\n     * Retrieves the number of objects stored in the container.\\n     * @return Number of objects in the container.\\n     */\\n    function length()\\n        external\\n        view\\n        returns (\\n            uint256\\n        );\\n\\n    /**\\n     * Pushes an object into the container.\\n     * @param _object A 32 byte value to insert into the container.\\n     */\\n    function push(\\n        bytes32 _object\\n    )\\n        external;\\n\\n    /**\\n     * Pushes an object into the container. Function allows setting the global metadata since\\n     * we'll need to touch the \\\"length\\\" storage slot anyway, which also contains the global\\n     * metadata (it's an optimization).\\n     * @param _object A 32 byte value to insert into the container.\\n     * @param _globalMetadata New global metadata for the container.\\n     */\\n    function push(\\n        bytes32 _object,\\n        bytes27 _globalMetadata\\n    )\\n        external;\\n\\n    /**\\n     * Retrieves an object from the container.\\n     * @param _index Index of the particular object to access.\\n     * @return 32 byte object value.\\n     */\\n    function get(\\n        uint256 _index\\n    )\\n        external\\n        view\\n        returns (\\n            bytes32\\n        );\\n\\n    /**\\n     * Removes all objects after and including a given index.\\n     * @param _index Object index to delete from.\\n     */\\n    function deleteElementsAfterInclusive(\\n        uint256 _index\\n    )\\n        external;\\n\\n    /**\\n     * Removes all objects after and including a given index. Also allows setting the global\\n     * metadata field.\\n     * @param _index Object index to delete from.\\n     * @param _globalMetadata New global metadata for the container.\\n     */\\n    function deleteElementsAfterInclusive(\\n        uint256 _index,\\n        bytes27 _globalMetadata\\n    )\\n        external;\\n}\\n\",\"keccak256\":\"0xf50d8b93a385b40ce4e3a42c97e5431ee148c1abcfd5d7dee48301c76a6aa207\",\"license\":\"MIT\"},\"contracts/libraries/codec/Lib_OVMCodec.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport { Lib_RLPReader } from \\\"../rlp/Lib_RLPReader.sol\\\";\\nimport { Lib_RLPWriter } from \\\"../rlp/Lib_RLPWriter.sol\\\";\\nimport { Lib_BytesUtils } from \\\"../utils/Lib_BytesUtils.sol\\\";\\nimport { Lib_Bytes32Utils } from \\\"../utils/Lib_Bytes32Utils.sol\\\";\\n\\n/**\\n * @title Lib_OVMCodec\\n */\\nlibrary Lib_OVMCodec {\\n\\n    /*********\\n     * Enums *\\n     *********/\\n\\n    enum QueueOrigin {\\n        SEQUENCER_QUEUE,\\n        L1TOL2_QUEUE\\n    }\\n\\n\\n    /***********\\n     * Structs *\\n     ***********/\\n\\n    struct EVMAccount {\\n        uint256 nonce;\\n        uint256 balance;\\n        bytes32 storageRoot;\\n        bytes32 codeHash;\\n    }\\n\\n    struct ChainBatchHeader {\\n        uint256 batchIndex;\\n        bytes32 batchRoot;\\n        uint256 batchSize;\\n        uint256 prevTotalElements;\\n        bytes extraData;\\n    }\\n\\n    struct ChainInclusionProof {\\n        uint256 index;\\n        bytes32[] siblings;\\n    }\\n\\n    struct Transaction {\\n        uint256 timestamp;\\n        uint256 blockNumber;\\n        QueueOrigin l1QueueOrigin;\\n        address l1TxOrigin;\\n        address entrypoint;\\n        uint256 gasLimit;\\n        bytes data;\\n    }\\n\\n    struct TransactionChainElement {\\n        bool isSequenced;\\n        uint256 queueIndex;  // QUEUED TX ONLY\\n        uint256 timestamp;   // SEQUENCER TX ONLY\\n        uint256 blockNumber; // SEQUENCER TX ONLY\\n        bytes txData;        // SEQUENCER TX ONLY\\n    }\\n\\n    struct QueueElement {\\n        bytes32 transactionHash;\\n        uint40 timestamp;\\n        uint40 blockNumber;\\n    }\\n\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Encodes a standard OVM transaction.\\n     * @param _transaction OVM transaction to encode.\\n     * @return Encoded transaction bytes.\\n     */\\n    function encodeTransaction(\\n        Transaction memory _transaction\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        return abi.encodePacked(\\n            _transaction.timestamp,\\n            _transaction.blockNumber,\\n            _transaction.l1QueueOrigin,\\n            _transaction.l1TxOrigin,\\n            _transaction.entrypoint,\\n            _transaction.gasLimit,\\n            _transaction.data\\n        );\\n    }\\n\\n    /**\\n     * Hashes a standard OVM transaction.\\n     * @param _transaction OVM transaction to encode.\\n     * @return Hashed transaction\\n     */\\n    function hashTransaction(\\n        Transaction memory _transaction\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32\\n        )\\n    {\\n        return keccak256(encodeTransaction(_transaction));\\n    }\\n\\n    /**\\n     * @notice Decodes an RLP-encoded account state into a useful struct.\\n     * @param _encoded RLP-encoded account state.\\n     * @return Account state struct.\\n     */\\n    function decodeEVMAccount(\\n        bytes memory _encoded\\n    )\\n        internal\\n        pure\\n        returns (\\n            EVMAccount memory\\n        )\\n    {\\n        Lib_RLPReader.RLPItem[] memory accountState = Lib_RLPReader.readList(_encoded);\\n\\n        return EVMAccount({\\n            nonce: Lib_RLPReader.readUint256(accountState[0]),\\n            balance: Lib_RLPReader.readUint256(accountState[1]),\\n            storageRoot: Lib_RLPReader.readBytes32(accountState[2]),\\n            codeHash: Lib_RLPReader.readBytes32(accountState[3])\\n        });\\n    }\\n\\n    /**\\n     * Calculates a hash for a given batch header.\\n     * @param _batchHeader Header to hash.\\n     * @return Hash of the header.\\n     */\\n    function hashBatchHeader(\\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32\\n        )\\n    {\\n        return keccak256(\\n            abi.encode(\\n                _batchHeader.batchRoot,\\n                _batchHeader.batchSize,\\n                _batchHeader.prevTotalElements,\\n                _batchHeader.extraData\\n            )\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x3695142de033228a3c69d440f8454bbfe09ff2a15d1a81c18f0dbc0fef7902b1\",\"license\":\"MIT\"},\"contracts/libraries/resolver/Lib_AddressManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* External Imports */\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/**\\n * @title Lib_AddressManager\\n */\\ncontract Lib_AddressManager is Ownable {\\n\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event AddressSet(\\n        string indexed _name,\\n        address _newAddress,\\n        address _oldAddress\\n    );\\n\\n\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    mapping (bytes32 => address) private addresses;\\n\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Changes the address associated with a particular name.\\n     * @param _name String name to associate an address with.\\n     * @param _address Address to associate with the name.\\n     */\\n    function setAddress(\\n        string memory _name,\\n        address _address\\n    )\\n        external\\n        onlyOwner\\n    {\\n        bytes32 nameHash = _getNameHash(_name);\\n        address oldAddress = addresses[nameHash];\\n        addresses[nameHash] = _address;\\n\\n        emit AddressSet(\\n            _name,\\n            _address,\\n            oldAddress\\n        );\\n    }\\n\\n    /**\\n     * Retrieves the address associated with a given name.\\n     * @param _name Name to retrieve an address for.\\n     * @return Address associated with the given name.\\n     */\\n    function getAddress(\\n        string memory _name\\n    )\\n        external\\n        view\\n        returns (\\n            address\\n        )\\n    {\\n        return addresses[_getNameHash(_name)];\\n    }\\n\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Computes the hash of a name.\\n     * @param _name Name to compute a hash for.\\n     * @return Hash of the given name.\\n     */\\n    function _getNameHash(\\n        string memory _name\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32\\n        )\\n    {\\n        return keccak256(abi.encodePacked(_name));\\n    }\\n}\\n\",\"keccak256\":\"0x298ef132f6235a645cbfa41b66a0a5198a81bfda736ccf861a15ca6501a6ef90\",\"license\":\"MIT\"},\"contracts/libraries/resolver/Lib_AddressResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport { Lib_AddressManager } from \\\"./Lib_AddressManager.sol\\\";\\n\\n/**\\n * @title Lib_AddressResolver\\n */\\nabstract contract Lib_AddressResolver {\\n\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    Lib_AddressManager public libAddressManager;\\n\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    /**\\n     * @param _libAddressManager Address of the Lib_AddressManager.\\n     */\\n    constructor(\\n        address _libAddressManager\\n    ) {\\n        libAddressManager = Lib_AddressManager(_libAddressManager);\\n    }\\n\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Resolves the address associated with a given name.\\n     * @param _name Name to resolve an address for.\\n     * @return Address associated with the given name.\\n     */\\n    function resolve(\\n        string memory _name\\n    )\\n        public\\n        view\\n        returns (\\n            address\\n        )\\n    {\\n        return libAddressManager.getAddress(_name);\\n    }\\n}\\n\",\"keccak256\":\"0x63eb1ff905332fbb7df490780d10f303819f141ac0b6f7faf2fda6c83796515a\",\"license\":\"MIT\"},\"contracts/libraries/rlp/Lib_RLPReader.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Lib_RLPReader\\n * @dev Adapted from \\\"RLPReader\\\" by Hamdi Allam (hamdi.allam97@gmail.com).\\n */\\nlibrary Lib_RLPReader {\\n\\n    /*************\\n     * Constants *\\n     *************/\\n\\n    uint256 constant internal MAX_LIST_LENGTH = 32;\\n\\n\\n    /*********\\n     * Enums *\\n     *********/\\n\\n    enum RLPItemType {\\n        DATA_ITEM,\\n        LIST_ITEM\\n    }\\n\\n\\n    /***********\\n     * Structs *\\n     ***********/\\n\\n    struct RLPItem {\\n        uint256 length;\\n        uint256 ptr;\\n    }\\n\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Converts bytes to a reference to memory position and length.\\n     * @param _in Input bytes to convert.\\n     * @return Output memory reference.\\n     */\\n    function toRLPItem(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            RLPItem memory\\n        )\\n    {\\n        uint256 ptr;\\n        assembly {\\n            ptr := add(_in, 32)\\n        }\\n\\n        return RLPItem({\\n            length: _in.length,\\n            ptr: ptr\\n        });\\n    }\\n\\n    /**\\n     * Reads an RLP list value into a list of RLP items.\\n     * @param _in RLP list value.\\n     * @return Decoded RLP list items.\\n     */\\n    function readList(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            RLPItem[] memory\\n        )\\n    {\\n        (\\n            uint256 listOffset,\\n            ,\\n            RLPItemType itemType\\n        ) = _decodeLength(_in);\\n\\n        require(\\n            itemType == RLPItemType.LIST_ITEM,\\n            \\\"Invalid RLP list value.\\\"\\n        );\\n\\n        // Solidity in-memory arrays can't be increased in size, but *can* be decreased in size by\\n        // writing to the length. Since we can't know the number of RLP items without looping over\\n        // the entire input, we'd have to loop twice to accurately size this array. It's easier to\\n        // simply set a reasonable maximum list length and decrease the size before we finish.\\n        RLPItem[] memory out = new RLPItem[](MAX_LIST_LENGTH);\\n\\n        uint256 itemCount = 0;\\n        uint256 offset = listOffset;\\n        while (offset < _in.length) {\\n            require(\\n                itemCount < MAX_LIST_LENGTH,\\n                \\\"Provided RLP list exceeds max list length.\\\"\\n            );\\n\\n            (\\n                uint256 itemOffset,\\n                uint256 itemLength,\\n            ) = _decodeLength(RLPItem({\\n                length: _in.length - offset,\\n                ptr: _in.ptr + offset\\n            }));\\n\\n            out[itemCount] = RLPItem({\\n                length: itemLength + itemOffset,\\n                ptr: _in.ptr + offset\\n            });\\n\\n            itemCount += 1;\\n            offset += itemOffset + itemLength;\\n        }\\n\\n        // Decrease the array size to match the actual item count.\\n        assembly {\\n            mstore(out, itemCount)\\n        }\\n\\n        return out;\\n    }\\n\\n    /**\\n     * Reads an RLP list value into a list of RLP items.\\n     * @param _in RLP list value.\\n     * @return Decoded RLP list items.\\n     */\\n    function readList(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            RLPItem[] memory\\n        )\\n    {\\n        return readList(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads an RLP bytes value into bytes.\\n     * @param _in RLP bytes value.\\n     * @return Decoded bytes.\\n     */\\n    function readBytes(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        (\\n            uint256 itemOffset,\\n            uint256 itemLength,\\n            RLPItemType itemType\\n        ) = _decodeLength(_in);\\n\\n        require(\\n            itemType == RLPItemType.DATA_ITEM,\\n            \\\"Invalid RLP bytes value.\\\"\\n        );\\n\\n        return _copy(_in.ptr, itemOffset, itemLength);\\n    }\\n\\n    /**\\n     * Reads an RLP bytes value into bytes.\\n     * @param _in RLP bytes value.\\n     * @return Decoded bytes.\\n     */\\n    function readBytes(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        return readBytes(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads an RLP string value into a string.\\n     * @param _in RLP string value.\\n     * @return Decoded string.\\n     */\\n    function readString(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            string memory\\n        )\\n    {\\n        return string(readBytes(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP string value into a string.\\n     * @param _in RLP string value.\\n     * @return Decoded string.\\n     */\\n    function readString(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            string memory\\n        )\\n    {\\n        return readString(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads an RLP bytes32 value into a bytes32.\\n     * @param _in RLP bytes32 value.\\n     * @return Decoded bytes32.\\n     */\\n    function readBytes32(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32\\n        )\\n    {\\n        require(\\n            _in.length <= 33,\\n            \\\"Invalid RLP bytes32 value.\\\"\\n        );\\n\\n        (\\n            uint256 itemOffset,\\n            uint256 itemLength,\\n            RLPItemType itemType\\n        ) = _decodeLength(_in);\\n\\n        require(\\n            itemType == RLPItemType.DATA_ITEM,\\n            \\\"Invalid RLP bytes32 value.\\\"\\n        );\\n\\n        uint256 ptr = _in.ptr + itemOffset;\\n        bytes32 out;\\n        assembly {\\n            out := mload(ptr)\\n\\n            // Shift the bytes over to match the item size.\\n            if lt(itemLength, 32) {\\n                out := div(out, exp(256, sub(32, itemLength)))\\n            }\\n        }\\n\\n        return out;\\n    }\\n\\n    /**\\n     * Reads an RLP bytes32 value into a bytes32.\\n     * @param _in RLP bytes32 value.\\n     * @return Decoded bytes32.\\n     */\\n    function readBytes32(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32\\n        )\\n    {\\n        return readBytes32(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads an RLP uint256 value into a uint256.\\n     * @param _in RLP uint256 value.\\n     * @return Decoded uint256.\\n     */\\n    function readUint256(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint256\\n        )\\n    {\\n        return uint256(readBytes32(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP uint256 value into a uint256.\\n     * @param _in RLP uint256 value.\\n     * @return Decoded uint256.\\n     */\\n    function readUint256(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint256\\n        )\\n    {\\n        return readUint256(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads an RLP bool value into a bool.\\n     * @param _in RLP bool value.\\n     * @return Decoded bool.\\n     */\\n    function readBool(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bool\\n        )\\n    {\\n        require(\\n            _in.length == 1,\\n            \\\"Invalid RLP boolean value.\\\"\\n        );\\n\\n        uint256 ptr = _in.ptr;\\n        uint256 out;\\n        assembly {\\n            out := byte(0, mload(ptr))\\n        }\\n\\n        require(\\n            out == 0 || out == 1,\\n            \\\"Lib_RLPReader: Invalid RLP boolean value, must be 0 or 1\\\"\\n        );\\n\\n        return out != 0;\\n    }\\n\\n    /**\\n     * Reads an RLP bool value into a bool.\\n     * @param _in RLP bool value.\\n     * @return Decoded bool.\\n     */\\n    function readBool(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bool\\n        )\\n    {\\n        return readBool(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads an RLP address value into a address.\\n     * @param _in RLP address value.\\n     * @return Decoded address.\\n     */\\n    function readAddress(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            address\\n        )\\n    {\\n        if (_in.length == 1) {\\n            return address(0);\\n        }\\n\\n        require(\\n            _in.length == 21,\\n            \\\"Invalid RLP address value.\\\"\\n        );\\n\\n        return address(uint160(readUint256(_in)));\\n    }\\n\\n    /**\\n     * Reads an RLP address value into a address.\\n     * @param _in RLP address value.\\n     * @return Decoded address.\\n     */\\n    function readAddress(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            address\\n        )\\n    {\\n        return readAddress(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads the raw bytes of an RLP item.\\n     * @param _in RLP item to read.\\n     * @return Raw RLP bytes.\\n     */\\n    function readRawBytes(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        return _copy(_in);\\n    }\\n\\n\\n    /*********************\\n     * Private Functions *\\n     *********************/\\n\\n    /**\\n     * Decodes the length of an RLP item.\\n     * @param _in RLP item to decode.\\n     * @return Offset of the encoded data.\\n     * @return Length of the encoded data.\\n     * @return RLP item type (LIST_ITEM or DATA_ITEM).\\n     */\\n    function _decodeLength(\\n        RLPItem memory _in\\n    )\\n        private\\n        pure\\n        returns (\\n            uint256,\\n            uint256,\\n            RLPItemType\\n        )\\n    {\\n        require(\\n            _in.length > 0,\\n            \\\"RLP item cannot be null.\\\"\\n        );\\n\\n        uint256 ptr = _in.ptr;\\n        uint256 prefix;\\n        assembly {\\n            prefix := byte(0, mload(ptr))\\n        }\\n\\n        if (prefix <= 0x7f) {\\n            // Single byte.\\n\\n            return (0, 1, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xb7) {\\n            // Short string.\\n\\n            uint256 strLen = prefix - 0x80;\\n\\n            require(\\n                _in.length > strLen,\\n                \\\"Invalid RLP short string.\\\"\\n            );\\n\\n            return (1, strLen, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xbf) {\\n            // Long string.\\n            uint256 lenOfStrLen = prefix - 0xb7;\\n\\n            require(\\n                _in.length > lenOfStrLen,\\n                \\\"Invalid RLP long string length.\\\"\\n            );\\n\\n            uint256 strLen;\\n            assembly {\\n                // Pick out the string length.\\n                strLen := div(\\n                    mload(add(ptr, 1)),\\n                    exp(256, sub(32, lenOfStrLen))\\n                )\\n            }\\n\\n            require(\\n                _in.length > lenOfStrLen + strLen,\\n                \\\"Invalid RLP long string.\\\"\\n            );\\n\\n            return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xf7) {\\n            // Short list.\\n            uint256 listLen = prefix - 0xc0;\\n\\n            require(\\n                _in.length > listLen,\\n                \\\"Invalid RLP short list.\\\"\\n            );\\n\\n            return (1, listLen, RLPItemType.LIST_ITEM);\\n        } else {\\n            // Long list.\\n            uint256 lenOfListLen = prefix - 0xf7;\\n\\n            require(\\n                _in.length > lenOfListLen,\\n                \\\"Invalid RLP long list length.\\\"\\n            );\\n\\n            uint256 listLen;\\n            assembly {\\n                // Pick out the list length.\\n                listLen := div(\\n                    mload(add(ptr, 1)),\\n                    exp(256, sub(32, lenOfListLen))\\n                )\\n            }\\n\\n            require(\\n                _in.length > lenOfListLen + listLen,\\n                \\\"Invalid RLP long list.\\\"\\n            );\\n\\n            return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);\\n        }\\n    }\\n\\n    /**\\n     * Copies the bytes from a memory location.\\n     * @param _src Pointer to the location to read from.\\n     * @param _offset Offset to start reading from.\\n     * @param _length Number of bytes to read.\\n     * @return Copied bytes.\\n     */\\n    function _copy(\\n        uint256 _src,\\n        uint256 _offset,\\n        uint256 _length\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        bytes memory out = new bytes(_length);\\n        if (out.length == 0) {\\n            return out;\\n        }\\n\\n        uint256 src = _src + _offset;\\n        uint256 dest;\\n        assembly {\\n            dest := add(out, 32)\\n        }\\n\\n        // Copy over as many complete words as we can.\\n        for (uint256 i = 0; i < _length / 32; i++) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n\\n            src += 32;\\n            dest += 32;\\n        }\\n\\n        // Pick out the remaining bytes.\\n        uint256 mask;\\n        unchecked {\\n            mask = 256 ** (32 - (_length % 32)) - 1;\\n        }\\n\\n        assembly {\\n            mstore(\\n                dest,\\n                or(\\n                    and(mload(src), not(mask)),\\n                    and(mload(dest), mask)\\n                )\\n            )\\n        }\\n        return out;\\n    }\\n\\n    /**\\n     * Copies an RLP item into bytes.\\n     * @param _in RLP item to copy.\\n     * @return Copied bytes.\\n     */\\n    function _copy(\\n        RLPItem memory _in\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        return _copy(_in.ptr, 0, _in.length);\\n    }\\n}\\n\",\"keccak256\":\"0x24ebbbb58707cdd4e4d340efc6440b7ba16851c461b10eec43238e48b4c39283\",\"license\":\"MIT\"},\"contracts/libraries/rlp/Lib_RLPWriter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Lib_RLPWriter\\n * @author Bakaoh (with modifications)\\n */\\nlibrary Lib_RLPWriter {\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * RLP encodes a byte string.\\n     * @param _in The byte string to encode.\\n     * @return The RLP encoded string in bytes.\\n     */\\n    function writeBytes(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        bytes memory encoded;\\n\\n        if (_in.length == 1 && uint8(_in[0]) < 128) {\\n            encoded = _in;\\n        } else {\\n            encoded = abi.encodePacked(_writeLength(_in.length, 128), _in);\\n        }\\n\\n        return encoded;\\n    }\\n\\n    /**\\n     * RLP encodes a list of RLP encoded byte byte strings.\\n     * @param _in The list of RLP encoded byte strings.\\n     * @return The RLP encoded list of items in bytes.\\n     */\\n    function writeList(\\n        bytes[] memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        bytes memory list = _flatten(_in);\\n        return abi.encodePacked(_writeLength(list.length, 192), list);\\n    }\\n\\n    /**\\n     * RLP encodes a string.\\n     * @param _in The string to encode.\\n     * @return The RLP encoded string in bytes.\\n     */\\n    function writeString(\\n        string memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        return writeBytes(bytes(_in));\\n    }\\n\\n    /**\\n     * RLP encodes an address.\\n     * @param _in The address to encode.\\n     * @return The RLP encoded address in bytes.\\n     */\\n    function writeAddress(\\n        address _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        return writeBytes(abi.encodePacked(_in));\\n    }\\n\\n    /**\\n     * RLP encodes a uint.\\n     * @param _in The uint256 to encode.\\n     * @return The RLP encoded uint256 in bytes.\\n     */\\n    function writeUint(\\n        uint256 _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        return writeBytes(_toBinary(_in));\\n    }\\n\\n    /**\\n     * RLP encodes a bool.\\n     * @param _in The bool to encode.\\n     * @return The RLP encoded bool in bytes.\\n     */\\n    function writeBool(\\n        bool _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        bytes memory encoded = new bytes(1);\\n        encoded[0] = (_in ? bytes1(0x01) : bytes1(0x80));\\n        return encoded;\\n    }\\n\\n\\n    /*********************\\n     * Private Functions *\\n     *********************/\\n\\n    /**\\n     * Encode the first byte, followed by the `len` in binary form if `length` is more than 55.\\n     * @param _len The length of the string or the payload.\\n     * @param _offset 128 if item is string, 192 if item is list.\\n     * @return RLP encoded bytes.\\n     */\\n    function _writeLength(\\n        uint256 _len,\\n        uint256 _offset\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        bytes memory encoded;\\n\\n        if (_len < 56) {\\n            encoded = new bytes(1);\\n            encoded[0] = bytes1(uint8(_len) + uint8(_offset));\\n        } else {\\n            uint256 lenLen;\\n            uint256 i = 1;\\n            while (_len / i != 0) {\\n                lenLen++;\\n                i *= 256;\\n            }\\n\\n            encoded = new bytes(lenLen + 1);\\n            encoded[0] = bytes1(uint8(lenLen) + uint8(_offset) + 55);\\n            for(i = 1; i <= lenLen; i++) {\\n                encoded[i] = bytes1(uint8((_len / (256**(lenLen-i))) % 256));\\n            }\\n        }\\n\\n        return encoded;\\n    }\\n\\n    /**\\n     * Encode integer in big endian binary form with no leading zeroes.\\n     * @notice TODO: This should be optimized with assembly to save gas costs.\\n     * @param _x The integer to encode.\\n     * @return RLP encoded bytes.\\n     */\\n    function _toBinary(\\n        uint256 _x\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        bytes memory b = abi.encodePacked(_x);\\n\\n        uint256 i = 0;\\n        for (; i < 32; i++) {\\n            if (b[i] != 0) {\\n                break;\\n            }\\n        }\\n\\n        bytes memory res = new bytes(32 - i);\\n        for (uint256 j = 0; j < res.length; j++) {\\n            res[j] = b[i++];\\n        }\\n\\n        return res;\\n    }\\n\\n    /**\\n     * Copies a piece of memory to another location.\\n     * @notice From: https://github.com/Arachnid/solidity-stringutils/blob/master/src/strings.sol.\\n     * @param _dest Destination location.\\n     * @param _src Source location.\\n     * @param _len Length of memory to copy.\\n     */\\n    function _memcpy(\\n        uint256 _dest,\\n        uint256 _src,\\n        uint256 _len\\n    )\\n        private\\n        pure\\n    {\\n        uint256 dest = _dest;\\n        uint256 src = _src;\\n        uint256 len = _len;\\n\\n        for(; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        uint256 mask;\\n        unchecked {\\n            mask = 256 ** (32 - len) - 1;\\n        }\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n\\n    /**\\n     * Flattens a list of byte strings into one byte string.\\n     * @notice From: https://github.com/sammayo/solidity-rlp-encoder/blob/master/RLPEncode.sol.\\n     * @param _list List of byte strings to flatten.\\n     * @return The flattened byte string.\\n     */\\n    function _flatten(\\n        bytes[] memory _list\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        if (_list.length == 0) {\\n            return new bytes(0);\\n        }\\n\\n        uint256 len;\\n        uint256 i = 0;\\n        for (; i < _list.length; i++) {\\n            len += _list[i].length;\\n        }\\n\\n        bytes memory flattened = new bytes(len);\\n        uint256 flattenedPtr;\\n        assembly { flattenedPtr := add(flattened, 0x20) }\\n\\n        for(i = 0; i < _list.length; i++) {\\n            bytes memory item = _list[i];\\n\\n            uint256 listPtr;\\n            assembly { listPtr := add(item, 0x20)}\\n\\n            _memcpy(flattenedPtr, listPtr, item.length);\\n            flattenedPtr += _list[i].length;\\n        }\\n\\n        return flattened;\\n    }\\n}\\n\",\"keccak256\":\"0x8b43953622efbd36ad86b852012d549412327b3c9e9dbedd8e8513cbe408c03f\",\"license\":\"MIT\"},\"contracts/libraries/utils/Lib_Bytes32Utils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Lib_Byte32Utils\\n */\\nlibrary Lib_Bytes32Utils {\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Converts a bytes32 value to a boolean. Anything non-zero will be converted to \\\"true.\\\"\\n     * @param _in Input bytes32 value.\\n     * @return Bytes32 as a boolean.\\n     */\\n    function toBool(\\n        bytes32 _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bool\\n        )\\n    {\\n        return _in != 0;\\n    }\\n\\n    /**\\n     * Converts a boolean to a bytes32 value.\\n     * @param _in Input boolean value.\\n     * @return Boolean as a bytes32.\\n     */\\n    function fromBool(\\n        bool _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32\\n        )\\n    {\\n        return bytes32(uint256(_in ? 1 : 0));\\n    }\\n\\n    /**\\n     * Converts a bytes32 value to an address. Takes the *last* 20 bytes.\\n     * @param _in Input bytes32 value.\\n     * @return Bytes32 as an address.\\n     */\\n    function toAddress(\\n        bytes32 _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            address\\n        )\\n    {\\n        return address(uint160(uint256(_in)));\\n    }\\n\\n    /**\\n     * Converts an address to a bytes32.\\n     * @param _in Input address value.\\n     * @return Address as a bytes32.\\n     */\\n    function fromAddress(\\n        address _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32\\n        )\\n    {\\n        return bytes32(uint256(uint160(_in)));\\n    }\\n}\\n\",\"keccak256\":\"0xf9f813f7565c40898a4dc55aa8211d740859669bfbe60b438964a4ccc7981476\",\"license\":\"MIT\"},\"contracts/libraries/utils/Lib_BytesUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Lib_BytesUtils\\n */\\nlibrary Lib_BytesUtils {\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n        require(_start + _length >= _start, \\\"slice_overflow\\\");\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        if (_start >= _bytes.length) {\\n            return bytes(\\\"\\\");\\n        }\\n\\n        return slice(_bytes, _start, _bytes.length - _start);\\n    }\\n\\n    function toBytes32(\\n        bytes memory _bytes\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32\\n        )\\n    {\\n        if (_bytes.length < 32) {\\n            bytes32 ret;\\n            assembly {\\n                ret := mload(add(_bytes, 32))\\n            }\\n            return ret;\\n        }\\n\\n        return abi.decode(_bytes,(bytes32)); // will truncate if input length > 32 bytes\\n    }\\n\\n    function toUint256(\\n        bytes memory _bytes\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint256\\n        )\\n    {\\n        return uint256(toBytes32(_bytes));\\n    }\\n\\n    function toNibbles(\\n        bytes memory _bytes\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        bytes memory nibbles = new bytes(_bytes.length * 2);\\n\\n        for (uint256 i = 0; i < _bytes.length; i++) {\\n            nibbles[i * 2] = _bytes[i] >> 4;\\n            nibbles[i * 2 + 1] = bytes1(uint8(_bytes[i]) % 16);\\n        }\\n\\n        return nibbles;\\n    }\\n\\n    function fromNibbles(\\n        bytes memory _bytes\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        bytes memory ret = new bytes(_bytes.length / 2);\\n\\n        for (uint256 i = 0; i < ret.length; i++) {\\n            ret[i] = (_bytes[i * 2] << 4) | (_bytes[i * 2 + 1]);\\n        }\\n\\n        return ret;\\n    }\\n\\n    function equal(\\n        bytes memory _bytes,\\n        bytes memory _other\\n    )\\n        internal\\n        pure\\n        returns (\\n            bool\\n        )\\n    {\\n        return keccak256(_bytes) == keccak256(_other);\\n    }\\n}\\n\",\"keccak256\":\"0xb33f2e5403714ecbcda611b676a746fc47f48f6a05916e8c893c2368758e7a82\",\"license\":\"MIT\"},\"contracts/standards/AddressAliasHelper.sol\":{\"content\":\"\\n// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2019-2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.8.7;\\n\\nlibrary AddressAliasHelper {\\n    uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);\\n\\n    /// @notice Utility function that converts the address in the L1 that submitted a tx to\\n    /// the inbox to the msg.sender viewed in the L2\\n    /// @param l1Address the address in the L1 that triggered the tx to L2\\n    /// @return l2Address L2 address as viewed in msg.sender\\n    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\\n        unchecked {\\n            l2Address = address(uint160(l1Address) + offset);\\n        }\\n    }\\n\\n    /// @notice Utility function that converts the msg.sender viewed in the L2 to the\\n    /// address in the L1 that submitted a tx to the inbox\\n    /// @param l2Address L2 address as viewed in msg.sender\\n    /// @return l1Address the address in the L1 that triggered the tx to L2\\n    function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {\\n        unchecked {\\n            l1Address = address(uint160(l2Address) - offset);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x4bee07249549c0c3a33d749a1787fb0262fe0a5aef2627ed78d5fd004102ae87\",\"license\":\"Apache-2.0\"}},\"version\":1}",
  "bytecode": "0x60e06040523480156200001157600080fd5b5060405162001c5238038062001c52833981016040819052620000349162000078565b600080546001600160a01b0319166001600160a01b0386161790556001839055608082905260a08190526200006a8183620000c5565b60c05250620000f392505050565b600080600080608085870312156200008f57600080fd5b84516001600160a01b0381168114620000a757600080fd5b60208601516040870151606090970151919890975090945092505050565b6000816000190483118215151615620000ee57634e487b7160e01b600052601160045260246000fd5b500290565b60805160a05160c051611b1a6200013860003960008181610235015281816105ee015261063c015260006102870152600081816102e201526106180152611b1a6000f3fe608060405234801561001057600080fd5b506004361061016c5760003560e01c80637aa63a86116100cd578063cfdf677e11610081578063e10d29ee11610066578063e10d29ee14610314578063e561dddc1461031c578063f722b41a1461032457600080fd5b8063cfdf677e14610304578063d0f893441461030c57600080fd5b80638d38c6c1116100b25780638d38c6c1146102cc578063b8f77005146102d5578063c2cf696f146102dd57600080fd5b80637aa63a86146102bb578063876ed5cb146102c357600080fd5b80635ae6256d116101245780637350d2b6116101095780637350d2b61461028257806378f4b2f2146102a95780637a167a8a146102b357600080fd5b80635ae6256d146102655780636fee07e01461026d57600080fd5b8063378997701161015557806337899770146101ff578063461a44781461021d57806346a8d4db1461023057600080fd5b8063299ca478146101715780632a7f18be146101bb575b600080fd5b6000546101919073ffffffffffffffffffffffffffffffffffffffff1681565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020015b60405180910390f35b6101ce6101c93660046115db565b61032c565b604080518251815260208084015164ffffffffff9081169183019190915292820151909216908201526060016101b2565b610207610360565b60405164ffffffffff90911681526020016101b2565b61019161022b3660046116b7565b610374565b6102577f000000000000000000000000000000000000000000000000000000000000000081565b6040519081526020016101b2565b61020761041b565b61028061027b36600461172d565b61042f565b005b6102577f000000000000000000000000000000000000000000000000000000000000000081565b610257620186a081565b6102076109c8565b6102576109dd565b61025761c35081565b61025760015481565b6102076109f8565b6102577f000000000000000000000000000000000000000000000000000000000000000081565b610191610a0f565b610280610a32565b610191610efe565b610257610f3e565b610207610fc5565b604080516060810182526000808252602082018190529181019190915261035a82610355610efe565b610fe1565b92915050565b60008061036b61119c565b50949350505050565b600080546040517fbf40fac100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff9091169063bf40fac1906103cb908590600401611805565b60206040518083038186803b1580156103e357600080fd5b505afa1580156103f7573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061035a919061181f565b60008061042661119c565b95945050505050565b61c350815111156104c7576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603d60248201527f5472616e73616374696f6e20646174612073697a652065786365656473206d6160448201527f78696d756d20666f7220726f6c6c7570207472616e73616374696f6e2e00000060648201526084015b60405180910390fd5b600154821115610559576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603d60248201527f5472616e73616374696f6e20676173206c696d69742065786365656473206d6160448201527f78696d756d20666f7220726f6c6c7570207472616e73616374696f6e2e00000060648201526084016104be565b620186a08210156105ec576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602960248201527f5472616e73616374696f6e20676173206c696d697420746f6f206c6f7720746f60448201527f20656e71756575652e000000000000000000000000000000000000000000000060648201526084016104be565b7f000000000000000000000000000000000000000000000000000000000000000082111561072c5760007f00000000000000000000000000000000000000000000000000000000000000006106617f00000000000000000000000000000000000000000000000000000000000000008561186b565b61066b9190611882565b905060005a9050818111610701576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f496e73756666696369656e742067617320666f72204c322072617465206c696d60448201527f6974696e67206275726e2e00000000000000000000000000000000000000000060648201526084016104be565b60005b825a610710908461186b565b10156107285780610720816118bd565b915050610704565b5050505b60003332141561073d575033610756565b5033731111000000000000000000000000000000001111015b60008185858560405160200161076f94939291906118f6565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0818403018152919052805160209091012090504360281b421760006107b7610efe565b6040517fb298e36b0000000000000000000000000000000000000000000000000000000081526004810185905290915073ffffffffffffffffffffffffffffffffffffffff82169063b298e36b90602401600060405180830381600087803b15801561082257600080fd5b505af1158015610836573d6000803e3d6000fd5b50506040517fb298e36b0000000000000000000000000000000000000000000000000000000081526004810185905273ffffffffffffffffffffffffffffffffffffffff8416925063b298e36b9150602401600060405180830381600087803b1580156108a257600080fd5b505af11580156108b6573d6000803e3d6000fd5b505050506000600160028373ffffffffffffffffffffffffffffffffffffffff16631f7b6d326040518163ffffffff1660e01b815260040160206040518083038186803b15801561090657600080fd5b505afa15801561091a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061093e919061193f565b6109489190611882565b610952919061186b565b9050808873ffffffffffffffffffffffffffffffffffffffff168673ffffffffffffffffffffffffffffffffffffffff167f4b388aecf9fa6cc92253704e5975a6129a4f735bdbd99567df4ed0094ee4ceb58a8a426040516109b693929190611958565b60405180910390a45050505050505050565b6000806109d361119c565b5090949350505050565b6000806109e861119c565b50505064ffffffffff1692915050565b6000610a0a610a05610efe565b611257565b905090565b6000610a0a604051806060016040528060218152602001611aed60219139610374565b60043560d81c60093560e890811c90600c35901c610a4e6109dd565b8364ffffffffff1614610ae3576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603d60248201527f41637475616c20626174636820737461727420696e64657820646f6573206e6f60448201527f74206d6174636820657870656374656420737461727420696e6465782e00000060648201526084016104be565b610b216040518060400160405280600d81526020017f4f564d5f53657175656e63657200000000000000000000000000000000000000815250610374565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614610bdb576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602d60248201527f46756e6374696f6e2063616e206f6e6c792062652063616c6c6564206279207460448201527f68652053657175656e6365722e0000000000000000000000000000000000000060648201526084016104be565b6000610bed62ffffff83166010611981565b610bf890600f6119be565b905064ffffffffff8116361015610c91576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602260248201527f4e6f7420656e6f756768204261746368436f6e74657874732070726f7669646560448201527f642e00000000000000000000000000000000000000000000000000000000000060648201526084016104be565b6000610c9b610efe565b90506000610ca882611257565b9050600080610cb56109c8565b9050610ce26040518060800160405280600081526020016000815260200160008152602001600081525090565b60005b8762ffffff168163ffffffff161015610d43576000610d098263ffffffff166112e3565b8051909350839150610d1b90866119d6565b9450826020015184610d2d91906119fe565b9350508080610d3b90611a1e565b915050610ce5565b508364ffffffffff168264ffffffffff161115610e08576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152604260248201527f417474656d7074656420746f20617070656e64206d6f726520656c656d656e7460448201527f73207468616e2061726520617661696c61626c6520696e20746865207175657560648201527f652e000000000000000000000000000000000000000000000000000000000000608482015260a4016104be565b6000610e198462ffffff8b16611a42565b63ffffffff169050600080836020015160001415610e4257505060408201516060830151610e71565b6000610e5f610e52600188611a67565b64ffffffffff168a610fe1565b90508060200151925080604001519150505b610e95610e7f60014361186b565b408c62ffffff168564ffffffffff16858561136a565b7f602f1aeac0ca2e7a13e281a9ef0ad7838542712ce16780fa2ecffd351f05f899610ec08487611a67565b84610ec96109dd565b6040805164ffffffffff94851681529390921660208401529082015260600160405180910390a1505050505050505050505050565b6000610a0a6040518060400160405280601f81526020017f436861696e53746f72616765436f6e7461696e65722d4354432d717565756500815250610374565b6000610f48610a0f565b73ffffffffffffffffffffffffffffffffffffffff16631f7b6d326040518163ffffffff1660e01b815260040160206040518083038186803b158015610f8d57600080fd5b505afa158015610fa1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a0a919061193f565b6000610fcf6109c8565b610fd76109f8565b610a0a9190611a67565b6040805160608101825260008082526020820181905291810182905290611009846002611981565b6040517f9507d39a00000000000000000000000000000000000000000000000000000000815264ffffffffff8216600482015290915060009073ffffffffffffffffffffffffffffffffffffffff851690639507d39a9060240160206040518083038186803b15801561107b57600080fd5b505afa15801561108f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110b3919061193f565b9050600073ffffffffffffffffffffffffffffffffffffffff8516639507d39a6110de8560016119fe565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e084901b16815264ffffffffff909116600482015260240160206040518083038186803b15801561113357600080fd5b505afa158015611147573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061116b919061193f565b6040805160608101825293845264ffffffffff828116602086015260289290921c9091169083015250949350505050565b60008060008060006111ac610a0f565b73ffffffffffffffffffffffffffffffffffffffff1663ccf8f9696040518163ffffffff1660e01b815260040160206040518083038186803b1580156111f157600080fd5b505afa158015611205573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112299190611a85565b64ffffffffff602882901c811697605083901c82169750607883901c8216965060a09290921c169350915050565b600060028273ffffffffffffffffffffffffffffffffffffffff16631f7b6d326040518163ffffffff1660e01b815260040160206040518083038186803b1580156112a157600080fd5b505afa1580156112b5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112d9919061193f565b61035a9190611882565b61130e6040518060800160405280600081526020016000815260200160008152602001600081525090565b600061131b601084611981565b61132690600f6119be565b60408051608081018252823560e890811c82526003840135901c6020820152600683013560d890811c92820192909252600b90920135901c60608201529392505050565b6000611374610a0f565b905060008061138161119c565b50509150915060006040518060a001604052808573ffffffffffffffffffffffffffffffffffffffff16631f7b6d326040518163ffffffff1660e01b815260040160206040518083038186803b1580156113da57600080fd5b505afa1580156113ee573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611412919061193f565b81526020018a81526020018981526020018464ffffffffff16815260200160405180602001604052806000815250815250905080600001517f127186556e7be68c7e31263195225b4de02820707889540969f62c05cf73525e826020015183604001518460600151856080015160405161148f9493929190611ac7565b60405180910390a260006114a282611595565b905060006114dd8360400151866114b991906119fe565b6114c38b876119fe565b602890811b9190911760508b901b1760788a901b17901b90565b6040517f2015276c000000000000000000000000000000000000000000000000000000008152600481018490527fffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000008216602482015290915073ffffffffffffffffffffffffffffffffffffffff871690632015276c90604401600060405180830381600087803b15801561157057600080fd5b505af1158015611584573d6000803e3d6000fd5b505050505050505050505050505050565b600081602001518260400151836060015184608001516040516020016115be9493929190611ac7565b604051602081830303815290604052805190602001209050919050565b6000602082840312156115ed57600080fd5b5035919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600067ffffffffffffffff8084111561163e5761163e6115f4565b604051601f85017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908282118183101715611684576116846115f4565b8160405280935085815286868601111561169d57600080fd5b858560208301376000602087830101525050509392505050565b6000602082840312156116c957600080fd5b813567ffffffffffffffff8111156116e057600080fd5b8201601f810184136116f157600080fd5b61170084823560208401611623565b949350505050565b73ffffffffffffffffffffffffffffffffffffffff8116811461172a57600080fd5b50565b60008060006060848603121561174257600080fd5b833561174d81611708565b925060208401359150604084013567ffffffffffffffff81111561177057600080fd5b8401601f8101861361178157600080fd5b61179086823560208401611623565b9150509250925092565b6000815180845260005b818110156117c0576020818501810151868301820152016117a4565b818111156117d2576000602083870101525b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b602081526000611818602083018461179a565b9392505050565b60006020828403121561183157600080fd5b815161181881611708565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60008282101561187d5761187d61183c565b500390565b6000826118b8577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500490565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8214156118ef576118ef61183c565b5060010190565b600073ffffffffffffffffffffffffffffffffffffffff808716835280861660208401525083604083015260806060830152611935608083018461179a565b9695505050505050565b60006020828403121561195157600080fd5b5051919050565b838152606060208201526000611971606083018561179a565b9050826040830152949350505050565b6000817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff04831182151516156119b9576119b961183c565b500290565b600082198211156119d1576119d161183c565b500190565b600063ffffffff8083168185168083038211156119f5576119f561183c565b01949350505050565b600064ffffffffff8083168185168083038211156119f5576119f561183c565b600063ffffffff80831681811415611a3857611a3861183c565b6001019392505050565b600063ffffffff83811690831681811015611a5f57611a5f61183c565b039392505050565b600064ffffffffff83811690831681811015611a5f57611a5f61183c565b600060208284031215611a9757600080fd5b81517fffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000008116811461181857600080fd5b848152836020820152826040820152608060608201526000611935608083018461179a56fe436861696e53746f72616765436f6e7461696e65722d4354432d62617463686573a164736f6c6343000809000a",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061016c5760003560e01c80637aa63a86116100cd578063cfdf677e11610081578063e10d29ee11610066578063e10d29ee14610314578063e561dddc1461031c578063f722b41a1461032457600080fd5b8063cfdf677e14610304578063d0f893441461030c57600080fd5b80638d38c6c1116100b25780638d38c6c1146102cc578063b8f77005146102d5578063c2cf696f146102dd57600080fd5b80637aa63a86146102bb578063876ed5cb146102c357600080fd5b80635ae6256d116101245780637350d2b6116101095780637350d2b61461028257806378f4b2f2146102a95780637a167a8a146102b357600080fd5b80635ae6256d146102655780636fee07e01461026d57600080fd5b8063378997701161015557806337899770146101ff578063461a44781461021d57806346a8d4db1461023057600080fd5b8063299ca478146101715780632a7f18be146101bb575b600080fd5b6000546101919073ffffffffffffffffffffffffffffffffffffffff1681565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020015b60405180910390f35b6101ce6101c93660046115db565b61032c565b604080518251815260208084015164ffffffffff9081169183019190915292820151909216908201526060016101b2565b610207610360565b60405164ffffffffff90911681526020016101b2565b61019161022b3660046116b7565b610374565b6102577f000000000000000000000000000000000000000000000000000000000000000081565b6040519081526020016101b2565b61020761041b565b61028061027b36600461172d565b61042f565b005b6102577f000000000000000000000000000000000000000000000000000000000000000081565b610257620186a081565b6102076109c8565b6102576109dd565b61025761c35081565b61025760015481565b6102076109f8565b6102577f000000000000000000000000000000000000000000000000000000000000000081565b610191610a0f565b610280610a32565b610191610efe565b610257610f3e565b610207610fc5565b604080516060810182526000808252602082018190529181019190915261035a82610355610efe565b610fe1565b92915050565b60008061036b61119c565b50949350505050565b600080546040517fbf40fac100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff9091169063bf40fac1906103cb908590600401611805565b60206040518083038186803b1580156103e357600080fd5b505afa1580156103f7573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061035a919061181f565b60008061042661119c565b95945050505050565b61c350815111156104c7576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603d60248201527f5472616e73616374696f6e20646174612073697a652065786365656473206d6160448201527f78696d756d20666f7220726f6c6c7570207472616e73616374696f6e2e00000060648201526084015b60405180910390fd5b600154821115610559576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603d60248201527f5472616e73616374696f6e20676173206c696d69742065786365656473206d6160448201527f78696d756d20666f7220726f6c6c7570207472616e73616374696f6e2e00000060648201526084016104be565b620186a08210156105ec576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602960248201527f5472616e73616374696f6e20676173206c696d697420746f6f206c6f7720746f60448201527f20656e71756575652e000000000000000000000000000000000000000000000060648201526084016104be565b7f000000000000000000000000000000000000000000000000000000000000000082111561072c5760007f00000000000000000000000000000000000000000000000000000000000000006106617f00000000000000000000000000000000000000000000000000000000000000008561186b565b61066b9190611882565b905060005a9050818111610701576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f496e73756666696369656e742067617320666f72204c322072617465206c696d60448201527f6974696e67206275726e2e00000000000000000000000000000000000000000060648201526084016104be565b60005b825a610710908461186b565b10156107285780610720816118bd565b915050610704565b5050505b60003332141561073d575033610756565b5033731111000000000000000000000000000000001111015b60008185858560405160200161076f94939291906118f6565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0818403018152919052805160209091012090504360281b421760006107b7610efe565b6040517fb298e36b0000000000000000000000000000000000000000000000000000000081526004810185905290915073ffffffffffffffffffffffffffffffffffffffff82169063b298e36b90602401600060405180830381600087803b15801561082257600080fd5b505af1158015610836573d6000803e3d6000fd5b50506040517fb298e36b0000000000000000000000000000000000000000000000000000000081526004810185905273ffffffffffffffffffffffffffffffffffffffff8416925063b298e36b9150602401600060405180830381600087803b1580156108a257600080fd5b505af11580156108b6573d6000803e3d6000fd5b505050506000600160028373ffffffffffffffffffffffffffffffffffffffff16631f7b6d326040518163ffffffff1660e01b815260040160206040518083038186803b15801561090657600080fd5b505afa15801561091a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061093e919061193f565b6109489190611882565b610952919061186b565b9050808873ffffffffffffffffffffffffffffffffffffffff168673ffffffffffffffffffffffffffffffffffffffff167f4b388aecf9fa6cc92253704e5975a6129a4f735bdbd99567df4ed0094ee4ceb58a8a426040516109b693929190611958565b60405180910390a45050505050505050565b6000806109d361119c565b5090949350505050565b6000806109e861119c565b50505064ffffffffff1692915050565b6000610a0a610a05610efe565b611257565b905090565b6000610a0a604051806060016040528060218152602001611aed60219139610374565b60043560d81c60093560e890811c90600c35901c610a4e6109dd565b8364ffffffffff1614610ae3576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603d60248201527f41637475616c20626174636820737461727420696e64657820646f6573206e6f60448201527f74206d6174636820657870656374656420737461727420696e6465782e00000060648201526084016104be565b610b216040518060400160405280600d81526020017f4f564d5f53657175656e63657200000000000000000000000000000000000000815250610374565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614610bdb576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602d60248201527f46756e6374696f6e2063616e206f6e6c792062652063616c6c6564206279207460448201527f68652053657175656e6365722e0000000000000000000000000000000000000060648201526084016104be565b6000610bed62ffffff83166010611981565b610bf890600f6119be565b905064ffffffffff8116361015610c91576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602260248201527f4e6f7420656e6f756768204261746368436f6e74657874732070726f7669646560448201527f642e00000000000000000000000000000000000000000000000000000000000060648201526084016104be565b6000610c9b610efe565b90506000610ca882611257565b9050600080610cb56109c8565b9050610ce26040518060800160405280600081526020016000815260200160008152602001600081525090565b60005b8762ffffff168163ffffffff161015610d43576000610d098263ffffffff166112e3565b8051909350839150610d1b90866119d6565b9450826020015184610d2d91906119fe565b9350508080610d3b90611a1e565b915050610ce5565b508364ffffffffff168264ffffffffff161115610e08576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152604260248201527f417474656d7074656420746f20617070656e64206d6f726520656c656d656e7460448201527f73207468616e2061726520617661696c61626c6520696e20746865207175657560648201527f652e000000000000000000000000000000000000000000000000000000000000608482015260a4016104be565b6000610e198462ffffff8b16611a42565b63ffffffff169050600080836020015160001415610e4257505060408201516060830151610e71565b6000610e5f610e52600188611a67565b64ffffffffff168a610fe1565b90508060200151925080604001519150505b610e95610e7f60014361186b565b408c62ffffff168564ffffffffff16858561136a565b7f602f1aeac0ca2e7a13e281a9ef0ad7838542712ce16780fa2ecffd351f05f899610ec08487611a67565b84610ec96109dd565b6040805164ffffffffff94851681529390921660208401529082015260600160405180910390a1505050505050505050505050565b6000610a0a6040518060400160405280601f81526020017f436861696e53746f72616765436f6e7461696e65722d4354432d717565756500815250610374565b6000610f48610a0f565b73ffffffffffffffffffffffffffffffffffffffff16631f7b6d326040518163ffffffff1660e01b815260040160206040518083038186803b158015610f8d57600080fd5b505afa158015610fa1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a0a919061193f565b6000610fcf6109c8565b610fd76109f8565b610a0a9190611a67565b6040805160608101825260008082526020820181905291810182905290611009846002611981565b6040517f9507d39a00000000000000000000000000000000000000000000000000000000815264ffffffffff8216600482015290915060009073ffffffffffffffffffffffffffffffffffffffff851690639507d39a9060240160206040518083038186803b15801561107b57600080fd5b505afa15801561108f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110b3919061193f565b9050600073ffffffffffffffffffffffffffffffffffffffff8516639507d39a6110de8560016119fe565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e084901b16815264ffffffffff909116600482015260240160206040518083038186803b15801561113357600080fd5b505afa158015611147573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061116b919061193f565b6040805160608101825293845264ffffffffff828116602086015260289290921c9091169083015250949350505050565b60008060008060006111ac610a0f565b73ffffffffffffffffffffffffffffffffffffffff1663ccf8f9696040518163ffffffff1660e01b815260040160206040518083038186803b1580156111f157600080fd5b505afa158015611205573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112299190611a85565b64ffffffffff602882901c811697605083901c82169750607883901c8216965060a09290921c169350915050565b600060028273ffffffffffffffffffffffffffffffffffffffff16631f7b6d326040518163ffffffff1660e01b815260040160206040518083038186803b1580156112a157600080fd5b505afa1580156112b5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112d9919061193f565b61035a9190611882565b61130e6040518060800160405280600081526020016000815260200160008152602001600081525090565b600061131b601084611981565b61132690600f6119be565b60408051608081018252823560e890811c82526003840135901c6020820152600683013560d890811c92820192909252600b90920135901c60608201529392505050565b6000611374610a0f565b905060008061138161119c565b50509150915060006040518060a001604052808573ffffffffffffffffffffffffffffffffffffffff16631f7b6d326040518163ffffffff1660e01b815260040160206040518083038186803b1580156113da57600080fd5b505afa1580156113ee573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611412919061193f565b81526020018a81526020018981526020018464ffffffffff16815260200160405180602001604052806000815250815250905080600001517f127186556e7be68c7e31263195225b4de02820707889540969f62c05cf73525e826020015183604001518460600151856080015160405161148f9493929190611ac7565b60405180910390a260006114a282611595565b905060006114dd8360400151866114b991906119fe565b6114c38b876119fe565b602890811b9190911760508b901b1760788a901b17901b90565b6040517f2015276c000000000000000000000000000000000000000000000000000000008152600481018490527fffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000008216602482015290915073ffffffffffffffffffffffffffffffffffffffff871690632015276c90604401600060405180830381600087803b15801561157057600080fd5b505af1158015611584573d6000803e3d6000fd5b505050505050505050505050505050565b600081602001518260400151836060015184608001516040516020016115be9493929190611ac7565b604051602081830303815290604052805190602001209050919050565b6000602082840312156115ed57600080fd5b5035919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600067ffffffffffffffff8084111561163e5761163e6115f4565b604051601f85017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908282118183101715611684576116846115f4565b8160405280935085815286868601111561169d57600080fd5b858560208301376000602087830101525050509392505050565b6000602082840312156116c957600080fd5b813567ffffffffffffffff8111156116e057600080fd5b8201601f810184136116f157600080fd5b61170084823560208401611623565b949350505050565b73ffffffffffffffffffffffffffffffffffffffff8116811461172a57600080fd5b50565b60008060006060848603121561174257600080fd5b833561174d81611708565b925060208401359150604084013567ffffffffffffffff81111561177057600080fd5b8401601f8101861361178157600080fd5b61179086823560208401611623565b9150509250925092565b6000815180845260005b818110156117c0576020818501810151868301820152016117a4565b818111156117d2576000602083870101525b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b602081526000611818602083018461179a565b9392505050565b60006020828403121561183157600080fd5b815161181881611708565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60008282101561187d5761187d61183c565b500390565b6000826118b8577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500490565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8214156118ef576118ef61183c565b5060010190565b600073ffffffffffffffffffffffffffffffffffffffff808716835280861660208401525083604083015260806060830152611935608083018461179a565b9695505050505050565b60006020828403121561195157600080fd5b5051919050565b838152606060208201526000611971606083018561179a565b9050826040830152949350505050565b6000817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff04831182151516156119b9576119b961183c565b500290565b600082198211156119d1576119d161183c565b500190565b600063ffffffff8083168185168083038211156119f5576119f561183c565b01949350505050565b600064ffffffffff8083168185168083038211156119f5576119f561183c565b600063ffffffff80831681811415611a3857611a3861183c565b6001019392505050565b600063ffffffff83811690831681811015611a5f57611a5f61183c565b039392505050565b600064ffffffffff83811690831681811015611a5f57611a5f61183c565b600060208284031215611a9757600080fd5b81517fffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000008116811461181857600080fd5b848152836020820152826040820152608060608201526000611935608083018461179a56fe436861696e53746f72616765436f6e7461696e65722d4354432d62617463686573a164736f6c6343000809000a",
  "devdoc": {
    "details": "The Canonical Transaction Chain (CTC) contract is an append-only log of transactions which must be applied to the rollup state. It defines the ordering of rollup transactions by writing them to the 'CTC:batches' instance of the Chain Storage Container. The CTC also allows any account to 'enqueue' an L2 transaction, which will require that the Sequencer will eventually append it to the rollup state. Runtime target: EVM",
    "kind": "dev",
    "methods": {
      "appendSequencerBatch()": {
        "details": "This function uses a custom encoding scheme for efficiency reasons. .param _shouldStartAtElement Specific batch we expect to start appending to. .param _totalElementsToAppend Total number of batch elements we expect to append. .param _contexts Array of batch contexts. .param _transactionDataFields Array of raw transaction data."
      },
      "batches()": {
        "returns": {
          "_0": "Reference to the batch storage container."
        }
      },
      "enqueue(address,uint256,bytes)": {
        "params": {
          "_data": "Transaction data.",
          "_gasLimit": "Gas limit for the enqueued L2 transaction.",
          "_target": "Target L2 contract to send the transaction to."
        }
      },
      "getLastBlockNumber()": {
        "returns": {
          "_0": "Blocknumber for the last transaction."
        }
      },
      "getLastTimestamp()": {
        "returns": {
          "_0": "Timestamp for the last transaction."
        }
      },
      "getNextQueueIndex()": {
        "returns": {
          "_0": "Index for the next queue element."
        }
      },
      "getNumPendingQueueElements()": {
        "returns": {
          "_0": "Number of pending queue elements."
        }
      },
      "getQueueElement(uint256)": {
        "params": {
          "_index": "Index of the queue element to access."
        },
        "returns": {
          "_element": "Queue element at the given index."
        }
      },
      "getQueueLength()": {
        "returns": {
          "_0": "Length of the queue."
        }
      },
      "getTotalBatches()": {
        "returns": {
          "_totalBatches": "Total submitted batches."
        }
      },
      "getTotalElements()": {
        "returns": {
          "_totalElements": "Total submitted elements."
        }
      },
      "queue()": {
        "returns": {
          "_0": "Reference to the queue storage container."
        }
      },
      "resolve(string)": {
        "params": {
          "_name": "Name to resolve an address for."
        },
        "returns": {
          "_0": "Address associated with the given name."
        }
      }
    },
    "title": "CanonicalTransactionChain",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "appendSequencerBatch()": {
        "notice": "Allows the sequencer to append a batch of transactions."
      },
      "batches()": {
        "notice": "Accesses the batch storage container."
      },
      "enqueue(address,uint256,bytes)": {
        "notice": "Adds a transaction to the queue."
      },
      "getLastBlockNumber()": {
        "notice": "Returns the blocknumber of the last transaction."
      },
      "getLastTimestamp()": {
        "notice": "Returns the timestamp of the last transaction."
      },
      "getNextQueueIndex()": {
        "notice": "Returns the index of the next element to be enqueued."
      },
      "getNumPendingQueueElements()": {
        "notice": "Get the number of queue elements which have not yet been included."
      },
      "getQueueElement(uint256)": {
        "notice": "Gets the queue element at a particular index."
      },
      "getQueueLength()": {
        "notice": "Retrieves the length of the queue, including both pending and canonical transactions."
      },
      "getTotalBatches()": {
        "notice": "Retrieves the total number of batches submitted."
      },
      "getTotalElements()": {
        "notice": "Retrieves the total number of elements submitted."
      },
      "queue()": {
        "notice": "Accesses the queue storage container."
      },
      "resolve(string)": {
        "notice": "Resolves the address associated with a given name."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 6572,
        "contract": "contracts/L1/rollup/CanonicalTransactionChain.sol:CanonicalTransactionChain",
        "label": "libAddressManager",
        "offset": 0,
        "slot": "0",
        "type": "t_contract(Lib_AddressManager)6564"
      },
      {
        "astId": 3162,
        "contract": "contracts/L1/rollup/CanonicalTransactionChain.sol:CanonicalTransactionChain",
        "label": "maxTransactionGasLimit",
        "offset": 0,
        "slot": "1",
        "type": "t_uint256"
      }
    ],
    "types": {
      "t_contract(Lib_AddressManager)6564": {
        "encoding": "inplace",
        "label": "contract Lib_AddressManager",
        "numberOfBytes": "20"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}