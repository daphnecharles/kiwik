import { Signer, BigNumber, providers } from 'ethers';
import { L1GatewayRouter } from './abi/L1GatewayRouter';
import { L1ERC20Gateway } from './abi/L1ERC20Gateway';
import { Inbox } from './abi/Inbox';
import { ERC20 } from './abi/ERC20';
import { PayableOverrides } from '@ethersproject/contracts';
export interface L1TokenData {
    ERC20?: {
        contract: ERC20;
        balance: BigNumber;
        allowed: boolean;
        symbol: string;
        decimals: number;
        name: string;
    };
    CUSTOM?: {
        contract: ERC20;
        balance: BigNumber;
        allowed: boolean;
        symbol: string;
    };
}
export interface Tokens {
    [contractAddress: string]: L1TokenData | undefined;
}
/**
 * L1 side only of {@link Bridge}
 */
export declare class L1Bridge {
    l1Signer: Signer;
    l1GatewayRouter: L1GatewayRouter;
    walletAddressCache?: string;
    inboxCached?: Inbox;
    l1Tokens: Tokens;
    l1Provider: providers.Provider;
    l1EthBalance: BigNumber;
    constructor(l1GatewayRouterAddress: string, l1Signer: Signer);
    updateAllL1Tokens(): Promise<Tokens>;
    getERC20L2Address(erc20L1Address: string): Promise<string>;
    getAndUpdateL1TokenData(erc20L1Address: string): Promise<L1TokenData>;
    depositETH(value: BigNumber, maxSubmissionPrice: BigNumber, overrides?: PayableOverrides): Promise<import("ethers").ContractTransaction>;
    getGatewayAddress(erc20L1Address: string): Promise<string>;
    getDefaultL1Gateway(): Promise<L1ERC20Gateway>;
    approveToken(erc20L1Address: string, overrides?: PayableOverrides): Promise<import("ethers").ContractTransaction>;
    deposit(erc20L1Address: string, amount: BigNumber, maxSubmissionCost: BigNumber, maxGas: BigNumber, gasPriceBid: BigNumber, destinationAddress?: string, overrides?: PayableOverrides): Promise<import("ethers").ContractTransaction>;
    getWalletAddress(): Promise<string>;
    getInbox(): Promise<Inbox>;
    getAndUpdateL1EthBalance(): Promise<BigNumber>;
}
