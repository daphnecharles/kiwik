/*
 * Copyright 2021, Offchain Labs, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* eslint-env node */
'use strict';
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bridge = void 0;
const ethers_1 = require("ethers");
const l1Bridge_1 = require("./l1Bridge");
const l2Bridge_1 = require("./l2Bridge");
const bridge_helpers_1 = require("./bridge_helpers");
const precompile_addresses_1 = require("./precompile_addresses");
const NodeInterface__factory_1 = require("./abi/factories/NodeInterface__factory");
const L1ERC20Gateway__factory_1 = require("./abi/factories/L1ERC20Gateway__factory");
const networks_1 = __importDefault(require("./networks"));
/**
 * Main class for accessing token bridge methods; inherits methods from {@link L1Bridge} and {@link L2Bridge}
 */
class Bridge {
    constructor(l1BridgeObj, l2BridgeObj) {
        this.l1Bridge = l1BridgeObj;
        this.l2Bridge = l2BridgeObj;
    }
    updateAllBalances() {
        this.updateAllTokens();
        this.getAndUpdateL1EthBalance();
        this.getAndUpdateL2EthBalance();
    }
    static async init(ethSigner, arbSigner, l1GatewayRouterAddress, l2GatewayRouterAddress) {
        if (!ethSigner.provider || !arbSigner.provider) {
            throw new Error('Signer needs a provider');
        }
        const ethSignerAddress = await ethSigner.getAddress();
        const arbSignerAddress = await arbSigner.getAddress();
        const l1ChainId = await ethSigner.getChainId();
        const l2ChainId = await arbSigner.getChainId();
        if (ethSignerAddress !== arbSignerAddress) {
            throw new Error('L1 & L2 wallets must be of the same address');
        }
        else {
            if (!l2GatewayRouterAddress) {
                const currNetwork = networks_1.default[l2ChainId];
                if (currNetwork.l2.chainId !== l2ChainId) {
                    throw new Error('WRONG L2 CHAIN ID');
                }
                l2GatewayRouterAddress = currNetwork.l2.l2GatewayRouter;
            }
            if (!l1GatewayRouterAddress) {
                const currNetwork = networks_1.default[l2ChainId];
                if (currNetwork.l1.chainId !== l1ChainId) {
                    throw new Error('WRONG L1 CHAIN ID');
                }
                l1GatewayRouterAddress = currNetwork.l1.l1GatewayRouter;
            }
        }
        // check routers are deployed
        const l1RouterCode = await ethSigner.provider.getCode(l1GatewayRouterAddress);
        if (l1RouterCode === '0x') {
            throw new Error(`No code deployed to ${l1GatewayRouterAddress} in the L1`);
        }
        const l2RouterCode = await arbSigner.provider.getCode(l2GatewayRouterAddress);
        if (l2RouterCode === '0x') {
            throw new Error(`No code deployed to ${l2GatewayRouterAddress} in the L2`);
        }
        const l1BridgeObj = new l1Bridge_1.L1Bridge(l1GatewayRouterAddress, ethSigner);
        const l2BridgeObj = new l2Bridge_1.L2Bridge(l2GatewayRouterAddress, arbSigner);
        return new Bridge(l1BridgeObj, l2BridgeObj);
    }
    /**
     * Update state of all tracked tokens (balance, allowance), etc. and returns state
     */
    async updateAllTokens() {
        const l1Tokens = await this.l1Bridge.updateAllL1Tokens();
        const l2Tokens = await this.l2Bridge.updateAllL2Tokens();
        return { l1Tokens, l2Tokens };
    }
    /**
     * Update target token (balance, allowance), etc. and state
     */
    async updateTokenData(erc20l1Address) {
        const l1Data = await this.getAndUpdateL1TokenData(erc20l1Address);
        const l2Data = await this.getAndUpdateL2TokenData(erc20l1Address);
        return { l1Data, l2Data };
    }
    get l1Tokens() {
        return this.l1Bridge.l1Tokens;
    }
    get l1EthBalance() {
        return this.l1Bridge.l1EthBalance;
    }
    get l1GatewayRouter() {
        return this.l1Bridge.l1GatewayRouter;
    }
    defaultL1Gateway() {
        return this.l1Bridge.getDefaultL1Gateway();
    }
    /**
     * Set allowance for L1 router contract
     */
    async approveToken(erc20L1Address, overrides) {
        return this.l1Bridge.approveToken(erc20L1Address, overrides);
    }
    /**
     * Deposit ether from L1 to L2.
     */
    async depositETH(value, _maxSubmissionPriceIncreaseRatio, overrides) {
        const maxSubmissionPriceIncreaseRatio = _maxSubmissionPriceIncreaseRatio || ethers_1.BigNumber.from(13);
        const maxSubmissionPrice = (await this.l2Bridge.getTxnSubmissionPrice(0))[0]
            .mul(maxSubmissionPriceIncreaseRatio)
            .div(ethers_1.BigNumber.from(10));
        return this.l1Bridge.depositETH(value, maxSubmissionPrice, overrides);
    }
    /**
     * Token deposit; if no value given, calculates and includes minimum necessary value to fund L2 side of execution
     */
    async deposit(erc20L1Address, amount, retryableGasArgs = {}, destinationAddress, overrides) {
        const gasPriceBid = retryableGasArgs.gasPriceBid ||
            (await this.l2Bridge.l2Provider.getGasPrice());
        const sender = await this.l1Bridge.l1Signer.getAddress();
        const expectedL1GatewayAddress = await this.l1Bridge.getGatewayAddress(erc20L1Address);
        const l1Gateway = L1ERC20Gateway__factory_1.L1ERC20Gateway__factory.connect(expectedL1GatewayAddress, this.l1Bridge.l1Provider);
        const depositCalldata = await l1Gateway.getOutboundCalldata(erc20L1Address, sender, destinationAddress ? destinationAddress : sender, amount, '0x');
        const maxSubmissionPriceIncreaseRatio = retryableGasArgs.maxSubmissionPriceIncreaseRatio || ethers_1.BigNumber.from(13);
        const maxSubmissionPrice = (await this.l2Bridge.getTxnSubmissionPrice(depositCalldata.length - 2))[0]
            .mul(maxSubmissionPriceIncreaseRatio)
            .div(ethers_1.BigNumber.from(10));
        const nodeInterface = NodeInterface__factory_1.NodeInterface__factory.connect(precompile_addresses_1.NODE_INTERFACE_ADDRESS, this.l2Bridge.l2Provider);
        const l2Dest = await l1Gateway.counterpartGateway();
        const maxGas = (await nodeInterface.estimateRetryableTicket(expectedL1GatewayAddress, ethers_1.ethers.utils.parseEther('0.05'), l2Dest, 0, maxSubmissionPrice, sender, sender, 0, 0, depositCalldata))[0];
        console.log('DONE ESTIMATING GAS');
        // calculate required forwarding gas
        let ethDeposit = overrides && (await overrides.value);
        if (!ethDeposit || ethers_1.BigNumber.from(ethDeposit).isZero()) {
            ethDeposit = await maxSubmissionPrice.add(gasPriceBid.mul(maxGas));
        }
        return this.l1Bridge.deposit(erc20L1Address, amount, maxSubmissionPrice, maxGas, gasPriceBid, destinationAddress, Object.assign(Object.assign({}, overrides), { value: ethDeposit }));
    }
    getAndUpdateL1TokenData(erc20l1Address) {
        return this.l1Bridge.getAndUpdateL1TokenData(erc20l1Address);
    }
    async getAndUpdateL2TokenData(erc20l1Address) {
        const l2TokenAddress = await this.l1Bridge.getERC20L2Address(erc20l1Address);
        return this.l2Bridge.getAndUpdateL2TokenData(erc20l1Address, l2TokenAddress);
    }
    async getAndUpdateL1EthBalance() {
        return this.l1Bridge.getAndUpdateL1EthBalance();
    }
    async getAndUpdateL2EthBalance() {
        return this.l2Bridge.getAndUpdateL2EthBalance();
    }
    getL2Transaction(l2TransactionHash) {
        return bridge_helpers_1.BridgeHelper.getL2Transaction(l2TransactionHash, this.l2Bridge.l2Provider);
    }
    getL1Transaction(l1TransactionHash) {
        return bridge_helpers_1.BridgeHelper.getL1Transaction(l1TransactionHash, this.l1Bridge.l1Provider);
    }
    /**
     * get hash of regular L2 txn from corresponding inbox sequence number
     */
    calculateL2TransactionHash(inboxSequenceNumber, l2ChainId) {
        return bridge_helpers_1.BridgeHelper.calculateL2TransactionHash(inboxSequenceNumber, l2ChainId || this.l2Bridge.l2Provider);
    }
    /**
     * Hash of L2 side of retryable txn; txn gets generated automatically and is formatted as tho user submitted
     */
    calculateL2RetryableTransactionHash(inboxSequenceNumber, l2ChainId) {
        return bridge_helpers_1.BridgeHelper.calculateL2RetryableTransactionHash(inboxSequenceNumber, l2ChainId || this.l2Bridge.l2Provider);
    }
    /**
     * Hash of L2 ArbOs generated "auto-redeem" transaction; if it succeeded, a transaction queryable by {@link calculateL2RetryableTransactionHash} will then be created
     */
    calculateRetryableAutoRedeemTxnHash(inboxSequenceNumber, l2ChainId) {
        return bridge_helpers_1.BridgeHelper.calculateRetryableAutoRedeemTxnHash(inboxSequenceNumber, l2ChainId || this.l2Bridge.l2Provider);
    }
    async getInboxSeqNumFromContractTransaction(l1Transaction) {
        return bridge_helpers_1.BridgeHelper.getInboxSeqNumFromContractTransaction(l1Transaction, 
        // TODO: we don't need to actually make this query if random address fetches interface
        (await this.l1Bridge.getInbox()).address);
    }
    /**
     * Convenience method to directly retrieve retryable hash from an l1 transaction
     */
    async getL2TxHashByRetryableTicket(l1Transaction) {
        if (typeof l1Transaction == 'string') {
            l1Transaction = await this.getL1Transaction(l1Transaction);
        }
        const inboxSeqNum = await this.getInboxSeqNumFromContractTransaction(l1Transaction);
        if (!inboxSeqNum)
            throw new Error('Inbox not triggered');
        return this.calculateL2RetryableTransactionHash(inboxSeqNum[0]);
    }
    getBuddyDeployInL2Transaction(l2Transaction) {
        return bridge_helpers_1.BridgeHelper.getBuddyDeployInL2Transaction(l2Transaction);
    }
    getWithdrawalsInL2Transaction(l2Transaction) {
        return bridge_helpers_1.BridgeHelper.getWithdrawalsInL2Transaction(l2Transaction, this.l2Bridge.l2Provider);
    }
    async getDepositTokenEventData(l1Transaction) {
        const defaultGatewayAddress = (await this.l1Bridge.getDefaultL1Gateway())
            .address;
        return bridge_helpers_1.BridgeHelper.getDepositTokenEventData(l1Transaction, defaultGatewayAddress);
    }
    /**
     * Attempt to execute an outbox message; must be confirmed to succeed (i.e., confirmation delay must have passed)
     */
    async triggerL2ToL1Transaction(batchNumber, indexInBatch, singleAttempt = false) {
        const inbox = await this.l1Bridge.getInbox();
        const bridgeAddress = await inbox.bridge();
        return bridge_helpers_1.BridgeHelper.triggerL2ToL1Transaction(batchNumber, indexInBatch, bridgeAddress, this.l2Bridge.l2Provider, this.l1Bridge.l1Signer, singleAttempt);
    }
    tryOutboxExecute(activeOutboxAddress, batchNumber, proof, path, l2Sender, l1Dest, l2Block, l1Block, timestamp, amount, calldataForL1) {
        return bridge_helpers_1.BridgeHelper.tryOutboxExecute({
            batchNumber,
            proof,
            path,
            l2Sender,
            l1Dest,
            l2Block,
            l1Block,
            timestamp,
            amount,
            calldataForL1,
        }, activeOutboxAddress, this.l1Bridge.l1Signer);
    }
    tryGetProofOnce(batchNumber, indexInBatch) {
        return bridge_helpers_1.BridgeHelper.tryGetProofOnce(batchNumber, indexInBatch, this.l2Bridge.l2Provider);
    }
    tryGetProof(batchNumber, indexInBatch, retryDelay = 500) {
        return bridge_helpers_1.BridgeHelper.tryGetProof(batchNumber, indexInBatch, this.l2Bridge.l2Provider, retryDelay);
    }
    waitUntilOutboxEntryCreated(batchNumber, activeOutboxAddress) {
        return bridge_helpers_1.BridgeHelper.waitUntilOutboxEntryCreated(batchNumber, activeOutboxAddress, this.l1Bridge.l1Provider);
    }
    /**
     * Return receipt of retryable transaction after execution
     */
    async waitForRetryableReceipt(seqNum) {
        return bridge_helpers_1.BridgeHelper.waitForRetryableReceipt(seqNum, this.l2Bridge.l2Provider);
    }
    async getTokenWithdrawEventData(l1TokenAddress, destinationAddress) {
        const l2ERC20Gateway = await this.l2Bridge.l2GatewayRouter.getGateway(l1TokenAddress);
        return bridge_helpers_1.BridgeHelper.getTokenWithdrawEventData(destinationAddress, l2ERC20Gateway, this.l2Bridge.l2Provider);
    }
    async getL2ToL1EventData(destinationAddress) {
        return bridge_helpers_1.BridgeHelper.getL2ToL1EventData(destinationAddress, this.l2Bridge.l2Provider);
    }
    async getOutboxAddress() {
        if (this.outboxAddressCache) {
            return this.outboxAddressCache;
        }
        const inboxAddress = (await this.l1Bridge.getInbox()).address;
        const coreBridgeAddress = await bridge_helpers_1.BridgeHelper.getCoreBridgeFromInbox(inboxAddress, this.l1Bridge.l1Provider);
        const outboxAddress = await bridge_helpers_1.BridgeHelper.getActiveOutbox(coreBridgeAddress, this.l1Bridge.l1Provider);
        this.outboxAddressCache = outboxAddress;
        return outboxAddress;
    }
    /**
     * Returns {@link OutgoingMessageState} for given outgoing message
     */
    async getOutGoingMessageState(batchNumber, indexInBatch) {
        const outboxAddress = await this.getOutboxAddress();
        return bridge_helpers_1.BridgeHelper.getOutgoingMessageState(batchNumber, indexInBatch, outboxAddress, this.l1Bridge.l1Provider, this.l2Bridge.l2Provider);
    }
    async getERC20L2Address(erc20L1Address) {
        return this.l1Bridge.getERC20L2Address(erc20L1Address);
    }
    async withdrawETH(value, destinationAddress, overrides) {
        return this.l2Bridge.withdrawETH(value, destinationAddress, overrides);
    }
    async withdrawERC20(erc20l1Address, amount, destinationAddress, overrides = {}) {
        return this.l2Bridge.withdrawERC20(erc20l1Address, amount, destinationAddress, overrides);
    }
    isWhiteListed(address, whiteListAddress) {
        return bridge_helpers_1.BridgeHelper.isWhiteListed(address, whiteListAddress, this.l1Bridge.l1Provider);
    }
}
exports.Bridge = Bridge;
